<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="Welcome to nnilk&#39;s daily learning blog" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>CPU虚拟化 |  nnilk&#39;s blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/images/logo2.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-CPU虚拟化"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  CPU虚拟化
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/03/11/CPU%E8%99%9A%E6%8B%9F%E5%8C%96/" class="article-date">
  <time datetime="2021-03-10T16:00:00.000Z" itemprop="datePublished">2021-03-11</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/The-Operating-System-Notes/">The-Operating-System-Notes</a>
  </div>
  
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">9.9k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">38 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="CPU-虚拟化"><a href="#CPU-虚拟化" class="headerlink" title="CPU 虚拟化"></a>CPU 虚拟化</h1><h2 id="第二章—操作系统介绍"><a href="#第二章—操作系统介绍" class="headerlink" title="第二章—操作系统介绍"></a>第二章—操作系统介绍</h2><h3 id="操作系统的任务"><a href="#操作系统的任务" class="headerlink" title="操作系统的任务"></a><strong>操作系统的任务</strong></h3><p>操作系统：负责确保系统既易于使用又正确高效地运行。</p>
<p>它取得 CPU、内存或磁盘等物理资源，甚对它们进行虚拟化。</p>
<p>它处理与并发有关的麻烦且棘手的问题。</p>
<p>它持久地（persistently）存储文件，并保证其安全性。</p>
<h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><p>将物理资源转化为更通用、更强大且更易于使用的虚拟形式。我们有时候将操作系统称为<strong>虚拟机</strong>。</p>
<p>为了让应用程序告诉操作系统要做什么，操作系统<strong>提供了许多 API</strong>（接口），有时候也说是操作系统为应用程序提供了一个标准库</p>
<p>操作系统也被称为<strong>资源管理器</strong>。他让多个程序运行，共享 cpu，让许多程序访问设备，同时访问自己的指令和数据</p>
<p><strong>虚拟化 CPU</strong></p>
<p>将单个 CPU(或其中一小部分)转换为看似无限数量的 CPU，从而让许多程序看似同时运行，这就是所谓的虚拟化 CPU</p>
<p><strong>虚拟化内存</strong></p>
<p>每个进程都有自己的私有虚拟地址空间，操作系统以某种方式映射到机器的物理内存上，一个正在运行的程序的内存引用不会影响其他进程。</p>
<blockquote>
<p><strong>CPU</strong>：通常使用时间片、多核的方法达到对 CPU 的分割；<br><strong>内存</strong>：内存是 CPU 可以进行直接寻址的存储空间，通常使用分段、分页的手段达到逻辑分割；<br>IO：即输入\输出，以网卡、磁盘为例：<br><strong>磁盘</strong>：采用磁盘映像文件的方式实现分割，通常采用 Spare 格式（稀疏格式：牺牲性能，虚拟化超出本身的内存空间）<br><strong>网卡</strong>：通过软件的方式，获得虚拟化网卡。</p>
</blockquote>
<h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><p>1.建立一些抽象，让系统方便使用</p>
<p>2.提供高性能</p>
<p>3.在应用程序和 OS 之间，以及应用程序之间提供保护</p>
<p>4.高度的可靠性和安全性</p>
<h2 id="第四章—抽象：进程"><a href="#第四章—抽象：进程" class="headerlink" title="第四章—抽象：进程"></a>第四章—抽象：进程</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><strong>进程非正式定义</strong></p>
<p>进程就是运行中的程序</p>
<p><strong>时分共享 cpu 技术</strong></p>
<p>通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟 CPU 的假象</p>
<p><strong>上下文切换</strong></p>
<p>它让操作系统能够停止运行一个程序，并开始在给定的 CPU 上运行另一个程序。</p>
<p><strong>抽象-进程</strong></p>
<p>操作系统为正在运行的程序提供的抽象，就是所谓的进程。进程是操作系统进行资源分配和调度的一个独立单位</p>
<p>进程的机器状态：</p>
<ol>
<li>内存，进程可以访问的内存（称为地址空间，address space）是该进程的一部分。</li>
<li>寄存器：许多指令明确地读取或更新寄存器。</li>
<li>还有一些特殊的寄存器，如 PC，栈指针，帧指针。</li>
</ol>
<p><strong>一个进程包括五个部分</strong></p>
<ol>
<li>（OS 管理运行程序的）数据结构 P</li>
<li>（运行程序的）内存代码 C</li>
<li>（运行程序的）内存数据 D</li>
<li>（运行程序的）通用寄存器信息 R</li>
<li>（OS 控制程序执行的）程序状态字信息 PSW</li>
</ol>
<p><strong>进程 API</strong></p>
<p>创建（create）<br>销毁（destroy）<br>等待（wait）<br>其他控制（miscellaneous control）<br>状态（status）</p>
<p><strong>进程创建</strong></p>
<p>1、将代码和所有静态数据（例如初始化变量）加载（load）到内存中，加载到进程的地址空间中。</p>
<p>2、为程序的运行时栈（run-time stack 或 stack）分配一些内存</p>
<p>3、也可能为程序的堆（heap）分配一些内存</p>
<p>4、一些其他初始化任务，特别是与输入&#x2F;输出（I&#x2F;O）相关的任务</p>
<p>5、启动程序，在入口处运行，即 main()。通过跳转到 main()例程（第 5 章讨论的专门机制），OS 将 CPU 的控制权转移到新创建的进程中，从而程序开始执行。</p>
<p><strong>进程的状态</strong></p>
<p>三种基本状态：</p>
<p>1、运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。<br>2、就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。<br>3、阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见的例子是，当进程向磁盘发起 I&#x2F;O 请求时，它会被阻塞，因此其他进程可以使用处理器。</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111111301668.png" alt="image-20211111130118589"></p>
<p>其他可能存在的状态：</p>
<p><strong>挂起状态</strong>（是该进程暂时不接受调度）。</p>
<p><strong>创建状态</strong>：此时，进程已经拥有了字节的 PCB，但该进程所必需的资源或其它信息（如主存资源）尚未分配，进程自身还未进入主存，即创建工作尚未完成，进程还不能够被调度运行。</p>
<p>（创建进程的两个步骤： 为一个新进程创建 PCB，并填写必要管理信息；把该进程转入就绪状态并插入就绪队列。）</p>
<p><strong>终止状态</strong>：进程的终止首先要等待操作系统进行善后处理，然后将其 PCB 清零，并将 PCB 空间返还系统。</p>
<p><strong>进程控制块（Process Control Block）</strong></p>
<p>PCB 是 OS 用于记录和刻画进程状态及环境信息的数据结构</p>
<p>借助 PCB，OS 可以全面管理进程物理实体，刻画进程的执行现状，控制进程的执行</p>
<h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><p><strong>4.1</strong></p>
<p><strong>用以下标志运行程序：.&#x2F;process-run.py -l 5:100,5:100。CPU 利用率（CPU 使用时间的百分比）应该是多少？为什么你知道这一点？利用 -c 标记查看你的答案是否正确。</strong></p>
<p>运行结果如下</p>
<p>**cpu 利用率为 100%**，可以看到进程 0 和进程 1 交替执行，且没有调用 IO 命令。</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943336.png" alt="image-20211107224505762"></p>
<p>加上-c 标记后运行结果。CPU 一直处于占用状态，验证正确</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943337.png" alt="image-20211107224328317"></p>
<p><strong>4.2</strong></p>
<p><strong>现在用这些标志运行：.&#x2F;process-run.py -l 4:100,1:0。这些标志指定了一个包含 4 条指令的进程（都要使用 CPU），并且只是简单地发出 I&#x2F;O 并等待它完成。完成这两个进程需要多长时间？利用-c 检查你的答案是否正确。</strong></p>
<p>从运行结果来看，进程 0 的 4 条指令需要占用 4 个 cpu 时间，发起 io 和 io 结束需要 2 个时装周期 ，io 占用时间还无法得知。total&#x3D;4+2+n</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943338.png"></p>
<p>加上-c 标记后运行结果，可以看到程序一共占用了 11 个时钟周期，io 占用了 5 时钟周期</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111120937254.png"></p>
<p><strong>4.3</strong></p>
<p><strong>现在交换进程的顺序：.&#x2F;process-run.py -l 1:0,4:100。现在发生了什么？交换顺序是否重要？为什么？同样，用-c 看看你的答案是否正确。</strong></p>
<p>交换运行顺序后，首先运行进程 0，进程 0 发起 IO，系统进行上下文切换，进程 1 占用 cpu 执行程序。</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943340.png" alt="image-20211109170627689"></p>
<p>加上-c，可以看到，让进程 0 先执行 IO 的话，进程 1 在进程 0 调用 IO 的同时可占用 CPU。只需 6 个时钟周期即可执行完程序</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943341.png" alt="image-20211109171420829"></p>
<p><strong>4.4</strong></p>
<p><strong>现在交换进程的顺序：.&#x2F;process-run.py -l 1:0,4:100。现在发生了什么？交换顺序是否重要？为什么？同样，用-c 看看你的答案是否正确。</strong></p>
<p>可以看到，因为进程在进行 I&#x2F;O 操作时，系统不会进行上下文切换，所以进程 1 只能等待进程 0 调用 IO 结束再占用 CPU，最终要消耗 9 个时钟周期</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943342.png" alt="image-20211109172648650"></p>
<p><strong>4.5</strong></p>
<p><strong>现在，运行相同的进程，但切换行为设置，在等待 I&#x2F;O 时切换到另一个进程（-l 1:0,4:100-c -S SWITCH_ON_IO）。现在会发生什么？利用-c 来确认你的答案是否正确。</strong></p>
<p>可以看到，让进程 0 先执行 IO，然后系统进行上下文切换，进程 1 可占用 CPU。只需 6 个时钟周期即可执行完程序</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943343.png" alt="image-20211109172752093"></p>
<h2 id="第五章-进程-API"><a href="#第五章-进程-API" class="headerlink" title="第五章-进程 API"></a>第五章-进程 API</h2><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><h4 id="fork-系统调用"><a href="#fork-系统调用" class="headerlink" title="fork 系统调用"></a><strong>fork 系统调用</strong></h4><p>1、子进程不会从 main()函数开始执行，而是直接从 fork()系统调用返回。</p>
<p>2、子进程拥有自己的地址空间（即拥有自己的私有内存）、寄存器、程序计数器等</p>
<p>3、父进程获得的返回值是新创建子进程的 PID，而子进程获得的返回值是 0</p>
<p>4、子进程和父进程的运行顺序取决于 CPU 调度顺序</p>
<p><strong>代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line"><span class="type">int</span> rc = fork();</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123; <span class="comment">// fork failed; exit</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123; <span class="comment">// child (new process)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// parent goes down this path (main)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello, I am parent of %d (pid:%d)\n&quot;</span>,</span><br><span class="line">rc, (<span class="type">int</span>) getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="wait-系统调用"><a href="#wait-系统调用" class="headerlink" title="wait 系统调用"></a>wait 系统调用</h4><p>父进程调用 wait()，延迟自己的执行，直到子进程执行完毕。当子进程结束，wait()才返回父进程。</p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line"> <span class="type">int</span> rc = fork();</span><br><span class="line"> <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123; <span class="comment">// fork failed; exit</span></span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123; <span class="comment">// child (new process)</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; <span class="comment">// parent goes down this path (main)</span></span><br><span class="line"> <span class="type">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;</span>,</span><br><span class="line"> rc, wc, (<span class="type">int</span>) getpid());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p2</span><br><span class="line">hello world (pid:29266)</span><br><span class="line">hello, I am child (pid:29267)</span><br><span class="line">hello, I am parent of 29267 (wc:29267) (pid:29266)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>

<h4 id="exec-系统调用"><a href="#exec-系统调用" class="headerlink" title="exec 系统调用"></a>exec 系统调用</h4><p>这个系统调用可以让子进程执行与父进程不同的程序。例如，在 p2.c 中调用 fork()，这只是在你想运行相同程序的拷贝谁有用。但是，我们常常想运行不同的程序，exec()正好做这样的事</p>
<p>这个例子中，子进程调用 execvp()来运行字符计数程序 wc。</p>
<p>exec()会从可执行程序中加载代码和静态数据，并用它覆写自己代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化。然后操作系统就执行该程序，将参数通过 argv 传递给该进程。因此，它并没有创建新进程，而是直接将当前运行的程序（以前的 p3）替换为不同的运行程序（wc）。子进程执行 exec()之后，几乎就像 p3.c 从未运行过一样。对 exec()的成功调用永远不会返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; ./p3</span><br><span class="line">hello world (pid:29383)</span><br><span class="line">hello, I am child (pid:29384)</span><br><span class="line">29 107 1030 p3.c</span><br><span class="line">hello, I am parent of 29384 (wc:29384) (pid:29383)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line"><span class="type">int</span> rc = fork();</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123; <span class="comment">// fork failed; exit</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123; <span class="comment">// child (new process)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line"><span class="type">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">myargs[<span class="number">0</span>] = strdup(<span class="string">&quot;wc&quot;</span>); <span class="comment">// program: &quot;wc&quot; (word count)</span></span><br><span class="line">myargs[<span class="number">1</span>] = strdup(<span class="string">&quot;p3.c&quot;</span>); <span class="comment">// argument: file to count</span></span><br><span class="line">myargs[<span class="number">2</span>] = <span class="literal">NULL</span>; <span class="comment">// marks end of array</span></span><br><span class="line">execvp(myargs[<span class="number">0</span>], myargs); <span class="comment">// runs word count</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this shouldn&#x27;t print out&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// parent goes down this path (main)</span></span><br><span class="line"><span class="type">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;</span>,</span><br><span class="line">rc, wc, (<span class="type">int</span>) getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="why-splits-fork-and-exec"><a href="#why-splits-fork-and-exec" class="headerlink" title="why splits fork() and exec()"></a>why splits fork() and exec()</h4><p>在构建 UNIX shell 的时候非常有用，因为这给了 shell 在 fork 之后 exec 之前运行代码的机会，这些代码可以在运行新程序前改变环境，实现一些有趣的功能。</p>
<p>例<code>prompt&gt; wc p3.c &gt; newfile.txt</code><br>在上面的例子中，wc 的输出结果被重定向（redirect）到文件 newfile.txt 中（通过 newfile.txt 之前的大于号来指明重我向）。shell 实现结果重定向的方式也很简单，当完成子进程的创建<br>后，shell 在调用 exec()之前先关闭了标准输出（standardoutput），打开了文件 newfile.txt。这样，即将运行的程序 wc 的输出结果就被发送到该文件，而不是打印在屏幕上。</p>
<h3 id="课后习题-1"><a href="#课后习题-1" class="headerlink" title="课后习题"></a>课后习题</h3><p><strong>5.1</strong></p>
<p><strong>编写一个调用 fork()的程序。谁调用 fork()之前，让主进程访问一个变量（例如 x）并将其值设置为某个值（例如 100）。子进程中的变量有什么值？当子进程和父进程都改变 x 的值，变量会发生什么？</strong></p>
<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;<span class="comment">//在调用之前,让主进程访问一个变量(例如 x)并将其值设               //置为100</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child, x %d\n&quot;</span>, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent, x %d\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">//当子进程和父进程都改变 x 的值时</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child,x %d\n&quot;</span>, x);</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child,x %d\n&quot;</span>, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent,x %d\n&quot;</span>, x);</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent,x %d\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，在调用之前,让主进程访问一个变量(例如 x)并将其值设为 100，父进程和子进程的 x 值都为 100</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943344.png" alt="image-20211109174929408"></p>
<p>当子进程和父进程在各自进程修改 x 值时，父子进程的值各自不受影响</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943345.png" alt="image-20211109173934825"></p>
<p><strong>5.2</strong></p>
<p><strong>编写一个打开文件的程序（使用 open()系统调用），然后调用 fork()创建一个新进程。子进程和父进程都可以访问 open()返回的文件描述符吗？当它在并发（即同时）写入文件时，会发生什么？</strong></p>
<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./check.txt&quot;</span>, O_CREAT | O_RDWR | O_TRUNC, S_IRWXU);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *buf = <span class="string">&quot;child\n&quot;</span>;</span><br><span class="line">        <span class="type">int</span> error = write(fd, buf, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child error: %d\n&quot;</span>, error == <span class="number">-1</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> *buf = <span class="string">&quot;parent\n&quot;</span>;</span><br><span class="line">        <span class="type">int</span> error = write(fd, buf, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child error: %d\n&quot;</span>, error == <span class="number">-1</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下，可以看到</p>
<p>父进程，子进程都能访问 open 返回的 fd 文件符。当他们同时写入文件时，存在竞争条件，但因为操作系统会进行调度，所以最终两个进程都能写入成功</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943346.png" alt="image-20211109180303635"></p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943347.png" alt="image-20211109180212533"></p>
<p><strong>5.4</strong></p>
<p><strong>编写一个调用 fork()的程序,然后调用某种形式的 exec()来运行序”&#x2F;bin&#x2F;ls”看看是否可以尝试 exec 的所有变体,包括 execl()、 execle()、 execlp()、 execv()、 execvp()和 execve(),为什么同样的基本调用会有这么多变种？</strong></p>
<p>测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[], char *envp[]) &#123;</span><br><span class="line">  int pid = fork();</span><br><span class="line">  char *cmd = &quot;/bin/ls&quot;;</span><br><span class="line">  char *arg[] = &#123;&quot;ls&quot;, &quot;-a&quot;, NULL&#125;;</span><br><span class="line"></span><br><span class="line">  if (pid &lt; 0) &#123;</span><br><span class="line">    printf(&quot;fork error\n&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125; else if (pid == 0) &#123;</span><br><span class="line">    //    exec不会返回,所以第一条execl语句后的语句不会被执行</span><br><span class="line">    execl(cmd, &quot;ls&quot;, NULL);</span><br><span class="line">    execlp(cmd, &quot;ls&quot;, NULL);</span><br><span class="line">    execve(cmd, arg, envp);</span><br><span class="line">    execv(cmd, arg);</span><br><span class="line">    execvp(cmd, arg);</span><br><span class="line">    execle(cmd, &quot;ls&quot;, NULL, envp);</span><br><span class="line">    execvP(cmd,arg)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是调用各个形式的 exec 函数后程序的运行结果</p>
<p>exec 多个变体能提供不同的功能,不同后缀指示着不同的操作功能：</p>
<ol>
<li>l: 希望接收以逗号分隔的参数列表,列表以 NULL 指针作为结束标志</li>
<li>v: 希望接收一个以 NULL 结尾字符串数组的指针</li>
<li>p: 是一个以 NULL 结尾的字符串数组指针,函数可以利用 DOS 的 PATH 变量查找自程序文件</li>
<li>e： 函数传递指定采纳数 envp(环境变量),允许改变子进程环境,无后缀 e 是,子进程使用当前程序环境</li>
<li>c 语言没有默认参数语法,只能实现多个变体</li>
</ol>
<p>execl:</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943348.png" alt="image-20211109195822756"></p>
<p>execlp:</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943349.png" alt="image-20211109195938552"></p>
<p>execve：</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943350.png" alt="image-20211109200052709"></p>
<p>execv：</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943351.png" alt="image-20211109200128674"></p>
<p>execvp：</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943352.png" alt="image-20211109200209564"></p>
<p>execle：</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943353.png" alt="image-20211109200430882"></p>
<p>execlP：</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943354.png" alt="image-20211109200543452"></p>
<h2 id="第六章——受限直接执行"><a href="#第六章——受限直接执行" class="headerlink" title="第六章——受限直接执行"></a>第六章——受限直接执行</h2><h3 id="受限运行协议"><a href="#受限运行协议" class="headerlink" title="受限运行协议"></a>受限运行协议</h3><p><strong>用户模式</strong> user mode：在用户模式下运行的代码会受到限制，如用户模式下，进程不能发出 I&#x2F;O，这样会引发异常，可能导致操作系统终止该进程</p>
<p><strong>内核模式</strong> kernel mode：操作系统就在内核模式下运行，在此模式下，运行的代码可以做它想做的所有事，包括特权操作，发出 I&#x2F;O 和执行所有类型的受限制操作</p>
<p>受限直接运行<strong>有两个阶段</strong>：<br>1，系统引导时：内核初始化陷阱表，CPU 记住陷阱表的位置以供使用<br>2，运行进程时：在执行进程前，操作系统为进程初始化了一些内容，接着转入用户模式运行程序。当进程发起系统调用时，会重新陷入操作系统，然后通过陷阱返回，并将控制权重新交给进程</p>
<p>通过让进程在用户模式和内核模式间切换，就完成了保护操作系统的控制权，且限制进程的运行，让它不能做不应该做的事</p>
<p><img src="https://s2.loli.net/2022/01/09/k2O1dHJv7jxi5Is.png" alt="image-20220109081403999"></p>
<p><img src="https://s2.loli.net/2022/01/09/IHiywGmulDKWvEU.png" alt="image-20220109081547409"></p>
<p>操作系统通过时钟中断重新获得了 CPU 的控制权，那么它需要决定：是继续运行当前的进程，还是切换其它进程，这个决定是由调度程序做出的，它是操作系统的一部分，这里先说明如何切换进程</p>
<p>如果决定切换进程，OS 就会执行一些底层代码，即上下文切换：操作系统为当前正执行的进程保存它寄存器的值，并为即将执行的进程恢复寄存器的值，这样操作系统可以确保从内核模式返回时，去执行另一个进程而不是之前运行的进程</p>
<p>下面是进程 A，B 间切换的一张表，操作系统决定从当前正在运行的进程 A 切换到进程 B，它调用 switch()，该系统调用会保存当前运行进程的寄存器的值(保存到 A 的进程结构)，将 B 的进程结构恢复到寄存器，从内核模式退出到用户模式，进入 B 进程执行代码</p>
<h2 id="第七章——进程调度"><a href="#第七章——进程调度" class="headerlink" title="第七章——进程调度"></a>第七章——进程调度</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><h4 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a><strong>调度指标</strong></h4><p>周转时间：T <del>周转时间</del>&#x3D; T <del>完成时间</del>−T <del>到达时间</del></p>
<p>响应时间：T<del>响应时间</del>&#x3D; T <del>首次运行</del>−T <del>到达时间</del></p>
<p>公平性：每个进程都有得到调度的机会</p>
<h4 id="FIFO（先来先服务）"><a href="#FIFO（先来先服务）" class="headerlink" title="FIFO（先来先服务）"></a>FIFO（先来先服务）</h4><p>优点：它很简单，而且易于实现</p>
<p>缺点：护航效应，一些耗时较少的潜在资源消费者被排在重量级的资源消费者之后。导致很差的平均周转时间</p>
<h4 id="SJF（最短任务优先）"><a href="#SJF（最短任务优先）" class="headerlink" title="SJF（最短任务优先）"></a>SJF（最短任务优先）</h4><p>考虑到所有工作同时到达的假设，先运行最短的任务，然后是次短的任务，如此下去。</p>
<p>我们可以证明 SJF 确实是一个最优的调度算法（假设所有任务同时到达）</p>
<h4 id="最短完成时间优先（STCF）"><a href="#最短完成时间优先（STCF）" class="headerlink" title="最短完成时间优先（STCF）"></a>最短完成时间优先（STCF）</h4><p>每当新工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作。</p>
<p>允许抢占，放宽假设，所有任务不是同时到达的</p>
<p>优点：结果是平均周转时间大大提高，虑到我们的新假设，STCF 可证明是最优的。考虑到如果所有工作同时到达，SJF 是最优的</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111112050629.png" alt="image-20211111205039567"></p>
<h4 id="轮转（RR）"><a href="#轮转（RR）" class="headerlink" title="轮转（RR）"></a>轮转（RR）</h4><p>基本思想：RR 在一个时间片（time slice，有时称为调度 scheduling quantum）内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。它反复执行，直到所有任务完成。</p>
<p>【请注意，时间片长度必须是时钟中断周期的倍数。】</p>
<p>时间片长度对于 RR 是至关重要的。<br>时间片太短是有问题的：突然上下文切换的成本将影响整体性能。因此，系统设计者需要权衡时间片的长度，使其足够长，以便摊销（amortize）上下文切换成本，而又不会使系统不及时响应。</p>
<p>优势：有非常好的平均响应时间，通过设置合适的时间片，能获得不错的性能</p>
<p>缺点：较差的平均周转时间</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111230810271.png" alt="image-20211123081045212"></p>
<h4 id="结合-IO"><a href="#结合-IO" class="headerlink" title="结合 IO"></a><strong>结合 IO</strong></h4><p>当一个交互性进程发出 IO 让出 CPU 后，调度程序调度其他程序，从而更好地利用 CPU<img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111112104131.png" alt="image-20211111210429081"></p>
<h3 id="课后习题-2"><a href="#课后习题-2" class="headerlink" title="课后习题"></a>课后习题</h3><p><strong>7.1</strong></p>
<p><strong>使用 SJF 和 FIFO 调度程序运行长度为 200 的 3 个作业时,计算响应时间和周转时间。</strong></p>
<table>
<thead>
<tr>
<th>作业 ID</th>
<th>响应时间</th>
<th>周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>SJF</td>
<td>平均响应时间:200</td>
<td>平均周转时间:400</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>200</td>
</tr>
<tr>
<td>2</td>
<td>200</td>
<td>400</td>
</tr>
<tr>
<td>3</td>
<td>400</td>
<td>600</td>
</tr>
<tr>
<td>FIFO</td>
<td>平均响应时间:200</td>
<td>平均周转时间:400</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>200</td>
</tr>
<tr>
<td>2</td>
<td>200</td>
<td>400</td>
</tr>
<tr>
<td>3</td>
<td>400</td>
<td>600</td>
</tr>
</tbody></table>
<p><strong>7.2</strong></p>
<p>现在做同样的事情,但有不同长度的作业,即 100、200 和 300</p>
<table>
<thead>
<tr>
<th>作业 ID</th>
<th>响应时间</th>
<th>周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>SJF</td>
<td>平均响应时间：133.3</td>
<td>平均周转时间：333.3</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>100</td>
<td>300</td>
</tr>
<tr>
<td>3</td>
<td>300</td>
<td>600</td>
</tr>
<tr>
<td>FIFO</td>
<td>平均响应时间：133.3</td>
<td>平均周转时间：333.3</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>100</td>
<td>300</td>
</tr>
<tr>
<td>3</td>
<td>300</td>
<td>600</td>
</tr>
</tbody></table>
<p><strong>7.3</strong></p>
<p><strong>现在做同样的事情,但采用 RR 调度程序,时间片为 1</strong></p>
<table>
<thead>
<tr>
<th>作业 ID</th>
<th>响应时间</th>
<th>周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>RR</td>
<td>平均响应时间：2</td>
<td>平均周转时间：599</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>598</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>599</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>600</td>
</tr>
</tbody></table>
<p>当三件工作时间分别为 100,200,300 时</p>
<table>
<thead>
<tr>
<th>作业 ID</th>
<th>响应时间</th>
<th>周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>RR</td>
<td>平均响应时间：2</td>
<td>平均周转时间：456.67</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>298</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>499</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>600</td>
</tr>
</tbody></table>
<p><strong>7.4</strong></p>
<p><strong>对于什么类型的工作负载,SJF 提供与 FIFO 相同的周转时间?</strong></p>
<p>以第一条：作业列表中的作业到达时间全部不一致。<br>第二，当作业到达时间一致时，在极细微可以忽略不计的时间上，作业列表中的作业排序必须按作业长度非严格递增。<br>第三，当有的作业到达时间一致，有的不一致时，到达时间一致的作业满足第二条。</p>
<p><strong>7.5</strong></p>
<p><strong>对于什么类型的工作负载和量子长度,SJF 与 RR 提供相同的响应时间?</strong></p>
<p>当运行时间小于等于时间片的时候，SJF 和 RR 提供相同的响应时间</p>
<p><strong>7.6</strong></p>
<p><strong>随着工作长度的增加,SJF 的响应时间会怎样?</strong></p>
<p>随着工作长度的增加，SJF 的响应时间越来越长</p>
<p><strong>7.7</strong></p>
<p><strong>随着量子长度的增加,RR 的响应时间会怎样?你能写出一个方程,计算给定 N 个工作时,最坏情况的响应时间吗?</strong></p>
<p>随着量子长度的增加，RR 的平均响应时间会增加</p>
<p>假设 k 个工作 n1,n2,n3..nk</p>
<p>工作长度为 t1,t2…tk 且 t1&gt;t2&gt;…tk</p>
<p>最坏情况的平均响应时间为</p>
<p>averT&#x3D;(t1+t1+t2+t1+t2+t3+t1+t2+t3…)&#x2F;k&#x3D;((k-1)t1+(k-2)t2+…tk-1)&#x2F;k</p>
<h2 id="第八章—调度：多级反馈队列（MLFQ）"><a href="#第八章—调度：多级反馈队列（MLFQ）" class="headerlink" title="第八章—调度：多级反馈队列（MLFQ）"></a>第八章—调度：多级反馈队列（MLFQ）</h2><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><p><strong>MLFQ（多级反馈队列）</strong></p>
<p>有许多独立的队列，每个列有不同的优先级。并利用反馈信息决定某个工作的优先级。一个工作只能处于一个队列中。MLFQ 总是优先执行优先级高的工作。对于一个队列中的工作，我们采取轮转调度</p>
<p>规则 1：如果 A 的优先级大于 B 优先级，运行 A</p>
<p>规则 2：如果 A 的优先级&#x3D;B，轮转运行 A 和 B</p>
<p><strong>尝:1：改变优先级</strong></p>
<p>规则 3：工作进入系统时，放在最高优先级</p>
<p>规则 4a：工作用完整个时间片后，降低其优先级（移入下一个队列）</p>
<p>规则 4b：如果工作在其时间片内主动释放 cpu，则优先级不变</p>
<p><strong>当前存在的问题</strong></p>
<p>饥饿问题，如果一个程序总是在时间片用完之前让出 cpu，那么它将永远占据高优先级，导致长工作饿死</p>
<p>存在愚弄程序，使一个程序总是在时间片用完之前让出 cpu，它将永远占据高优先级</p>
<p>一个程序不同时间表现不同，一个刚开始计算密集型程序可能在某段时间表现为交互性，那么他无法享受到交互性的待遇</p>
<p><strong>尝试 2：提升优先级</strong></p>
<p>周期性地提升（boost）所有工作的优先级</p>
<p>规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</p>
<p><strong>尝试 3：更好的计时方式</strong></p>
<p>规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）</p>
<p><strong>其他问题</strong></p>
<p>1.如何配置一个调度程序，例如，配置多少队列？每一层队列的时间片配置多大？</p>
<p>大多数的 MLFQ 变体都支持不同队列可变的时间片长度。高优先级队列通常只有较短的时间片（比如 10ms 或者更少），因而这一层的交互工作可以更快地切换。相反，低优先级队列中更多的是 CPU 密集型工作，配置更长的时间片会取得更好的效果。</p>
<p><strong>MLFQ 优点</strong></p>
<p>1.它不需要对工作的运行方式有先验知识，而是通过观察工作的运行来给出对应的优先级</p>
<p>2.MLFQ 可以同时满足各种工作的需求：对于短时间运行的交互型工作，获得类似于 SJF&#x2F;STCF 的很好的全局性能，同时对长时间运行的 CPU 密集型负载也可以公平地、不断地稳步向前。</p>
<p>因此，许多系统使用某种类型的 MLFQ 作为自己的基础调度程序，包括类 BSD UNIX 系统[LM+89，B86]、Solaris[M06]以及 WindowsNT 和其后的 Window 系列操作系统。</p>
<h3 id="课后习题-3"><a href="#课后习题-3" class="headerlink" title="课后习题"></a>课后习题</h3><p><strong>8.1</strong></p>
<p><strong>只用两个工作和两个队列运行几个随机生成的问题。针对每个工作计算 MLFQ 的执行记录。限制每项作业的长度并关闭 I&#x2F;O，让你的生活更轻松。</strong></p>
<p>执行命令行 python2 mlfq.py -j 2 -n 2 -M 0 -m 15 -s 1</p>
<p>程序运行结果如图</p>
<table>
<thead>
<tr>
<th></th>
<th>到达时间</th>
<th>占用 cpu 时间</th>
<th>完成时间</th>
<th>总执行时间</th>
<th>是否调用 io</th>
</tr>
</thead>
<tbody><tr>
<td>job0</td>
<td>0</td>
<td>0-1（位于 Q1）</td>
<td>1</td>
<td>2</td>
<td>否</td>
</tr>
<tr>
<td>job1</td>
<td>0</td>
<td>2-11（位于 Q2）</td>
<td>11</td>
<td>11</td>
<td>否</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111101943355.png" alt="image-20211109210002760"></p>
<p><strong>8.3</strong></p>
<p><strong>将如何配置调度程序参数，像轮转调度程序那样工作？</strong></p>
<p>因为对于同一个队列中的工作，采取轮转的方式调度。所以将队列数设为 1 即可</p>
<p><strong>8.5</strong></p>
<p><strong>给定一个系统，其最高队列中的时间片长度为 10ms，你需要如何频繁地将工作推回到最高优先级级别（带有-B 标志），以保证一个长时间运行（并可能饥饿）的工作得到至少 5%的 CPU？</strong></p>
<p>保证参数 B 小于等于 190，这样至少每隔 200ms 这个长时间运行工作就能被执行 10ms（5%）</p>
<h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h3 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h3><h4 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a><strong>彩票调度</strong></h4><p>彩票数（ticket）代表了进程（或用户或其他）占有某个资源的份额。一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。</p>
<p><strong>一个简单的例子</strong></p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111111054744.png" alt="image-20211111105425418"></p>
<p><strong>优势</strong></p>
<p>彩票调度最精彩的地方在于利用了随机性<br>随机方法相对于传统的决策方式，至少有 3 点优势。</p>
<p>第一，随机方法常常可以避免奇怪的边角情况<br>第二，随机方法很轻量，几乎不需要记录任何状态。<br>第三，随机方法很快。只要能很快地产生随机数，做出决策就很快</p>
<p><strong>彩票调度机制</strong></p>
<p>1、一种方式是利用彩票货币（ticket currency）的概念。这种方式允许拥有一组彩票的用户以他们喜欢的某种货币，将彩票分给自己的不同工作。之后操作系统再自动将这种货币兑换为正确的全局彩票。</p>
<p>eg：假设用户 A 和用户 B 每人拥有 100 张彩票。用户 A 有两个工作 A1 和 A2，他以自己的货币，给每个工作 500 张彩票（共 1000 张）。用户 B 只运行一个工作，给它 10 张彩票（总共 10 张）。操作系统将进行兑换，将 A1 和 A2 拥有的 A 的货币 500 张，兑换成全局货币 50 张。类似地，兑换给 B1 的 10 张彩票兑换成 100 张。然后会对全局彩票货币（共 200 张）举行抽奖，决定哪个工作运行。</p>
<p>2、彩票转让，一个进程可以临时将自己的彩票交给另一个进程。</p>
<p>3、彩票通胀（ticket inflation）有时也很有用。利用通胀，一个进程可以临时提升或降低自己拥有的彩票数量。</p>
<p><strong>代码实现</strong></p>
<p>要让这个过程更有效率，建议将列表项按照彩票数递减排序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 // counter: used to track if we&#x27;ve found the winner yet</span><br><span class="line">2 int counter = 0;</span><br><span class="line">3</span><br><span class="line">4 // winner: use some call to a random number generator to</span><br><span class="line">5 // get a value, between 0 and the total # of tickets</span><br><span class="line">6 int winner = getrandom(0, totaltickets);</span><br><span class="line">7</span><br><span class="line">8 // current: use this to walk through the list of jobs</span><br><span class="line">9 node_t *current = head;</span><br><span class="line">10</span><br><span class="line">11 // loop until the sum of ticket values is &gt; the winner</span><br><span class="line">12 while (current) &#123;</span><br><span class="line">13 counter = counter + current-&gt;tickets;</span><br><span class="line">14 if (counter &gt; winner)</span><br><span class="line">15 break; // found the winner</span><br><span class="line">16 current = current-&gt;next;</span><br><span class="line">17 &#125;</span><br><span class="line">18 // &#x27;current&#x27; is the winner: schedule it...</span><br></pre></td></tr></table></figure>

<h4 id="步长调度"><a href="#步长调度" class="headerlink" title="步长调度"></a>步长调度</h4><p>确定性的公平分配算法</p>
<p>步长调度也很简单。系统中的每个工作都有自己的步长，这个值与票数值成反比。当需要进行调度时，选择目前拥有最小行程值的进程，并且在运行之后将该进程的行程值增加一个步长。</p>
<p><strong>一个例子</strong></p>
<p>A、B、C 这 3 个工作的票数分别是 100、50 和 250，我们通过用一个大数分别除以他们的票数来获得每个进程的步长。比如用 10000 除以这些票数值，得到了 3 个进程的步长分别为 100、200 和 40。我们称这个值为每个进程的步长（stride）。每次进程运<br>行后，我们会让它的计数器 [称为行程（pass）值] 增加它的步长，记录它的总体进展。</p>
<p>可以看出，C 运行了 5 次、A 运行了 2 次，B 一次，正好是票数的比例——200、100 和 50。彩票调度算法只能一段时间后，在概率上实现比例，而步长调度算法可以在每个调度周期后做到完全正确。</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111111105771.png" alt="image-20211111110512549"></p>
<p><strong>优势</strong></p>
<p>步长调度能实现一个确定性的公平分配算法。</p>
<p>随机方式可以使得调度程序的实现简单（且大致正确），但偶尔并不能产生正确的比例，尤其在工作运行时间很短的情况下。</p>
<p><strong>劣势</strong></p>
<p>彩票调度有一个步长调度没有的优势——不需要全局状态。因此彩票调度算法能够更合理地处理新加入的进程。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>比例份额调度的两种实现：彩票调度和步长调度。但这两种方法没有作为 CPU 调度程序被广泛使用</p>
<p>原因一：这两种方式都不能很好地适合 I&#x2F;O[AC97]</p>
<p>原因二：没有解决如何分配彩票的问题</p>
<p>原因三：彩票调度在工作执行时间很短时，平均不公平度非常糟糕。只有当工作执行非常多的时间片时，彩票调度算法才能得到期望的结果。</p>
<p>原因四：步长调度需要全局状态，不能很好的解决新加入的进程</p>
<p>比例份额调度程序只有在这些问题可以相对容易解决的领域更有用（例如容易确定份额比例）。例如在虚拟（virtualized）数据中心中，你可能会希望分配 1&#x2F;4 的 CPU 周期给 Windows 虚拟机，剩余的给 Linux 系统，比例分配的方式可以更简单高效。</p>
<h3 id="课后习题-4"><a href="#课后习题-4" class="headerlink" title="课后习题"></a>课后习题</h3><p><strong>9.1</strong></p>
<p><strong>计算 3 个工作在随机种子为 1、2 和 3 时的模拟解。</strong></p>
<p>运行命令行 python2 lottery.py -j 3 -s 1，随机种子为 1</p>
<p>可以看到，</p>
<p>时间片 R&#x3D;1</p>
<p>job0 ，总占用时间：1，彩票数：0-83</p>
<p>job1 ，总占用时间：7，彩票数：84-108</p>
<p>job2 ，总占用时间：2，彩票数：109-152</p>
<p>产生的随机数依次取模得到执行作业的顺序为：</p>
<p>2 0 1 2 2 2 1 1 1 1 1 1</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111111128405.png" alt="image-20211111112849348"></p>
<p>运行命令行 python2 lottery.py -j 3 -s 2，随机种子为 2</p>
<p>同理可得到执行作业的顺序：</p>
<p>2 0 0 2 0 1 0 2 0 0 0 1 0 0 1 2 1 1 1 2 1 1 2</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111111133096.png" alt="image-20211111113351023"></p>
<p>运行命令行 python2 lottery.py -j 3 -s 3，随机种子为 3</p>
<p>同理可得到执行作业的顺序：</p>
<p>1 1 0 1 0 2 2 2 2 2 2</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111111134211.png" alt="image-20211111113449142"></p>
<p><strong>9.2</strong></p>
<p><strong>现在运行两个具体的工作：每个长度为 10,但是一个（工作 0)只有一张彩票，另一个（工作 1)有 100 张（-l 10:1,10:100).彩票数量如此不平衡时会发生什么？在工作 1 完成之前，工作 0 是否会运行？多久？一般来说，这种彩票不平衡对彩票调度的行为有什么影响？</strong></p>
<p>只有一张彩票被调度的可能性非常小，可能会饿死。</p>
<p>在工作 1 完成之前，工作 0 可能会运行。</p>
<p>这种行为可能会导致平均周转和响应时间变得很差</p>
<p><strong>9.3</strong></p>
<p><strong>如果运行两个长度为 100 的工作，都有 100 张彩票（-l 100:100,100:100),调度程序有多不公平？运行一些不同的随机种子来确定（概率上的）答案。不公平性取决于一项工作比另一项工作早完成多少。</strong></p>
<p>分别运行命令行</p>
<p>python2 lottery.py -l 100:100,100:100 -s 1 -c</p>
<p>python2 lottery.py -l 100:100,100:100 -s 25 -c</p>
<p>python2 lottery.py -l 100:100,100:100 -s 50 -c</p>
<p>python2 lottery.py -l 100:100,100:100 -s 100 -q 10 -c(调整时间片为 10)</p>
<p>python2 lottery.py -l 100:100,100:100 -s 100 -q 30 -c(调整时间片为 30)</p>
<p>可以看到随机种子为 1 时 job0 在 192 时完成，job1 在 200 的时候完成</p>
<p>随机种子为 25 时 job1 在 182 时完成，job0 在 200 的时候完成</p>
<p>随机种子为 50 时 job1 在 188 时完成，job0 在 200 的时候完成</p>
<p>公平性都还不错</p>
<p>可以看到当时间片调整为 10 后，job1 在 140 时完成，job0 在 200 的时候完成</p>
<p>当时间片调整为 30 后，job1 在 150 时完成，job0 在 240 的时候完成</p>
<p>公平性较差</p>
<p>一般来说，时间片越小，两个工作完成的时间越接近，公平性越高</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111111143789.png" alt="image-20211111114313728"></p>
<h2 id="第十章——多处理器调度"><a href="#第十章——多处理器调度" class="headerlink" title="第十章——多处理器调度"></a>第十章——多处理器调度</h2><p><strong>多处理器架构</strong></p>
<p><strong>缓存一致性（cache coherence）问题</strong></p>
<p>与单处理器的核心区别在于对硬件缓存（cache）的使用，事实证明，多 CPU 的情况下缓存要复杂得多。例如，假设一个运行在 CPU 1 上的程序从内存地址 A 读取数据。由于不在 CPU 1 的缓存中，所以系统直接访问内存，得到值 D。程序然后修改了地址 A 处的值，只是将它的缓存更新为新值 D’。将数据写回内存比较慢，因此系统（通常）会稍后再做。假设这时操作系统中断了该程序的运行，并将其交给 CPU 2，重新读取地址 A 的数据，由于 CPU 2 的缓存中并没有该数据，所以会直接从内存中读取，得到了旧值 D，而不是正确的值 D’。</p>
<p>基本解决方案：通过监控内存访问，硬件可以保证获得正确的<br>数据，并保证共享内存的唯一性。在基于总线的系统中，一种方式是使用总线窥探（bus snooping）[G83]。每个缓存都通过监听链接所有缓存和内存的总线，来发现内存访问。如果 CPU 发现对它放在缓存中的数据的更新，会作废（invalidate）本地副本（从缓存中移除），<br>或更新（update）它（修改为新值）。回写缓存。</p>
<p><strong>缓存亲和度（cache affinity</strong>）<br>一个进程在某个 CPU 上运行时，会在该 CPU 的缓存中维护许多状态。下次该进程在相同 CPU 上运行时，由于缓存中的数据而执行得更快。相反，在不同的 CPU 上执行，会由于需要重新加载数据而很慢（好在硬件保证的缓存一致性可以保证正确执行）。因此多处理器调度应该考虑到这种缓存亲和性，<strong>并尽可能将进程保持在同一个 CPU 上</strong></p>
<p><strong>单队列调度</strong>（SQMS）</p>
<p>简单地复用单处理器调度的基本架构，将所有需要调度的工作放入一个单独的队列中。</p>
<p>优点：能够从单 CPU 调度程序很简单地发展而来</p>
<p>短板：它的扩展性不好（由于同步开销有限），并且不能很好地保证缓存亲和度。</p>
<p>调度程序的开发者需要在代码中通过加锁（locking）来保证原子性</p>
<p>为了解决缓存亲和性这个问题，大多数 SQMS 调度程序都引入了一些亲和度机制，尽可能让进程在同一个 CPU 上运行。保持一些工作的亲和度的同时，可能需要牺牲其他工作的亲和度来实现负载均衡</p>
<p><strong>多队列调度</strong>MQMS</p>
<p>有些系统使用了多队列的方案，比如每个 CPU 一个队列。我们称之为多队列多处理器调度。基本调度框架包含多个调度队列，每个队列可以使用不同的调度规则</p>
<p>优势：具有可扩展性和缓存亲和性，所有工作都保持在固定的 CPU 上</p>
<p>短板：负载不均衡（每个 CPU 承载的工作不平衡），</p>
<p>解决方案：<strong>工作迁移</strong>，通过工作的跨 CPU 迁移。</p>
<p><strong>工作窃取</strong>，工作量较少的（源）队列不定期地“偷看”其他（目标）队列是不是比自己的工作多。如果目标队列比源队列（显著地）更满，就从目标队列“窃取”一个或多个工作，实现负载均衡。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2021/03/11/CPU%E8%99%9A%E6%8B%9F%E5%8C%96/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/" rel="tag">linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/operating-sysytem/" rel="tag">operating sysytem</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/03/15/%E5%B9%B6%E5%8F%91%E6%80%A7/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            并发性
          
        </div>
      </a>
    
    
      <a href="/2021/02/11/Linux%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">《Linux命令速查手册》</div>
      </a>
    
  </nav>

  
   
<div class="gitalk" id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.css">


<script src="https://cdn.staticfile.org/gitalk/1.7.2/gitalk.min.js"></script>


<script src="https://cdn.staticfile.org/blueimp-md5/2.19.0/js/md5.min.js"></script>

<script type="text/javascript">
  var gitalk = new Gitalk({
    clientID: '3aa4f744e9b5db355ee9',
    clientSecret: '7a275b033ddbdc5dd88517bca28175b3ceb4c04b',
    repo: 'ninibymilk.github.io',
    owner: 'ninibymilk',
    admin: ['ninibymilk'],
    // id: location.pathname,      // Ensure uniqueness and length less than 50
    id: md5(location.pathname),
    distractionFreeMode: false,  // Facebook-like distraction free mode
    pagerDirection: 'last'
  })

  gitalk.render('gitalk-container')
</script>

     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2019-2022
        <i class="ri-heart-fill heart_icon"></i> nnilk
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="nnilk&#39;s blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->
 
<script src="/js/clickLove.js"></script>
 
<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->
 
<script src="/js/dz.js"></script>
 
<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>