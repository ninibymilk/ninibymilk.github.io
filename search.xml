<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Tacotron2声谱预测网络</title>
    <url>/2022/03/15/tacotron2%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Tacotron2-声谱预测网络"><a href="#Tacotron2-声谱预测网络" class="headerlink" title="Tacotron2 声谱预测网络"></a><a href="https://arxiv.org/abs/1712.05884">Tacotron2 声谱预测网络</a></h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>1.<a href="https://cloud.tencent.com/developer/article/1143127">注意力机制</a></p>
<p>2.<a href="https://blog.csdn.net/v_july_v/category_9261611.html">RNN</a></p>
<p>3.CNN</p>
<ol start="4">
<li>LSTM</li>
</ol>
<p>5.<a href="https://www.pianshen.com/article/93901929427/">梅尔波形（mel spectrogram）——一种中间声学特征表示</a></p>
<h2 id="模型概述"><a href="#模型概述" class="headerlink" title="模型概述"></a>模型概述</h2><p>该语音合成系统由两个组件组成，如下图所示</p>
<ol>
<li>一个循环 seq2seq 声谱特征预测网络，它从输入字符序列预测 mel 谱图帧的序列;</li>
<li>一个改进的 WaveNet，它根据预测的 mel 谱图帧生成时域波形样本。<span id="more"></span></li>
</ol>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202203031055188.png" alt="image-20220303105518888"></p>
<p>我们选择了一个低电平的声学表示:梅尔-频谱图，以连接这两个成分。使用一种很容易从时域波形计算出来的表示形式，可以让我们分别训练这两个分量。这种表示也比波形样本更平滑，更容易训练使用平方误差损失，因为它是不变的相位在每一帧。mel 谱图与线性谱图有关，即短时傅里叶变换(STFT)幅度。</p>
<p>该方法是根据人类听觉系统的实测响应，对短时傅立叶变换的频率轴进行非线性变换，以较少的维数总结频率内容。</p>
<p>使用这种听觉频率标度可以强调对语音清晰度至关重要的低频细节，同时减少了对高频细节的强调，高频细节主要由摩擦和其他噪声爆发控制，通常不需要以高保真度建模。由于这些特性，从 mel 尺度衍生出来的特征已经被用作语音识别的基础表示几十年了</p>
<h2 id="声谱预测网络"><a href="#声谱预测网络" class="headerlink" title="声谱预测网络"></a>声谱预测网络</h2><h3 id="梅尔谱图生成"><a href="#梅尔谱图生成" class="headerlink" title="梅尔谱图生成"></a>梅尔谱图生成</h3><p>我们使用跨越 125 Hz 至 7.6 kHz 的 80 通道 mel 滤波器组将 STFT 幅度转换为梅尔尺度，然后进行对数动态范围压缩。在日志压缩之前，为了限制对数域的动态范围，滤波器组的输出幅度被裁剪到最小值 0.01。</p>
<h3 id="结构概述"><a href="#结构概述" class="headerlink" title="结构概述"></a>结构概述</h3><p>该网络由编码器（Encoder）和解码器（Decoder）组成。编码器将字符序列转换为隐藏的特征表示，解码器使用该特征表示来预测谱图。输入字符使用学习过的 512 维字符嵌入（a learned 512-dimensional character embedding）表示，该字符嵌入经过 3 个卷积层的堆栈，每个卷积层包含 512 个形状为 5 x 1 的滤波器（filter），即每个滤波器跨越 5 个字符，然后是批量归一化和 ReLU 激活。</p>
<h3 id="编码器（Encoder）"><a href="#编码器（Encoder）" class="headerlink" title="编码器（Encoder）"></a>编码器（Encoder）</h3><p>编码器输出由注意力网络消耗，该网络将完整编码序列总结为每个解码器输出步骤的固定长度上下文向量。我们使用位置敏感注意（location-sensitive attention），它扩展了可加性注意机制将先前解码器时间步骤中的累积注意权值作为额外的特征。这鼓励模型在输入过程中始终向前移动，减少解码程序重复或忽略某些子序列的潜在失败模式。在投射输入后计算注意力概率</p>
<blockquote>
<p>在 Tacotron2 中，编码器将输入序列 X&#x3D;[x<del>1</del>,x<del>2</del>,…,x<del>Tx</del>] 映射成序列 H&#x3D;[h<del>1</del>,h<del>2</del>,…,h<del>Tx</del>] ，其中序列 H 被称作“编码器隐状态”(encoder hidden states)。注意：编码器的输入输出序列都拥有相同的长度，h<del>i</del>之于相邻分量 h<del>j</del>拥有的信息等价于 x<del>i</del>之于 x<del>j</del>所拥有的信息。</p>
<p>在 Tacotron2 中，每一个输入分量 xi 就是一个字符。Tacotron2 的编码器是一个 3 层卷积层后跟一个双向 LSTM 层形成的模块，在 Tacotron2 中卷积层给予了神经网络类似于 N−gramN−gram 感知上下文的能力。这里使用卷积层获取上下文主要是由于实践中 RNN 很难捕获长时依赖，并且卷积层的使用使得模型对不发音字符更为鲁棒(如’know’中的’k’)。</p>
<p>经词嵌入(word embedding)的字符序列先送入三层卷积层以提取上下文信息，然后送入一个双向的 LSTM 中生成编码器隐状态，即：</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202203031438629.png" alt="image-20220225155829121"></p>
<p>其中，F1、F2、F3F1、F2、F3 为 3 个卷积核，ReLUReLU 为每一个卷积层上的非线性激活 E¯ 表示对字符序列 X 做 embedding，EncoderRecurrency 表示双向 LSTM。</p>
</blockquote>
<h3 id="Tacotron2-注意力机制-Location-Sensitive-Attention"><a href="#Tacotron2-注意力机制-Location-Sensitive-Attention" class="headerlink" title="Tacotron2 注意力机制-Location Sensitive Attention"></a>Tacotron2 注意力机制-Location Sensitive Attention</h3><blockquote>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202203031438800.png" alt="image-20220225160230769"></p>
<p>其中，s<del>i</del>为<em>当前</em>解码器隐状态而非上一步解码器隐状态，偏置值 b 被初始化为 0。位置特征 fi 使用累加注意力权重 cα<del>i</del>卷积而来</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202203031438516.png" alt="image-20220225160333596"></p>
</blockquote>
<h3 id="解码器（Decoder）"><a href="#解码器（Decoder）" class="headerlink" title="解码器（Decoder）"></a>解码器（Decoder）</h3><p>该解码器是一种自回归递归神经网络，它从编码后的输入序列一帧一帧地预测 mel 谱图。</p>
<p>其处理步骤如下：</p>
<ol>
<li>前一个时间步的预测首先通过一个包含 2 个完全连接的 256 个隐藏 ReLU 单元的 pre-net。</li>
<li>将 pre-net 输出和注意上下文向量串联起来，并通过一个包含 1024 个单元的 2 个单向 LSTM 层的堆栈。</li>
<li>将 LSTM 输出与注意上下文向量串联起来，通过线性变换进行投影，对目标谱图帧进行预测。</li>
<li>最后，将预测的 mel 谱图通过 5 层卷积 post-net（5-layer convolutional post-net）进行预测，并将残差添加到预测中以改善预测的梅尔谱图质量。post-net 由 512 个滤波器组成，形状为 5 x 1，批量归一化，然后在最后一层上进行 tanh 激活。</li>
</ol>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202203031055369.png" alt="image-20220303105542062"></p>
<h2 id="声码器（Vocoder）"><a href="#声码器（Vocoder）" class="headerlink" title="声码器（Vocoder）"></a>声码器（Vocoder）</h2><p>该论文使用的声码器是一个改进的 WaveNet，不是本次论文重点提出的模型，也不是我们本次项目使用到的声码器模型。故略。之后再对 melgan 等声码器进行分析。</p>
]]></content>
      <categories>
        <category>TTS(text to speech)</category>
      </categories>
      <tags>
        <tag>TTS</tag>
        <tag>AI</tag>
        <tag>MachineLearning</tag>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU虚拟化</title>
    <url>/2021/03/11/CPU%E8%99%9A%E6%8B%9F%E5%8C%96/</url>
    <content><![CDATA[<h1 id="CPU-虚拟化"><a href="#CPU-虚拟化" class="headerlink" title="CPU 虚拟化"></a>CPU 虚拟化</h1><h2 id="第二章—操作系统介绍"><a href="#第二章—操作系统介绍" class="headerlink" title="第二章—操作系统介绍"></a>第二章—操作系统介绍</h2><h3 id="操作系统的任务"><a href="#操作系统的任务" class="headerlink" title="操作系统的任务"></a><strong>操作系统的任务</strong></h3><p>操作系统：负责确保系统既易于使用又正确高效地运行。</p>
<p>它取得 CPU、内存或磁盘等物理资源，甚对它们进行虚拟化。</p>
<p>它处理与并发有关的麻烦且棘手的问题。</p>
<p>它持久地（persistently）存储文件，并保证其安全性。</p>
<h3 id="虚拟化"><a href="#虚拟化" class="headerlink" title="虚拟化"></a>虚拟化</h3><p>将物理资源转化为更通用、更强大且更易于使用的虚拟形式。我们有时候将操作系统称为<strong>虚拟机</strong>。</p>
<p>为了让应用程序告诉操作系统要做什么，操作系统<strong>提供了许多 API</strong>（接口），有时候也说是操作系统为应用程序提供了一个标准库</p>
<p>操作系统也被称为<strong>资源管理器</strong>。他让多个程序运行，共享 cpu，让许多程序访问设备，同时访问自己的指令和数据</p>
<p><strong>虚拟化 CPU</strong></p>
<p>将单个 CPU(或其中一小部分)转换为看似无限数量的 CPU，从而让许多程序看似同时运行，这就是所谓的虚拟化 CPU</p>
<p><strong>虚拟化内存</strong></p>
<p>每个进程都有自己的私有虚拟地址空间，操作系统以某种方式映射到机器的物理内存上，一个正在运行的程序的内存引用不会影响其他进程。</p>
<blockquote>
<p><strong>CPU</strong>：通常使用时间片、多核的方法达到对 CPU 的分割；<br><strong>内存</strong>：内存是 CPU 可以进行直接寻址的存储空间，通常使用分段、分页的手段达到逻辑分割；<br>IO：即输入\输出，以网卡、磁盘为例：<br><strong>磁盘</strong>：采用磁盘映像文件的方式实现分割，通常采用 Spare 格式（稀疏格式：牺牲性能，虚拟化超出本身的内存空间）<br><strong>网卡</strong>：通过软件的方式，获得虚拟化网卡。</p>
</blockquote>
<h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><p>1.建立一些抽象，让系统方便使用</p>
<p>2.提供高性能</p>
<p>3.在应用程序和 OS 之间，以及应用程序之间提供保护</p>
<p>4.高度的可靠性和安全性</p>
<h2 id="第四章—抽象：进程"><a href="#第四章—抽象：进程" class="headerlink" title="第四章—抽象：进程"></a>第四章—抽象：进程</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p><strong>进程非正式定义</strong></p>
<p>进程就是运行中的程序</p>
<p><strong>时分共享 cpu 技术</strong></p>
<p>通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟 CPU 的假象</p>
<p><strong>上下文切换</strong></p>
<p>它让操作系统能够停止运行一个程序，并开始在给定的 CPU 上运行另一个程序。</p>
<p><strong>抽象-进程</strong></p>
<p>操作系统为正在运行的程序提供的抽象，就是所谓的进程。进程是操作系统进行资源分配和调度的一个独立单位</p>
<p>进程的机器状态：</p>
<ol>
<li>内存，进程可以访问的内存（称为地址空间，address space）是该进程的一部分。</li>
<li>寄存器：许多指令明确地读取或更新寄存器。</li>
<li>还有一些特殊的寄存器，如 PC，栈指针，帧指针。</li>
</ol>
<p><strong>一个进程包括五个部分</strong></p>
<ol>
<li>（OS 管理运行程序的）数据结构 P</li>
<li>（运行程序的）内存代码 C</li>
<li>（运行程序的）内存数据 D</li>
<li>（运行程序的）通用寄存器信息 R</li>
<li>（OS 控制程序执行的）程序状态字信息 PSW</li>
</ol>
<p><strong>进程 API</strong></p>
<p>创建（create）<br>销毁（destroy）<br>等待（wait）<br>其他控制（miscellaneous control）<br>状态（status）</p>
<p><strong>进程创建</strong></p>
<p>1、将代码和所有静态数据（例如初始化变量）加载（load）到内存中，加载到进程的地址空间中。</p>
<p>2、为程序的运行时栈（run-time stack 或 stack）分配一些内存</p>
<p>3、也可能为程序的堆（heap）分配一些内存</p>
<p>4、一些其他初始化任务，特别是与输入&#x2F;输出（I&#x2F;O）相关的任务</p>
<p>5、启动程序，在入口处运行，即 main()。通过跳转到 main()例程（第 5 章讨论的专门机制），OS 将 CPU 的控制权转移到新创建的进程中，从而程序开始执行。</p>
<p><strong>进程的状态</strong></p>
<p>三种基本状态：</p>
<p>1、运行（running）：在运行状态下，进程正在处理器上运行。这意味着它正在执行指令。<br>2、就绪（ready）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。<br>3、阻塞（blocked）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。一个常见的例子是，当进程向磁盘发起 I&#x2F;O 请求时，它会被阻塞，因此其他进程可以使用处理器。</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111111301668.png" alt="image-20211111130118589"></p>
<p>其他可能存在的状态：</p>
<p><strong>挂起状态</strong>（是该进程暂时不接受调度）。</p>
<p><strong>创建状态</strong>：此时，进程已经拥有了字节的 PCB，但该进程所必需的资源或其它信息（如主存资源）尚未分配，进程自身还未进入主存，即创建工作尚未完成，进程还不能够被调度运行。</p>
<p>（创建进程的两个步骤： 为一个新进程创建 PCB，并填写必要管理信息；把该进程转入就绪状态并插入就绪队列。）</p>
<p><strong>终止状态</strong>：进程的终止首先要等待操作系统进行善后处理，然后将其 PCB 清零，并将 PCB 空间返还系统。</p>
<p><strong>进程控制块（Process Control Block）</strong></p>
<p>PCB 是 OS 用于记录和刻画进程状态及环境信息的数据结构</p>
<p>借助 PCB，OS 可以全面管理进程物理实体，刻画进程的执行现状，控制进程的执行</p>
<h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><p><strong>4.1</strong></p>
<p><strong>用以下标志运行程序：.&#x2F;process-run.py -l 5:100,5:100。CPU 利用率（CPU 使用时间的百分比）应该是多少？为什么你知道这一点？利用 -c 标记查看你的答案是否正确。</strong></p>
<p>运行结果如下</p>
<p>**cpu 利用率为 100%**，可以看到进程 0 和进程 1 交替执行，且没有调用 IO 命令。</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943336.png" alt="image-20211107224505762"></p>
<p>加上-c 标记后运行结果。CPU 一直处于占用状态，验证正确</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943337.png" alt="image-20211107224328317"></p>
<p><strong>4.2</strong></p>
<p><strong>现在用这些标志运行：.&#x2F;process-run.py -l 4:100,1:0。这些标志指定了一个包含 4 条指令的进程（都要使用 CPU），并且只是简单地发出 I&#x2F;O 并等待它完成。完成这两个进程需要多长时间？利用-c 检查你的答案是否正确。</strong></p>
<p>从运行结果来看，进程 0 的 4 条指令需要占用 4 个 cpu 时间，发起 io 和 io 结束需要 2 个时装周期 ，io 占用时间还无法得知。total&#x3D;4+2+n</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943338.png"></p>
<p>加上-c 标记后运行结果，可以看到程序一共占用了 11 个时钟周期，io 占用了 5 时钟周期</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111120937254.png"></p>
<p><strong>4.3</strong></p>
<p><strong>现在交换进程的顺序：.&#x2F;process-run.py -l 1:0,4:100。现在发生了什么？交换顺序是否重要？为什么？同样，用-c 看看你的答案是否正确。</strong></p>
<p>交换运行顺序后，首先运行进程 0，进程 0 发起 IO，系统进行上下文切换，进程 1 占用 cpu 执行程序。</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943340.png" alt="image-20211109170627689"></p>
<p>加上-c，可以看到，让进程 0 先执行 IO 的话，进程 1 在进程 0 调用 IO 的同时可占用 CPU。只需 6 个时钟周期即可执行完程序</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943341.png" alt="image-20211109171420829"></p>
<p><strong>4.4</strong></p>
<p><strong>现在交换进程的顺序：.&#x2F;process-run.py -l 1:0,4:100。现在发生了什么？交换顺序是否重要？为什么？同样，用-c 看看你的答案是否正确。</strong></p>
<p>可以看到，因为进程在进行 I&#x2F;O 操作时，系统不会进行上下文切换，所以进程 1 只能等待进程 0 调用 IO 结束再占用 CPU，最终要消耗 9 个时钟周期</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943342.png" alt="image-20211109172648650"></p>
<p><strong>4.5</strong></p>
<p><strong>现在，运行相同的进程，但切换行为设置，在等待 I&#x2F;O 时切换到另一个进程（-l 1:0,4:100-c -S SWITCH_ON_IO）。现在会发生什么？利用-c 来确认你的答案是否正确。</strong></p>
<p>可以看到，让进程 0 先执行 IO，然后系统进行上下文切换，进程 1 可占用 CPU。只需 6 个时钟周期即可执行完程序</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943343.png" alt="image-20211109172752093"></p>
<h2 id="第五章-进程-API"><a href="#第五章-进程-API" class="headerlink" title="第五章-进程 API"></a>第五章-进程 API</h2><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><h4 id="fork-系统调用"><a href="#fork-系统调用" class="headerlink" title="fork 系统调用"></a><strong>fork 系统调用</strong></h4><p>1、子进程不会从 main()函数开始执行，而是直接从 fork()系统调用返回。</p>
<p>2、子进程拥有自己的地址空间（即拥有自己的私有内存）、寄存器、程序计数器等</p>
<p>3、父进程获得的返回值是新创建子进程的 PID，而子进程获得的返回值是 0</p>
<p>4、子进程和父进程的运行顺序取决于 CPU 调度顺序</p>
<p><strong>代码实现</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line"><span class="type">int</span> rc = fork();</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123; <span class="comment">// fork failed; exit</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123; <span class="comment">// child (new process)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// parent goes down this path (main)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello, I am parent of %d (pid:%d)\n&quot;</span>,</span><br><span class="line">rc, (<span class="type">int</span>) getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="wait-系统调用"><a href="#wait-系统调用" class="headerlink" title="wait 系统调用"></a>wait 系统调用</h4><p>父进程调用 wait()，延迟自己的执行，直到子进程执行完毕。当子进程结束，wait()才返回父进程。</p>
<p>代码实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line"> <span class="type">int</span> rc = fork();</span><br><span class="line"> <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123; <span class="comment">// fork failed; exit</span></span><br><span class="line"> <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123; <span class="comment">// child (new process)</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; <span class="comment">// parent goes down this path (main)</span></span><br><span class="line"> <span class="type">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;</span>,</span><br><span class="line"> rc, wc, (<span class="type">int</span>) getpid());</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prompt&gt; ./p2</span><br><span class="line">hello world (pid:29266)</span><br><span class="line">hello, I am child (pid:29267)</span><br><span class="line">hello, I am parent of 29267 (wc:29267) (pid:29266)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>

<h4 id="exec-系统调用"><a href="#exec-系统调用" class="headerlink" title="exec 系统调用"></a>exec 系统调用</h4><p>这个系统调用可以让子进程执行与父进程不同的程序。例如，在 p2.c 中调用 fork()，这只是在你想运行相同程序的拷贝谁有用。但是，我们常常想运行不同的程序，exec()正好做这样的事</p>
<p>这个例子中，子进程调用 execvp()来运行字符计数程序 wc。</p>
<p>exec()会从可执行程序中加载代码和静态数据，并用它覆写自己代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化。然后操作系统就执行该程序，将参数通过 argv 传递给该进程。因此，它并没有创建新进程，而是直接将当前运行的程序（以前的 p3）替换为不同的运行程序（wc）。子进程执行 exec()之后，几乎就像 p3.c 从未运行过一样。对 exec()的成功调用永远不会返回</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">prompt&gt; ./p3</span><br><span class="line">hello world (pid:29383)</span><br><span class="line">hello, I am child (pid:29384)</span><br><span class="line">29 107 1030 p3.c</span><br><span class="line">hello, I am parent of 29384 (wc:29384) (pid:29383)</span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line"><span class="type">int</span> rc = fork();</span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123; <span class="comment">// fork failed; exit</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123; <span class="comment">// child (new process)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="type">int</span>) getpid());</span><br><span class="line"><span class="type">char</span> *myargs[<span class="number">3</span>];</span><br><span class="line">myargs[<span class="number">0</span>] = strdup(<span class="string">&quot;wc&quot;</span>); <span class="comment">// program: &quot;wc&quot; (word count)</span></span><br><span class="line">myargs[<span class="number">1</span>] = strdup(<span class="string">&quot;p3.c&quot;</span>); <span class="comment">// argument: file to count</span></span><br><span class="line">myargs[<span class="number">2</span>] = <span class="literal">NULL</span>; <span class="comment">// marks end of array</span></span><br><span class="line">execvp(myargs[<span class="number">0</span>], myargs); <span class="comment">// runs word count</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;this shouldn&#x27;t print out&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// parent goes down this path (main)</span></span><br><span class="line"><span class="type">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;</span>,</span><br><span class="line">rc, wc, (<span class="type">int</span>) getpid());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="why-splits-fork-and-exec"><a href="#why-splits-fork-and-exec" class="headerlink" title="why splits fork() and exec()"></a>why splits fork() and exec()</h4><p>在构建 UNIX shell 的时候非常有用，因为这给了 shell 在 fork 之后 exec 之前运行代码的机会，这些代码可以在运行新程序前改变环境，实现一些有趣的功能。</p>
<p>例<code>prompt&gt; wc p3.c &gt; newfile.txt</code><br>在上面的例子中，wc 的输出结果被重定向（redirect）到文件 newfile.txt 中（通过 newfile.txt 之前的大于号来指明重我向）。shell 实现结果重定向的方式也很简单，当完成子进程的创建<br>后，shell 在调用 exec()之前先关闭了标准输出（standardoutput），打开了文件 newfile.txt。这样，即将运行的程序 wc 的输出结果就被发送到该文件，而不是打印在屏幕上。</p>
<h3 id="课后习题-1"><a href="#课后习题-1" class="headerlink" title="课后习题"></a>课后习题</h3><p><strong>5.1</strong></p>
<p><strong>编写一个调用 fork()的程序。谁调用 fork()之前，让主进程访问一个变量（例如 x）并将其值设置为某个值（例如 100）。子进程中的变量有什么值？当子进程和父进程都改变 x 的值，变量会发生什么？</strong></p>
<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;<span class="comment">//在调用之前,让主进程访问一个变量(例如 x)并将其值设               //置为100</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child, x %d\n&quot;</span>, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent, x %d\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">//当子进程和父进程都改变 x 的值时</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child,x %d\n&quot;</span>, x);</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child,x %d\n&quot;</span>, x);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent,x %d\n&quot;</span>, x);</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent,x %d\n&quot;</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">        test1();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        test2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，在调用之前,让主进程访问一个变量(例如 x)并将其值设为 100，父进程和子进程的 x 值都为 100</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943344.png" alt="image-20211109174929408"></p>
<p>当子进程和父进程在各自进程修改 x 值时，父子进程的值各自不受影响</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943345.png" alt="image-20211109173934825"></p>
<p><strong>5.2</strong></p>
<p><strong>编写一个打开文件的程序（使用 open()系统调用），然后调用 fork()创建一个新进程。子进程和父进程都可以访问 open()返回的文件描述符吗？当它在并发（即同时）写入文件时，会发生什么？</strong></p>
<p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;./check.txt&quot;</span>, O_CREAT | O_RDWR | O_TRUNC, S_IRWXU);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> *buf = <span class="string">&quot;child\n&quot;</span>;</span><br><span class="line">        <span class="type">int</span> error = write(fd, buf, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child error: %d\n&quot;</span>, error == <span class="number">-1</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> *buf = <span class="string">&quot;parent\n&quot;</span>;</span><br><span class="line">        <span class="type">int</span> error = write(fd, buf, <span class="keyword">sizeof</span>(<span class="type">char</span>) * <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child error: %d\n&quot;</span>, error == <span class="number">-1</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下，可以看到</p>
<p>父进程，子进程都能访问 open 返回的 fd 文件符。当他们同时写入文件时，存在竞争条件，但因为操作系统会进行调度，所以最终两个进程都能写入成功</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943346.png" alt="image-20211109180303635"></p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943347.png" alt="image-20211109180212533"></p>
<p><strong>5.4</strong></p>
<p><strong>编写一个调用 fork()的程序,然后调用某种形式的 exec()来运行序”&#x2F;bin&#x2F;ls”看看是否可以尝试 exec 的所有变体,包括 execl()、 execle()、 execlp()、 execv()、 execvp()和 execve(),为什么同样的基本调用会有这么多变种？</strong></p>
<p>测试代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[], char *envp[]) &#123;</span><br><span class="line">  int pid = fork();</span><br><span class="line">  char *cmd = &quot;/bin/ls&quot;;</span><br><span class="line">  char *arg[] = &#123;&quot;ls&quot;, &quot;-a&quot;, NULL&#125;;</span><br><span class="line"></span><br><span class="line">  if (pid &lt; 0) &#123;</span><br><span class="line">    printf(&quot;fork error\n&quot;);</span><br><span class="line">    exit(1);</span><br><span class="line">  &#125; else if (pid == 0) &#123;</span><br><span class="line">    //    exec不会返回,所以第一条execl语句后的语句不会被执行</span><br><span class="line">    execl(cmd, &quot;ls&quot;, NULL);</span><br><span class="line">    execlp(cmd, &quot;ls&quot;, NULL);</span><br><span class="line">    execve(cmd, arg, envp);</span><br><span class="line">    execv(cmd, arg);</span><br><span class="line">    execvp(cmd, arg);</span><br><span class="line">    execle(cmd, &quot;ls&quot;, NULL, envp);</span><br><span class="line">    execvP(cmd,arg)</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是调用各个形式的 exec 函数后程序的运行结果</p>
<p>exec 多个变体能提供不同的功能,不同后缀指示着不同的操作功能：</p>
<ol>
<li>l: 希望接收以逗号分隔的参数列表,列表以 NULL 指针作为结束标志</li>
<li>v: 希望接收一个以 NULL 结尾字符串数组的指针</li>
<li>p: 是一个以 NULL 结尾的字符串数组指针,函数可以利用 DOS 的 PATH 变量查找自程序文件</li>
<li>e： 函数传递指定采纳数 envp(环境变量),允许改变子进程环境,无后缀 e 是,子进程使用当前程序环境</li>
<li>c 语言没有默认参数语法,只能实现多个变体</li>
</ol>
<p>execl:</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943348.png" alt="image-20211109195822756"></p>
<p>execlp:</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943349.png" alt="image-20211109195938552"></p>
<p>execve：</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943350.png" alt="image-20211109200052709"></p>
<p>execv：</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943351.png" alt="image-20211109200128674"></p>
<p>execvp：</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943352.png" alt="image-20211109200209564"></p>
<p>execle：</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943353.png" alt="image-20211109200430882"></p>
<p>execlP：</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943354.png" alt="image-20211109200543452"></p>
<h2 id="第六章——受限直接执行"><a href="#第六章——受限直接执行" class="headerlink" title="第六章——受限直接执行"></a>第六章——受限直接执行</h2><h3 id="受限运行协议"><a href="#受限运行协议" class="headerlink" title="受限运行协议"></a>受限运行协议</h3><p><strong>用户模式</strong> user mode：在用户模式下运行的代码会受到限制，如用户模式下，进程不能发出 I&#x2F;O，这样会引发异常，可能导致操作系统终止该进程</p>
<p><strong>内核模式</strong> kernel mode：操作系统就在内核模式下运行，在此模式下，运行的代码可以做它想做的所有事，包括特权操作，发出 I&#x2F;O 和执行所有类型的受限制操作</p>
<p>受限直接运行<strong>有两个阶段</strong>：<br>1，系统引导时：内核初始化陷阱表，CPU 记住陷阱表的位置以供使用<br>2，运行进程时：在执行进程前，操作系统为进程初始化了一些内容，接着转入用户模式运行程序。当进程发起系统调用时，会重新陷入操作系统，然后通过陷阱返回，并将控制权重新交给进程</p>
<p>通过让进程在用户模式和内核模式间切换，就完成了保护操作系统的控制权，且限制进程的运行，让它不能做不应该做的事</p>
<p><img src="https://s2.loli.net/2022/01/09/k2O1dHJv7jxi5Is.png" alt="image-20220109081403999"></p>
<p><img src="https://s2.loli.net/2022/01/09/IHiywGmulDKWvEU.png" alt="image-20220109081547409"></p>
<p>操作系统通过时钟中断重新获得了 CPU 的控制权，那么它需要决定：是继续运行当前的进程，还是切换其它进程，这个决定是由调度程序做出的，它是操作系统的一部分，这里先说明如何切换进程</p>
<p>如果决定切换进程，OS 就会执行一些底层代码，即上下文切换：操作系统为当前正执行的进程保存它寄存器的值，并为即将执行的进程恢复寄存器的值，这样操作系统可以确保从内核模式返回时，去执行另一个进程而不是之前运行的进程</p>
<p>下面是进程 A，B 间切换的一张表，操作系统决定从当前正在运行的进程 A 切换到进程 B，它调用 switch()，该系统调用会保存当前运行进程的寄存器的值(保存到 A 的进程结构)，将 B 的进程结构恢复到寄存器，从内核模式退出到用户模式，进入 B 进程执行代码</p>
<h2 id="第七章——进程调度"><a href="#第七章——进程调度" class="headerlink" title="第七章——进程调度"></a>第七章——进程调度</h2><h3 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h3><h4 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a><strong>调度指标</strong></h4><p>周转时间：T <del>周转时间</del>&#x3D; T <del>完成时间</del>−T <del>到达时间</del></p>
<p>响应时间：T<del>响应时间</del>&#x3D; T <del>首次运行</del>−T <del>到达时间</del></p>
<p>公平性：每个进程都有得到调度的机会</p>
<h4 id="FIFO（先来先服务）"><a href="#FIFO（先来先服务）" class="headerlink" title="FIFO（先来先服务）"></a>FIFO（先来先服务）</h4><p>优点：它很简单，而且易于实现</p>
<p>缺点：护航效应，一些耗时较少的潜在资源消费者被排在重量级的资源消费者之后。导致很差的平均周转时间</p>
<h4 id="SJF（最短任务优先）"><a href="#SJF（最短任务优先）" class="headerlink" title="SJF（最短任务优先）"></a>SJF（最短任务优先）</h4><p>考虑到所有工作同时到达的假设，先运行最短的任务，然后是次短的任务，如此下去。</p>
<p>我们可以证明 SJF 确实是一个最优的调度算法（假设所有任务同时到达）</p>
<h4 id="最短完成时间优先（STCF）"><a href="#最短完成时间优先（STCF）" class="headerlink" title="最短完成时间优先（STCF）"></a>最短完成时间优先（STCF）</h4><p>每当新工作进入系统时，它就会确定剩余工作和新工作中，谁的剩余时间最少，然后调度该工作。</p>
<p>允许抢占，放宽假设，所有任务不是同时到达的</p>
<p>优点：结果是平均周转时间大大提高，虑到我们的新假设，STCF 可证明是最优的。考虑到如果所有工作同时到达，SJF 是最优的</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111112050629.png" alt="image-20211111205039567"></p>
<h4 id="轮转（RR）"><a href="#轮转（RR）" class="headerlink" title="轮转（RR）"></a>轮转（RR）</h4><p>基本思想：RR 在一个时间片（time slice，有时称为调度 scheduling quantum）内运行一个工作，然后切换到运行队列中的下一个任务，而不是运行一个任务直到结束。它反复执行，直到所有任务完成。</p>
<p>【请注意，时间片长度必须是时钟中断周期的倍数。】</p>
<p>时间片长度对于 RR 是至关重要的。<br>时间片太短是有问题的：突然上下文切换的成本将影响整体性能。因此，系统设计者需要权衡时间片的长度，使其足够长，以便摊销（amortize）上下文切换成本，而又不会使系统不及时响应。</p>
<p>优势：有非常好的平均响应时间，通过设置合适的时间片，能获得不错的性能</p>
<p>缺点：较差的平均周转时间</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111230810271.png" alt="image-20211123081045212"></p>
<h4 id="结合-IO"><a href="#结合-IO" class="headerlink" title="结合 IO"></a><strong>结合 IO</strong></h4><p>当一个交互性进程发出 IO 让出 CPU 后，调度程序调度其他程序，从而更好地利用 CPU<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111112104131.png" alt="image-20211111210429081"></p>
<h3 id="课后习题-2"><a href="#课后习题-2" class="headerlink" title="课后习题"></a>课后习题</h3><p><strong>7.1</strong></p>
<p><strong>使用 SJF 和 FIFO 调度程序运行长度为 200 的 3 个作业时,计算响应时间和周转时间。</strong></p>
<table>
<thead>
<tr>
<th>作业 ID</th>
<th>响应时间</th>
<th>周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>SJF</td>
<td>平均响应时间:200</td>
<td>平均周转时间:400</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>200</td>
</tr>
<tr>
<td>2</td>
<td>200</td>
<td>400</td>
</tr>
<tr>
<td>3</td>
<td>400</td>
<td>600</td>
</tr>
<tr>
<td>FIFO</td>
<td>平均响应时间:200</td>
<td>平均周转时间:400</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>200</td>
</tr>
<tr>
<td>2</td>
<td>200</td>
<td>400</td>
</tr>
<tr>
<td>3</td>
<td>400</td>
<td>600</td>
</tr>
</tbody></table>
<p><strong>7.2</strong></p>
<p>现在做同样的事情,但有不同长度的作业,即 100、200 和 300</p>
<table>
<thead>
<tr>
<th>作业 ID</th>
<th>响应时间</th>
<th>周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>SJF</td>
<td>平均响应时间：133.3</td>
<td>平均周转时间：333.3</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>100</td>
<td>300</td>
</tr>
<tr>
<td>3</td>
<td>300</td>
<td>600</td>
</tr>
<tr>
<td>FIFO</td>
<td>平均响应时间：133.3</td>
<td>平均周转时间：333.3</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>100</td>
</tr>
<tr>
<td>2</td>
<td>100</td>
<td>300</td>
</tr>
<tr>
<td>3</td>
<td>300</td>
<td>600</td>
</tr>
</tbody></table>
<p><strong>7.3</strong></p>
<p><strong>现在做同样的事情,但采用 RR 调度程序,时间片为 1</strong></p>
<table>
<thead>
<tr>
<th>作业 ID</th>
<th>响应时间</th>
<th>周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>RR</td>
<td>平均响应时间：2</td>
<td>平均周转时间：599</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>598</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>599</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>600</td>
</tr>
</tbody></table>
<p>当三件工作时间分别为 100,200,300 时</p>
<table>
<thead>
<tr>
<th>作业 ID</th>
<th>响应时间</th>
<th>周转时间</th>
</tr>
</thead>
<tbody><tr>
<td>RR</td>
<td>平均响应时间：2</td>
<td>平均周转时间：456.67</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>298</td>
</tr>
<tr>
<td>2</td>
<td>2</td>
<td>499</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>600</td>
</tr>
</tbody></table>
<p><strong>7.4</strong></p>
<p><strong>对于什么类型的工作负载,SJF 提供与 FIFO 相同的周转时间?</strong></p>
<p>以第一条：作业列表中的作业到达时间全部不一致。<br>第二，当作业到达时间一致时，在极细微可以忽略不计的时间上，作业列表中的作业排序必须按作业长度非严格递增。<br>第三，当有的作业到达时间一致，有的不一致时，到达时间一致的作业满足第二条。</p>
<p><strong>7.5</strong></p>
<p><strong>对于什么类型的工作负载和量子长度,SJF 与 RR 提供相同的响应时间?</strong></p>
<p>当运行时间小于等于时间片的时候，SJF 和 RR 提供相同的响应时间</p>
<p><strong>7.6</strong></p>
<p><strong>随着工作长度的增加,SJF 的响应时间会怎样?</strong></p>
<p>随着工作长度的增加，SJF 的响应时间越来越长</p>
<p><strong>7.7</strong></p>
<p><strong>随着量子长度的增加,RR 的响应时间会怎样?你能写出一个方程,计算给定 N 个工作时,最坏情况的响应时间吗?</strong></p>
<p>随着量子长度的增加，RR 的平均响应时间会增加</p>
<p>假设 k 个工作 n1,n2,n3..nk</p>
<p>工作长度为 t1,t2…tk 且 t1&gt;t2&gt;…tk</p>
<p>最坏情况的平均响应时间为</p>
<p>averT&#x3D;(t1+t1+t2+t1+t2+t3+t1+t2+t3…)&#x2F;k&#x3D;((k-1)t1+(k-2)t2+…tk-1)&#x2F;k</p>
<h2 id="第八章—调度：多级反馈队列（MLFQ）"><a href="#第八章—调度：多级反馈队列（MLFQ）" class="headerlink" title="第八章—调度：多级反馈队列（MLFQ）"></a>第八章—调度：多级反馈队列（MLFQ）</h2><h3 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h3><p><strong>MLFQ（多级反馈队列）</strong></p>
<p>有许多独立的队列，每个列有不同的优先级。并利用反馈信息决定某个工作的优先级。一个工作只能处于一个队列中。MLFQ 总是优先执行优先级高的工作。对于一个队列中的工作，我们采取轮转调度</p>
<p>规则 1：如果 A 的优先级大于 B 优先级，运行 A</p>
<p>规则 2：如果 A 的优先级&#x3D;B，轮转运行 A 和 B</p>
<p><strong>尝:1：改变优先级</strong></p>
<p>规则 3：工作进入系统时，放在最高优先级</p>
<p>规则 4a：工作用完整个时间片后，降低其优先级（移入下一个队列）</p>
<p>规则 4b：如果工作在其时间片内主动释放 cpu，则优先级不变</p>
<p><strong>当前存在的问题</strong></p>
<p>饥饿问题，如果一个程序总是在时间片用完之前让出 cpu，那么它将永远占据高优先级，导致长工作饿死</p>
<p>存在愚弄程序，使一个程序总是在时间片用完之前让出 cpu，它将永远占据高优先级</p>
<p>一个程序不同时间表现不同，一个刚开始计算密集型程序可能在某段时间表现为交互性，那么他无法享受到交互性的待遇</p>
<p><strong>尝试 2：提升优先级</strong></p>
<p>周期性地提升（boost）所有工作的优先级</p>
<p>规则 5：经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</p>
<p><strong>尝试 3：更好的计时方式</strong></p>
<p>规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次 CPU），就降低其优先级（移入低一级队列）</p>
<p><strong>其他问题</strong></p>
<p>1.如何配置一个调度程序，例如，配置多少队列？每一层队列的时间片配置多大？</p>
<p>大多数的 MLFQ 变体都支持不同队列可变的时间片长度。高优先级队列通常只有较短的时间片（比如 10ms 或者更少），因而这一层的交互工作可以更快地切换。相反，低优先级队列中更多的是 CPU 密集型工作，配置更长的时间片会取得更好的效果。</p>
<p><strong>MLFQ 优点</strong></p>
<p>1.它不需要对工作的运行方式有先验知识，而是通过观察工作的运行来给出对应的优先级</p>
<p>2.MLFQ 可以同时满足各种工作的需求：对于短时间运行的交互型工作，获得类似于 SJF&#x2F;STCF 的很好的全局性能，同时对长时间运行的 CPU 密集型负载也可以公平地、不断地稳步向前。</p>
<p>因此，许多系统使用某种类型的 MLFQ 作为自己的基础调度程序，包括类 BSD UNIX 系统[LM+89，B86]、Solaris[M06]以及 WindowsNT 和其后的 Window 系列操作系统。</p>
<h3 id="课后习题-3"><a href="#课后习题-3" class="headerlink" title="课后习题"></a>课后习题</h3><p><strong>8.1</strong></p>
<p><strong>只用两个工作和两个队列运行几个随机生成的问题。针对每个工作计算 MLFQ 的执行记录。限制每项作业的长度并关闭 I&#x2F;O，让你的生活更轻松。</strong></p>
<p>执行命令行 python2 mlfq.py -j 2 -n 2 -M 0 -m 15 -s 1</p>
<p>程序运行结果如图</p>
<table>
<thead>
<tr>
<th></th>
<th>到达时间</th>
<th>占用 cpu 时间</th>
<th>完成时间</th>
<th>总执行时间</th>
<th>是否调用 io</th>
</tr>
</thead>
<tbody><tr>
<td>job0</td>
<td>0</td>
<td>0-1（位于 Q1）</td>
<td>1</td>
<td>2</td>
<td>否</td>
</tr>
<tr>
<td>job1</td>
<td>0</td>
<td>2-11（位于 Q2）</td>
<td>11</td>
<td>11</td>
<td>否</td>
</tr>
</tbody></table>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111101943355.png" alt="image-20211109210002760"></p>
<p><strong>8.3</strong></p>
<p><strong>将如何配置调度程序参数，像轮转调度程序那样工作？</strong></p>
<p>因为对于同一个队列中的工作，采取轮转的方式调度。所以将队列数设为 1 即可</p>
<p><strong>8.5</strong></p>
<p><strong>给定一个系统，其最高队列中的时间片长度为 10ms，你需要如何频繁地将工作推回到最高优先级级别（带有-B 标志），以保证一个长时间运行（并可能饥饿）的工作得到至少 5%的 CPU？</strong></p>
<p>保证参数 B 小于等于 190，这样至少每隔 200ms 这个长时间运行工作就能被执行 10ms（5%）</p>
<h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h3 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h3><h4 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a><strong>彩票调度</strong></h4><p>彩票数（ticket）代表了进程（或用户或其他）占有某个资源的份额。一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。</p>
<p><strong>一个简单的例子</strong></p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111111054744.png" alt="image-20211111105425418"></p>
<p><strong>优势</strong></p>
<p>彩票调度最精彩的地方在于利用了随机性<br>随机方法相对于传统的决策方式，至少有 3 点优势。</p>
<p>第一，随机方法常常可以避免奇怪的边角情况<br>第二，随机方法很轻量，几乎不需要记录任何状态。<br>第三，随机方法很快。只要能很快地产生随机数，做出决策就很快</p>
<p><strong>彩票调度机制</strong></p>
<p>1、一种方式是利用彩票货币（ticket currency）的概念。这种方式允许拥有一组彩票的用户以他们喜欢的某种货币，将彩票分给自己的不同工作。之后操作系统再自动将这种货币兑换为正确的全局彩票。</p>
<p>eg：假设用户 A 和用户 B 每人拥有 100 张彩票。用户 A 有两个工作 A1 和 A2，他以自己的货币，给每个工作 500 张彩票（共 1000 张）。用户 B 只运行一个工作，给它 10 张彩票（总共 10 张）。操作系统将进行兑换，将 A1 和 A2 拥有的 A 的货币 500 张，兑换成全局货币 50 张。类似地，兑换给 B1 的 10 张彩票兑换成 100 张。然后会对全局彩票货币（共 200 张）举行抽奖，决定哪个工作运行。</p>
<p>2、彩票转让，一个进程可以临时将自己的彩票交给另一个进程。</p>
<p>3、彩票通胀（ticket inflation）有时也很有用。利用通胀，一个进程可以临时提升或降低自己拥有的彩票数量。</p>
<p><strong>代码实现</strong></p>
<p>要让这个过程更有效率，建议将列表项按照彩票数递减排序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 // counter: used to track if we&#x27;ve found the winner yet</span><br><span class="line">2 int counter = 0;</span><br><span class="line">3</span><br><span class="line">4 // winner: use some call to a random number generator to</span><br><span class="line">5 // get a value, between 0 and the total # of tickets</span><br><span class="line">6 int winner = getrandom(0, totaltickets);</span><br><span class="line">7</span><br><span class="line">8 // current: use this to walk through the list of jobs</span><br><span class="line">9 node_t *current = head;</span><br><span class="line">10</span><br><span class="line">11 // loop until the sum of ticket values is &gt; the winner</span><br><span class="line">12 while (current) &#123;</span><br><span class="line">13 counter = counter + current-&gt;tickets;</span><br><span class="line">14 if (counter &gt; winner)</span><br><span class="line">15 break; // found the winner</span><br><span class="line">16 current = current-&gt;next;</span><br><span class="line">17 &#125;</span><br><span class="line">18 // &#x27;current&#x27; is the winner: schedule it...</span><br></pre></td></tr></table></figure>

<h4 id="步长调度"><a href="#步长调度" class="headerlink" title="步长调度"></a>步长调度</h4><p>确定性的公平分配算法</p>
<p>步长调度也很简单。系统中的每个工作都有自己的步长，这个值与票数值成反比。当需要进行调度时，选择目前拥有最小行程值的进程，并且在运行之后将该进程的行程值增加一个步长。</p>
<p><strong>一个例子</strong></p>
<p>A、B、C 这 3 个工作的票数分别是 100、50 和 250，我们通过用一个大数分别除以他们的票数来获得每个进程的步长。比如用 10000 除以这些票数值，得到了 3 个进程的步长分别为 100、200 和 40。我们称这个值为每个进程的步长（stride）。每次进程运<br>行后，我们会让它的计数器 [称为行程（pass）值] 增加它的步长，记录它的总体进展。</p>
<p>可以看出，C 运行了 5 次、A 运行了 2 次，B 一次，正好是票数的比例——200、100 和 50。彩票调度算法只能一段时间后，在概率上实现比例，而步长调度算法可以在每个调度周期后做到完全正确。</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111111105771.png" alt="image-20211111110512549"></p>
<p><strong>优势</strong></p>
<p>步长调度能实现一个确定性的公平分配算法。</p>
<p>随机方式可以使得调度程序的实现简单（且大致正确），但偶尔并不能产生正确的比例，尤其在工作运行时间很短的情况下。</p>
<p><strong>劣势</strong></p>
<p>彩票调度有一个步长调度没有的优势——不需要全局状态。因此彩票调度算法能够更合理地处理新加入的进程。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>比例份额调度的两种实现：彩票调度和步长调度。但这两种方法没有作为 CPU 调度程序被广泛使用</p>
<p>原因一：这两种方式都不能很好地适合 I&#x2F;O[AC97]</p>
<p>原因二：没有解决如何分配彩票的问题</p>
<p>原因三：彩票调度在工作执行时间很短时，平均不公平度非常糟糕。只有当工作执行非常多的时间片时，彩票调度算法才能得到期望的结果。</p>
<p>原因四：步长调度需要全局状态，不能很好的解决新加入的进程</p>
<p>比例份额调度程序只有在这些问题可以相对容易解决的领域更有用（例如容易确定份额比例）。例如在虚拟（virtualized）数据中心中，你可能会希望分配 1&#x2F;4 的 CPU 周期给 Windows 虚拟机，剩余的给 Linux 系统，比例分配的方式可以更简单高效。</p>
<h3 id="课后习题-4"><a href="#课后习题-4" class="headerlink" title="课后习题"></a>课后习题</h3><p><strong>9.1</strong></p>
<p><strong>计算 3 个工作在随机种子为 1、2 和 3 时的模拟解。</strong></p>
<p>运行命令行 python2 lottery.py -j 3 -s 1，随机种子为 1</p>
<p>可以看到，</p>
<p>时间片 R&#x3D;1</p>
<p>job0 ，总占用时间：1，彩票数：0-83</p>
<p>job1 ，总占用时间：7，彩票数：84-108</p>
<p>job2 ，总占用时间：2，彩票数：109-152</p>
<p>产生的随机数依次取模得到执行作业的顺序为：</p>
<p>2 0 1 2 2 2 1 1 1 1 1 1</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111111128405.png" alt="image-20211111112849348"></p>
<p>运行命令行 python2 lottery.py -j 3 -s 2，随机种子为 2</p>
<p>同理可得到执行作业的顺序：</p>
<p>2 0 0 2 0 1 0 2 0 0 0 1 0 0 1 2 1 1 1 2 1 1 2</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111111133096.png" alt="image-20211111113351023"></p>
<p>运行命令行 python2 lottery.py -j 3 -s 3，随机种子为 3</p>
<p>同理可得到执行作业的顺序：</p>
<p>1 1 0 1 0 2 2 2 2 2 2</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111111134211.png" alt="image-20211111113449142"></p>
<p><strong>9.2</strong></p>
<p><strong>现在运行两个具体的工作：每个长度为 10,但是一个（工作 0)只有一张彩票，另一个（工作 1)有 100 张（-l 10:1,10:100).彩票数量如此不平衡时会发生什么？在工作 1 完成之前，工作 0 是否会运行？多久？一般来说，这种彩票不平衡对彩票调度的行为有什么影响？</strong></p>
<p>只有一张彩票被调度的可能性非常小，可能会饿死。</p>
<p>在工作 1 完成之前，工作 0 可能会运行。</p>
<p>这种行为可能会导致平均周转和响应时间变得很差</p>
<p><strong>9.3</strong></p>
<p><strong>如果运行两个长度为 100 的工作，都有 100 张彩票（-l 100:100,100:100),调度程序有多不公平？运行一些不同的随机种子来确定（概率上的）答案。不公平性取决于一项工作比另一项工作早完成多少。</strong></p>
<p>分别运行命令行</p>
<p>python2 lottery.py -l 100:100,100:100 -s 1 -c</p>
<p>python2 lottery.py -l 100:100,100:100 -s 25 -c</p>
<p>python2 lottery.py -l 100:100,100:100 -s 50 -c</p>
<p>python2 lottery.py -l 100:100,100:100 -s 100 -q 10 -c(调整时间片为 10)</p>
<p>python2 lottery.py -l 100:100,100:100 -s 100 -q 30 -c(调整时间片为 30)</p>
<p>可以看到随机种子为 1 时 job0 在 192 时完成，job1 在 200 的时候完成</p>
<p>随机种子为 25 时 job1 在 182 时完成，job0 在 200 的时候完成</p>
<p>随机种子为 50 时 job1 在 188 时完成，job0 在 200 的时候完成</p>
<p>公平性都还不错</p>
<p>可以看到当时间片调整为 10 后，job1 在 140 时完成，job0 在 200 的时候完成</p>
<p>当时间片调整为 30 后，job1 在 150 时完成，job0 在 240 的时候完成</p>
<p>公平性较差</p>
<p>一般来说，时间片越小，两个工作完成的时间越接近，公平性越高</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111111143789.png" alt="image-20211111114313728"></p>
<h2 id="第十章——多处理器调度"><a href="#第十章——多处理器调度" class="headerlink" title="第十章——多处理器调度"></a>第十章——多处理器调度</h2><p><strong>多处理器架构</strong></p>
<p><strong>缓存一致性（cache coherence）问题</strong></p>
<p>与单处理器的核心区别在于对硬件缓存（cache）的使用，事实证明，多 CPU 的情况下缓存要复杂得多。例如，假设一个运行在 CPU 1 上的程序从内存地址 A 读取数据。由于不在 CPU 1 的缓存中，所以系统直接访问内存，得到值 D。程序然后修改了地址 A 处的值，只是将它的缓存更新为新值 D’。将数据写回内存比较慢，因此系统（通常）会稍后再做。假设这时操作系统中断了该程序的运行，并将其交给 CPU 2，重新读取地址 A 的数据，由于 CPU 2 的缓存中并没有该数据，所以会直接从内存中读取，得到了旧值 D，而不是正确的值 D’。</p>
<p>基本解决方案：通过监控内存访问，硬件可以保证获得正确的<br>数据，并保证共享内存的唯一性。在基于总线的系统中，一种方式是使用总线窥探（bus snooping）[G83]。每个缓存都通过监听链接所有缓存和内存的总线，来发现内存访问。如果 CPU 发现对它放在缓存中的数据的更新，会作废（invalidate）本地副本（从缓存中移除），<br>或更新（update）它（修改为新值）。回写缓存。</p>
<p><strong>缓存亲和度（cache affinity</strong>）<br>一个进程在某个 CPU 上运行时，会在该 CPU 的缓存中维护许多状态。下次该进程在相同 CPU 上运行时，由于缓存中的数据而执行得更快。相反，在不同的 CPU 上执行，会由于需要重新加载数据而很慢（好在硬件保证的缓存一致性可以保证正确执行）。因此多处理器调度应该考虑到这种缓存亲和性，<strong>并尽可能将进程保持在同一个 CPU 上</strong></p>
<p><strong>单队列调度</strong>（SQMS）</p>
<p>简单地复用单处理器调度的基本架构，将所有需要调度的工作放入一个单独的队列中。</p>
<p>优点：能够从单 CPU 调度程序很简单地发展而来</p>
<p>短板：它的扩展性不好（由于同步开销有限），并且不能很好地保证缓存亲和度。</p>
<p>调度程序的开发者需要在代码中通过加锁（locking）来保证原子性</p>
<p>为了解决缓存亲和性这个问题，大多数 SQMS 调度程序都引入了一些亲和度机制，尽可能让进程在同一个 CPU 上运行。保持一些工作的亲和度的同时，可能需要牺牲其他工作的亲和度来实现负载均衡</p>
<p><strong>多队列调度</strong>MQMS</p>
<p>有些系统使用了多队列的方案，比如每个 CPU 一个队列。我们称之为多队列多处理器调度。基本调度框架包含多个调度队列，每个队列可以使用不同的调度规则</p>
<p>优势：具有可扩展性和缓存亲和性，所有工作都保持在固定的 CPU 上</p>
<p>短板：负载不均衡（每个 CPU 承载的工作不平衡），</p>
<p>解决方案：<strong>工作迁移</strong>，通过工作的跨 CPU 迁移。</p>
<p><strong>工作窃取</strong>，工作量较少的（源）队列不定期地“偷看”其他（目标）队列是不是比自己的工作多。如果目标队列比源队列（显著地）更满，就从目标队列“窃取”一个或多个工作，实现负载均衡。</p>
]]></content>
      <categories>
        <category>The-Operating-System-Notes</category>
      </categories>
      <tags>
        <tag>operating sysytem</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>并发性</title>
    <url>/2021/03/15/%E5%B9%B6%E5%8F%91%E6%80%A7/</url>
    <content><![CDATA[<h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="并发缺陷"><a href="#并发缺陷" class="headerlink" title="并发缺陷"></a>并发缺陷</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>若系统中存在一组进程，其中每个进程都占用了某种资源，又都在等待已被该组进程中的其他进程占用的资源，这种等待永远不能结束，称为死锁。</p>
<p>死锁产生条件</p>
<p>1、<strong>互斥</strong>：线程对于需要的资源进行互斥的访问（例如一个线程抢到锁）。<br>2、<strong>持有并等待</strong>：线程持有了资源（例如已将持有的锁），同时又在等待其他资源（例如，需要获得的锁）。<br>3、 <strong>非抢占</strong>：线程获得的资源（例如锁），不能被抢占。<br>4、<strong>循环等待</strong>：线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的。</p>
<h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><p>是指线程 1 可以使用资源，但它很礼貌，让其他线程先使用资源，线程 2 也可以使用资源，但它很绅士，也让其他线程先使用资源。这样你让我，我让你，最后两个线程都无法使用资源。</p>
<h2 id="第-26-章——并发"><a href="#第-26-章——并发" class="headerlink" title="第 26 章——并发"></a>第 26 章——并发</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h4><p><strong>线程</strong></p>
<p>经典观点是一个程序只有一个执行点（一个程序计数器，用来存放要执行的指令），但多线程（multi-threaded）程序会有多个执行点（多个程序计数器，每个都用于取指令和执行）。换一个角度来看，每个线程类似于独立的进程</p>
<p><strong>区别：</strong></p>
<p>每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，<strong>同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC）</strong>，线程之间切换的开销小。</p>
<ol>
<li>线程之间它们共享地址空间，从而能够访问相同的数据。</li>
<li>线程上下文切换地址空间保持不变（即不需要切换当前使用的页表）。</li>
<li>状态保存到线程控制块（TCB）</li>
<li>在简单的传统进程地址空间模型中，只有一个栈，通常位于地址空间的底部，每个线程都有一个栈</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/09/cVOeF4mlSv5soby.png" alt="image-20211111221705381"></p>
<p><strong>相同点：</strong></p>
<ol>
<li>线程有一个程序计数器（PC），记录程序从哪里获取指令。每个线程有自己的一组用于计算的寄存器。</li>
<li>线程之间的上下文切换类似于进程间的上下文切换。</li>
</ol>
<h4 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h4><p>主程序创建了两个线程，分别执行函数 mythread()，但是传入不同的参数（字符串类型的 A 或者 B）。一旦线程创建，可能会立即运行（取决于调度程序），或者处于就绪状态，等待执行。创建了两个线程（T1 和 T2）后，主程序调用 pthread_join()，等待特定线程完成。</p>
<p>代码实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;assert.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">void *mythread(void *arg)</span><br><span class="line">&#123;</span><br><span class="line"> printf(&quot;%s\n&quot;, (char *) arg); return NULL;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line"></span><br><span class="line">pthread_t p1, p2;</span><br><span class="line">int rc;</span><br><span class="line">printf(&quot;main: begin\n&quot;);</span><br><span class="line">rc = pthread_create(&amp;p1, NULL, mythread, &quot;A&quot;);</span><br><span class="line">assert(rc == 0);</span><br><span class="line">rc = pthread_create(&amp;p2, NULL, mythread, &quot;B&quot;);</span><br><span class="line">assert(rc == 0);</span><br><span class="line">// join waits for the threads to finish</span><br><span class="line">rc = pthread_join(p1, NULL);</span><br><span class="line">assert(rc == 0);</span><br><span class="line">rc = pthread_join(p2, NULL);</span><br><span class="line">assert(rc == 0);</span><br><span class="line">printf(&quot;main: end\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="共享数据带来的麻烦"><a href="#共享数据带来的麻烦" class="headerlink" title="共享数据带来的麻烦"></a>共享数据带来的麻烦</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &quot;mythreads.h&quot;</span><br><span class="line"></span><br><span class="line">static volatile int counter = 0;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">// mythread()</span><br><span class="line">//</span><br><span class="line">// Simply adds 1 to counter repeatedly, in a loop</span><br><span class="line">// No, this is not how you would add 10,000,000 to</span><br><span class="line">// a counter, but it shows the problem nicely.</span><br><span class="line">// void *</span><br><span class="line">mythread(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%s: begin\n&quot;, (char *) arg);</span><br><span class="line">int i;</span><br><span class="line">for (i = 0; i &lt; 1e7; i++)</span><br><span class="line">&#123;</span><br><span class="line"> counter = counter + 1;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%s: done\n&quot;, (char *) arg); return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Just launches two threads (pthread_create)</span><br><span class="line">// and then waits for them (pthread_join)</span><br><span class="line">//</span><br><span class="line">int</span><br><span class="line">main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">pthread_t p1, p2;</span><br><span class="line">printf(&quot;main: begin (counter = %d)\n&quot;, counter); Pthread_create(&amp;p1, NULL, mythread, &quot;A&quot;);</span><br><span class="line">Pthread_create(&amp;p2, NULL, mythread, &quot;B&quot;);</span><br><span class="line"></span><br><span class="line">// join waits for the threads to finish</span><br><span class="line">Pthread_join(p1, NULL);</span><br><span class="line">Pthread_join(p2, NULL);</span><br><span class="line">printf(&quot;main: done with both (counter = %d)\n&quot;, counter); return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>预期的最终结果是：20000000，但是每次运行的结果都不太符合预期且各不相同</p>
<h4 id="核心问题：不可控的调度"><a href="#核心问题：不可控的调度" class="headerlink" title="核心问题：不可控的调度"></a>核心问题：不可控的调度</h4><p>两个线程访问的是共享数据，并试图修改共享数据，也就是进入了临界区。此时如何发生上下文切换，多个线程处于竞争状态，可能会造成不可知的错误。</p>
<p>我们真正想要的代码就是所谓的互斥（mutual exclusion）。这个属性保证了如果一个线程在临界区内执行，其他线程将被阻止进入临界区。</p>
<p><img src="https://s2.loli.net/2022/01/09/Gysa9uLkzYnShJp.png" alt="image-20211111225421897"></p>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p><em>原子操作是构建计算机系统的最强大的基础技术之一，从计算机体系结构到并行代码（我们在这里研究的内容）、文件系统（我们将很快研究）、数据库管理系统，甚至分布式系统[L+93]。将一系列动作原子化（atomic）背后的想法可以简单用一个短语表达：“全部或没有”。看上去，要么你希望组合在一起的所有活动都发生了，要么它们都没有发生。不会看到中间状态。有时，将许多行</em><br><em>为组合为单个原子动作称为事务（transaction），这是一个在数据库和事务处理世界中非常详细地发展的概念</em></p>
<h2 id="第-28-章-锁"><a href="#第-28-章-锁" class="headerlink" title="第 28 章 锁"></a>第 28 章 锁</h2><p>对于<a href="https://so.csdn.net/so/search?q=%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">并发编程</a>的一个最基本的问题：程序员希望原子式执行一系列指令，但由于单处理器上的中断(或多线程在多处理器上并发执行)，这变得不可实现，为了解决这个问题，<strong>在源代码中加锁，放在临界区周围，保证临界区能像单条原子指令一样执行</strong></p>
<h2 id="第-30-章-条件变量"><a href="#第-30-章-条件变量" class="headerlink" title="第 30 章 条件变量"></a>第 30 章 条件变量</h2><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a><strong>知识点</strong></h3><p>。锁并不是并发程序设计所需的唯一原语。在很多情况下，线程需要检查某一条件满足之后，才会继续运行。例如，父线程需要检查子线程是否执行完毕 [这常被称为 join()]。</p>
<p><strong>方案一：原地自旋</strong></p>
<p>效率低下，有些情况设置是错误的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 volatile int done = 0;</span><br><span class="line">2</span><br><span class="line">3 void *child(void *arg) &#123;</span><br><span class="line">4 printf(&quot;child\n&quot;);</span><br><span class="line">5 done = 1;</span><br><span class="line">6 return NULL;</span><br><span class="line">7 &#125;</span><br><span class="line">8</span><br><span class="line">9 int main(int argc, char *argv[]) &#123;</span><br><span class="line">10 printf(&quot;parent: begin\n&quot;);</span><br><span class="line">11 pthread_t c;</span><br><span class="line">12 Pthread_create(&amp;c, NULL, child, NULL); // create child</span><br><span class="line">13 while (done == 0)</span><br><span class="line">14 ; // spin</span><br><span class="line">15 printf(&quot;parent: end\n&quot;);</span><br><span class="line">16 return 0;</span><br><span class="line">17 &#125;</span><br></pre></td></tr></table></figure>

<p><strong>方案二：</strong></p>
<p>可以使用条件变量（condition variable），来等待一个条件变成真。</p>
<p>条件变量有两种相关操作：wait()和 signal()。线程要睡<br>眠的时候，调用 wait()。当线程想唤醒等待在某个条件变量上的睡眠线程时，调用 signal()。具体来说，POSIX 调用如图所示。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pthread_cond_wait(pthread_cond_t *c, pthread_mutex_t *m);</span><br><span class="line">pthread_cond_signal(pthread_cond_t *c);</span><br><span class="line">1 int done = 0;</span><br><span class="line">2 pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">3 pthread_cond_t c = PTHREAD_COND_INITIALIZER;</span><br><span class="line">4</span><br><span class="line">5 void thr_exit() &#123;</span><br><span class="line">6 Pthread_mutex_lock(&amp;m);</span><br><span class="line">7 done = 1;</span><br><span class="line">8 Pthread_cond_signal(&amp;c);</span><br><span class="line">9 Pthread_mutex_unlock(&amp;m);</span><br><span class="line">10 &#125;</span><br><span class="line">11</span><br><span class="line">12 void *child(void *arg) &#123;</span><br><span class="line">13 printf(&quot;child\n&quot;);</span><br><span class="line">14 thr_exit();</span><br><span class="line">15 return NULL;</span><br><span class="line">16 &#125;</span><br><span class="line">30.1 定义和程序 251</span><br><span class="line">17</span><br><span class="line">18 void thr_join() &#123;</span><br><span class="line">19 Pthread_mutex_lock(&amp;m);</span><br><span class="line">20 while (done == 0)</span><br><span class="line">21 Pthread_cond_wait(&amp;c, &amp;m);</span><br><span class="line">22 Pthread_mutex_unlock(&amp;m);</span><br><span class="line">23 &#125;</span><br><span class="line">24</span><br><span class="line">25 int main(int argc, char *argv[]) &#123;</span><br><span class="line">26 printf(&quot;parent: begin\n&quot;);</span><br><span class="line">27 pthread_t p;</span><br><span class="line">28 Pthread_create(&amp;p, NULL, child, NULL);</span><br><span class="line">29 thr_join();</span><br><span class="line">30 printf(&quot;parent: end\n&quot;);</span><br><span class="line">31 return 0;</span><br><span class="line">32 &#125;</span><br></pre></td></tr></table></figure>

<h4 id="生产者-x2F-消费者问题"><a href="#生产者-x2F-消费者问题" class="headerlink" title="生产者&#x2F;消费者问题"></a><strong>生产者&#x2F;消费者问题</strong></h4><p>生产者&#x2F;消费者问题，也叫作有界缓冲区（bounded buffer）问题。假设有一个或多个生产者线程和一个或多个消费者线程。生产者把生成的数据项放入缓冲区；消费者从缓冲区取走数据项，以某种方式消费。</p>
<h5 id="有问题的方案一"><a href="#有问题的方案一" class="headerlink" title="有问题的方案一"></a><strong>有问题的方案一</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 cond_t cond;</span><br><span class="line">2 mutex_t mutex;</span><br><span class="line">3‘</span><br><span class="line">4 void *producer(void *arg) &#123;</span><br><span class="line">5 int i;</span><br><span class="line">6 for (i = 0; i &lt; loops; i++) &#123;</span><br><span class="line">7 Pthread_mutex_lock(&amp;mutex); // p1</span><br><span class="line">8 if (count == 1) // p2</span><br><span class="line">9 Pthread_cond_wait(&amp;cond, &amp;mutex); // p3</span><br><span class="line">10 put(i); // p4</span><br><span class="line">11 Pthread_cond_signal(&amp;cond); // p5</span><br><span class="line">12 Pthread_mutex_unlock(&amp;mutex); // p6</span><br><span class="line">13 &#125;</span><br><span class="line">14 &#125;</span><br><span class="line">15</span><br><span class="line">16 void *consumer(void *arg) &#123;</span><br><span class="line">17 int i;</span><br><span class="line">18 for (i = 0; i &lt; loops; i++) &#123;</span><br><span class="line">19 Pthread_mutex_lock(&amp;mutex); // c1</span><br><span class="line">20 if (count == 0) // c2</span><br><span class="line">21 Pthread_cond_wait(&amp;cond, &amp;mutex); // c3</span><br><span class="line">22 int tmp = get(); // c4</span><br><span class="line">23 Pthread_cond_signal(&amp;cond); // c5</span><br><span class="line">24 Pthread_mutex_unlock(&amp;mutex); // c6</span><br><span class="line">30.2 生产者/消费者（有界缓冲区）问题 255</span><br><span class="line">25 printf(&quot;%d\n&quot;, tmp);</span><br><span class="line">26 &#125;</span><br><span class="line">27</span><br></pre></td></tr></table></figure>

<p>出问题的例子：</p>
<p><img src="https://s2.loli.net/2022/01/09/oGh1SzMmxZ7VpnB.png" alt="image-20211111145947333"></p>
<p><img src="https://s2.loli.net/2022/01/09/iklyu4nr6AgZbQ5.png" alt="image-20211111150007868"></p>
<p>问题产生的原因很简单：在 T c1 被生产者唤醒后，但在它运行之前，缓冲区的状态改变了（由于 T c2 ）。发信号给线程只是唤醒它们，暗示状态发生了变化（在这个例子中，就是值已被放入缓冲区），但并不会保证在它运行之前状态一直是期望的情况。</p>
<h5 id="有问题的方案二"><a href="#有问题的方案二" class="headerlink" title="有问题的方案二"></a><strong>有问题的方案二</strong></h5><p>使用 While 语句替代 If</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 cond_t cond;</span><br><span class="line">2 mutex_t mutex;</span><br><span class="line">3</span><br><span class="line">4 void *producer(void *arg) &#123;</span><br><span class="line">5 int i;</span><br><span class="line">6 for (i = 0; i &lt; loops; i++) &#123;</span><br><span class="line">7 Pthread_mutex_lock(&amp;mutex); // p1</span><br><span class="line">8 while (count == 1) // p2</span><br><span class="line">9 Pthread_cond_wait(&amp;cond, &amp;mutex); // p3</span><br><span class="line">10 put(i); // p4</span><br><span class="line">11 Pthread_cond_signal(&amp;cond); // p5</span><br><span class="line">12 Pthread_mutex_unlock(&amp;mutex); // p6</span><br><span class="line">13 &#125;</span><br><span class="line">14 &#125;</span><br><span class="line">15</span><br><span class="line">16 void *consumer(void *arg) &#123;</span><br><span class="line">17 int i;</span><br><span class="line">18 for (i = 0; i &lt; loops; i++) &#123;</span><br><span class="line">19 Pthread_mutex_lock(&amp;mutex); // c1</span><br><span class="line">20 while (count == 0) // c2</span><br><span class="line">21 Pthread_cond_wait(&amp;cond, &amp;mutex); // c3</span><br><span class="line">22 int tmp = get(); // c4</span><br><span class="line">23 Pthread_cond_signal(&amp;cond); // c5</span><br><span class="line">24 Pthread_mutex_unlock(&amp;mutex); // c6</span><br><span class="line">25 printf(&quot;%d\n&quot;, tmp);</span><br><span class="line">26 &#125;</span><br><span class="line">27 &#125;</span><br></pre></td></tr></table></figure>

<p>我们要记住一条关于条件变量的简单规则：总是使用 while 循环（always use while loop）。虽然有时候不需要重新检查条件，但这样做总是安全的。</p>
<p><strong>存在的问题：</strong></p>
<p>因为消费者已经清空了缓冲区，很显然，应该唤醒生产者。但是，如果它唤醒了 T c2 （这绝对是可能的，取决于等待队列是如何管理的），问题就出现了。具体来说，消费者 T c2 会醒过来，发现队列为空（c2），又继续回去睡眠（c3）。生产者 T p 刚才在缓冲区中放了一个值，现在在睡眠。另一个消费者线程 T c1 也回去睡眠了。3 个线程都在睡眠，显然是一个缺陷。</p>
<p><img src="https://s2.loli.net/2022/01/09/isgFNlt23zynRKq.png" alt="image-20211111150848091"></p>
<p><img src="https://s2.loli.net/2022/01/09/uHFybaIhgnBNDit.png" alt="image-20211111150906666"></p>
<p>信号显然需要，但必须更有指向性。消费者不应该唤醒消费者，而应该只唤醒生产者，反之亦然。</p>
<p><strong>方案三：单值缓冲区的生产者&#x2F;消费者方案</strong></p>
<p>生产者线程等待条件变量 empty，发信号给变量 fill。相应地，消费者线程等待 fill，发信号给 empty。这样做，从设计上避免了上述第二个问题：消费者再也不会唤醒消费者，生产者也不会唤醒生产者。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 cond_t empty, fill;</span><br><span class="line">2 mutex_t mutex;</span><br><span class="line">3</span><br><span class="line">4 void *producer(void *arg) &#123;</span><br><span class="line">5 int i;</span><br><span class="line">6 for (i = 0; i &lt; loops; i++) &#123;</span><br><span class="line">7 Pthread_mutex_lock(&amp;mutex);</span><br><span class="line">8 while (count == 1)</span><br><span class="line">9 Pthread_cond_wait(&amp;empty, &amp;mutex);</span><br><span class="line">10 put(i);</span><br><span class="line">11 Pthread_cond_signal(&amp;fill);</span><br><span class="line">12 Pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">13 &#125;</span><br><span class="line">14 &#125;</span><br><span class="line">15</span><br><span class="line">16 void *consumer(void *arg) &#123;</span><br><span class="line">17 int i;</span><br><span class="line">18 for (i = 0; i &lt; loops; i++) &#123;</span><br><span class="line">19 Pthread_mutex_lock(&amp;mutex);</span><br><span class="line">20 while (count == 0)</span><br><span class="line">21 Pthread_cond_wait(&amp;fill, &amp;mutex);</span><br><span class="line">22 int tmp = get();</span><br><span class="line">23 Pthread_cond_signal(&amp;empty);</span><br><span class="line">24 Pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">25 printf(&quot;%d\n&quot;, tmp);</span><br><span class="line">26 &#125;</span><br><span class="line">27 &#125;</span><br></pre></td></tr></table></figure>

<h5 id="最终方案"><a href="#最终方案" class="headerlink" title="最终方案"></a><strong>最终方案</strong></h5><p><img src="https://s2.loli.net/2022/01/07/GHbpioTwRqa9tOM.png" alt="image-20220107140850903"></p>
<p><img src="https://s2.loli.net/2022/01/07/z9F6rOUKJL8wli1.png" alt="image-20220107140841597"></p>
<p>llll</p>
<h2 id="第-31-章：信号量"><a href="#第-31-章：信号量" class="headerlink" title="第 31 章：信号量"></a>第 31 章：信号量</h2><h3 id="信号量定义"><a href="#信号量定义" class="headerlink" title="信号量定义"></a>信号量定义</h3><p>信号量作为锁和条件变量</p>
<p>是有一个整数值的对象,可以用两个函数来操作它</p>
<p>**sem_wait()**要么立刻返回（调用 sem_wait()时，信号量的值大于等于 1），要么会让调用线程挂起，直到之后的一个 post 操作。当然，也可能多个调用线程都调用 sem_wait()，因此都在队列中等待被唤醒。</p>
<p><strong>sem_post()</strong> sem_post()并没有等待某些条件满足。它直接增加信号量的值，如果有等待线程，唤醒其中一个。当信号量的值为负数时，这个值就是等待线程的个数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *s)</span> &#123;</span><br><span class="line">decrement the value of semaphore s by one</span><br><span class="line">wait <span class="keyword">if</span> value of semaphore s is negative</span><br><span class="line">&#125;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *s)</span> &#123;</span><br><span class="line">increment the value of semaphore s by one</span><br><span class="line"><span class="keyword">if</span> there are one or more threads waiting, wake one</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二值信号量（锁）"><a href="#二值信号量（锁）" class="headerlink" title="二值信号量（锁）"></a>二值信号量（锁）</h3><p>用信号量作为锁。信号量初始值为 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sem_t m;</span><br><span class="line">sem_init(&amp;m, 0, X); // initialize semaphore to X; what should X be?</span><br><span class="line"></span><br><span class="line">sem_wait(&amp;m);</span><br><span class="line">// critical section here</span><br><span class="line">sem_post(&amp;m);</span><br></pre></td></tr></table></figure>

<p>考虑两种场景</p>
<p>1.一个单线程,调用了 sem_wait()，它把信号量的值减为 0。然后，它只会在值小于 0 时等待。因为值是 0，调用线程从函数返回并继续，线程 0 现在可以自由进入临界区。线程 0 在临界区中，如果没有其他线程尝试获取锁，当它调用 sem_post()时，会将信号量重置为 1（因为没有等待线程，不会唤醒其他线程）。</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111171023858.png" alt="image-20211117102303687"></p>
<h3 id="信号量用作条件变量"><a href="#信号量用作条件变量" class="headerlink" title="信号量用作条件变量"></a>信号量用作条件变量</h3><p>信号量初始值应为 0.</p>
<p>有两种情况需要考虑</p>
<p>第一种，父线程创建了子线程，但是子线程并没有运行。这种情况下（见表 31.3），父线程调用 sem_wait()会先于子线程调用 sem_post()。我们希望父线程等待子线程运行。为此，唯一的办法是让信号量的值不大于 0。因此，0 为初值。父线程运行，将信号量减为 −1，然后睡眠等待；子线程运行的时候，调用 sem_post()，信号量增加为 0，唤醒父线程，父线程然后从 sem_wait()返回，完成该程序。</p>
<p>第二种情况是子线程在父线程调用 sem_wait()之前就运行结束（见表 31.4）。在这种情况下，子线程会先调用 sem_post()，将信号量从 0 增加到 1。然后当父线程有机会运行时，会调用 sem_wait()，发现信号量的值为 1。于是父线程将信号量从 1 减为 0，没有等待，直接从<br>sem_wait()返回，也达到了预期效果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">sem_t</span> s;</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="type">void</span> *<span class="title function_">child</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">5</span> <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line"><span class="number">6</span> sem_post(&amp;s); <span class="comment">// signal here: child is done</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">8</span> &#125;</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="type">int</span></span><br><span class="line"><span class="number">11</span> main(<span class="type">int</span> argc, <span class="type">char</span> *argv[]) &#123;</span><br><span class="line"><span class="number">12</span> sem_init(&amp;s, <span class="number">0</span>, X); <span class="comment">// what should X be?</span></span><br><span class="line"><span class="number">13</span> <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line"><span class="number">14</span> <span class="type">pthread_t</span> c;</span><br><span class="line"><span class="number">15</span> Pthread_create(c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">16</span> sem_wait(&amp;s); <span class="comment">// wait here for child</span></span><br><span class="line"><span class="number">17</span> <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line"><span class="number">18</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">19</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="生产者-x2F-消费者问题-1"><a href="#生产者-x2F-消费者问题-1" class="headerlink" title="生产者&#x2F;消费者问题"></a>生产者&#x2F;消费者问题</h3><h4 id="初次尝试"><a href="#初次尝试" class="headerlink" title="初次尝试"></a>初次尝试</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">sem_t</span> empty;  <span class="comment">//生产者的等待条件判断变量,相当于缓冲区的剩余容量,被初始化为MAX</span></span><br><span class="line"><span class="number">2</span> <span class="type">sem_t</span> full;   <span class="comment">//消费者的等待条件判断变量,相当于缓冲区的数据数量,初始值为0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">5</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">7</span> sem_wait(&amp;empty);      <span class="comment">//line P1    //初始为MAX,函数返回,执行放入</span></span><br><span class="line"><span class="number">8</span> put(i);                <span class="comment">// line P2</span></span><br><span class="line"><span class="number">9</span> sem_post(&amp;full);       <span class="comment">// line P3  // full+1</span></span><br><span class="line"><span class="number">10</span> &#125;</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">14</span> <span class="type">int</span> i, tmp = <span class="number">0</span>;</span><br><span class="line"><span class="number">15</span> <span class="keyword">while</span> (tmp != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="number">16</span> sem_wait(&amp;full); <span class="comment">// line C1  //full初始值为0,缓冲区没有数据,wait函数将full-1,进入等待状态</span></span><br><span class="line"><span class="number">17</span> tmp = get(); <span class="comment">// line C2</span></span><br><span class="line"><span class="number">18</span> sem_post(&amp;empty); <span class="comment">// line C3</span></span><br><span class="line"><span class="number">19</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line"><span class="number">20</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">21</span> &#125;</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="number">24</span> <span class="comment">// ...</span></span><br><span class="line"><span class="number">25</span> sem_init(&amp;empty, <span class="number">0</span>, MAX); <span class="comment">// MAX buffers are empty to begin with...</span></span><br><span class="line"><span class="number">26</span> sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// ... and 0 are full</span></span><br><span class="line"><span class="number">27</span> <span class="comment">// ...</span></span><br><span class="line"><span class="number">28</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>存在的问题:竞态条件</strong></p>
<p>我们现在假设 MAX 大于 1（比如 MAX&#x3D;10）。对于这个例子，假定有多个生产者，多<br>个消费者。现在就有问题了：竞态条件。假设两个生产者（Pa 和 Pb）几乎同时调用 put()。当 Pa 先运行，在 f1 行先加入第一条数据（fill&#x3D;0），假设 Pa 在将 fill 计数器更新为 1 之前被中断，Pb 开始运行，也在 f1 行给缓冲区的 0 位置加入一条数据，这意味着那里的老数据被覆盖！</p>
<h4 id="解决竞态-增加互斥"><a href="#解决竞态-增加互斥" class="headerlink" title="解决竞态:增加互斥"></a>解决竞态:增加互斥</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 sem_t empty;</span><br><span class="line">2 sem_t full;</span><br><span class="line">3 sem_t mutex;</span><br><span class="line">4</span><br><span class="line">5 void *producer(void *arg) &#123;</span><br><span class="line">6 int i;</span><br><span class="line">7 for (i = 0; i &lt; loops; i++) &#123;</span><br><span class="line">8 sem_wait(&amp;mutex); // line p0 (NEW LINE)</span><br><span class="line">9 sem_wait(&amp;empty); // line p1</span><br><span class="line">10 put(i); // line p2</span><br><span class="line">11 sem_post(&amp;full); // line p3</span><br><span class="line">12 sem_post(&amp;mutex); // line p4 (NEW LINE)</span><br><span class="line">13 &#125;</span><br><span class="line">14 &#125;</span><br><span class="line">15</span><br><span class="line">16 void *consumer(void *arg) &#123;</span><br><span class="line">17 int i;</span><br><span class="line">18 for (i = 0; i &lt; loops; i++) &#123;</span><br><span class="line">19 sem_wait(&amp;mutex); // line c0 (NEW LINE)</span><br><span class="line">20 sem_wait(&amp;full); // line c1</span><br><span class="line">21 int tmp = get(); // line c2</span><br><span class="line">22 sem_post(&amp;empty); // line c3</span><br><span class="line">23 sem_post(&amp;mutex); // line c4 (NEW LINE)</span><br><span class="line">24 printf(&quot;%d\n&quot;, tmp);</span><br><span class="line">25 &#125;</span><br><span class="line">26 &#125;</span><br><span class="line">27</span><br><span class="line">28 int main(int argc, char *argv[]) &#123;</span><br><span class="line">29 // ...</span><br><span class="line">30 sem_init(&amp;empty, 0, MAX); // MAX buffers are empty to begin with...</span><br><span class="line">31 sem_init(&amp;full, 0, 0); // ... and 0 are full</span><br><span class="line">32 sem_init(&amp;mutex, 0, 1); // mutex=1 because it is a lock (NEW LINE)</span><br><span class="line">33 // ...</span><br><span class="line">34 &#125;</span><br></pre></td></tr></table></figure>

<h4 id="存在的问题-死锁"><a href="#存在的问题-死锁" class="headerlink" title="存在的问题:死锁"></a>存在的问题:死锁</h4><p>假设有两个线程，一个生产者和一个消费者。消费者首先运行，获得锁（c0 行），然后对 full 信号量执行 sem_wait() （c1 行）。因为还没有数据，所以消费者阻塞，让出 CPU。但是，重要的是，此时消费者仍然持有锁。然后生产者运行。假如生产者能够运行，它就能生产数据并唤醒消费者线程。遗憾的是，它首先对二值互斥信号量调用 sem_wait()（p0 行）。锁已经被持有，因此生产者也被卡住。这里出现了一个循环等待。消费者持有互斥量，等待在 full 信号量上。生产者可以发送 full 信号，却在等待互斥量。因此，生产者和消费者互相等待对方——典型的死锁。</p>
<h4 id="解决死锁-减少锁的作用域"><a href="#解决死锁-减少锁的作用域" class="headerlink" title="解决死锁:减少锁的作用域"></a>解决死锁:减少锁的作用域</h4><p><img src="https://s2.loli.net/2022/01/07/nPY936j5tzg8GKk.png" alt="image-20220107141050654"></p>
<h3 id="读者—写者锁"><a href="#读者—写者锁" class="headerlink" title="读者—写者锁"></a>读者—写者锁</h3><p>不同的数据结构访问可能需要不同类型的锁。</p>
<p>如果某个线程要更新数据结构，需要调用 rwlock_acquire_lock()获得写锁，调用 rwlock_release_writelock()释放锁。内部通过一个 writelock 的信号量保证只有一个写者能获得锁进入临界区，从而更新数据结构。</p>
<p>但有一些缺陷，尤其是公平性。读者很容易饿死写者。存在复杂一些的解决方案，也许你可以想到更好的实现？提示：有写者等待时，如何能够避更多的读者进入并持有锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rwlock_t</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">sem_t</span> lock; <span class="comment">// binary semaphore (basic lock)</span></span><br><span class="line"><span class="number">3</span> <span class="type">sem_t</span> writelock; <span class="comment">// used to allow ONE writer or MANY readers</span></span><br><span class="line"><span class="number">4</span> <span class="type">int</span> readers; <span class="comment">// count of readers reading in critical section</span></span><br><span class="line"><span class="number">5</span> &#125; <span class="type">rwlock_t</span>;</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="type">void</span> <span class="title function_">rwlock_init</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line"><span class="number">8</span> rw-&gt;readers = <span class="number">0</span>;</span><br><span class="line"><span class="number">9</span> sem_init(&amp;rw-&gt;lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="number">10</span> sem_init(&amp;rw-&gt;writelock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line"><span class="number">14</span> sem_wait(&amp;rw-&gt;lock);</span><br><span class="line"><span class="number">15</span> rw-&gt;readers++;</span><br><span class="line"><span class="number">16</span> <span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>)</span><br><span class="line"><span class="number">17</span> sem_wait(&amp;rw-&gt;writelock); <span class="comment">// first reader acquires writelock</span></span><br><span class="line"><span class="number">18</span> sem_post(&amp;rw-&gt;lock);</span><br><span class="line"><span class="number">19</span> &#125;</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span> <span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line"><span class="number">22</span> sem_wait(&amp;rw-&gt;lock);</span><br><span class="line"><span class="number">23</span> rw-&gt;readers--;</span><br><span class="line"><span class="number">24</span> <span class="keyword">if</span> (rw-&gt;readers == <span class="number">0</span>)</span><br><span class="line"><span class="number">25</span> sem_post(&amp;rw-&gt;writelock); <span class="comment">// last reader releases writelock</span></span><br><span class="line"><span class="number">26</span> sem_post(&amp;rw-&gt;lock);</span><br><span class="line"><span class="number">27</span> &#125;</span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span> <span class="type">void</span> <span class="title function_">rwlock_acquire_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line"><span class="number">30</span> sem_wait(&amp;rw-&gt;writelock);</span><br><span class="line"><span class="number">31</span> &#125;</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">33</span> <span class="type">void</span> <span class="title function_">rwlock_release_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line"><span class="number">34</span> sem_post(&amp;rw-&gt;writelock);</span><br><span class="line"><span class="number">35</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>假定有 5 位“哲学家”围着一个圆桌。每两位哲学家之间有一把餐叉（一共 5 把）。哲学家有时要思考一会，不需要餐叉；有时又要就餐。而一位哲学家只有同时拿到了左手边和右手边的两把餐叉，才能吃到东西。关于餐叉的竞争以及随之而来的同步问题，就是我们在并发编程中研<br>究它的原因。</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111251057977.png" alt="image-20211117112437466"></p>
<h4 id="有问题的解决方案"><a href="#有问题的解决方案" class="headerlink" title="有问题的解决方案"></a>有问题的解决方案</h4><p>如果哲学家 p 希望用左手边的叉子，他们就调用 left(p)。类似地，右手边的叉子就用<br>right(p)。模运算解决了最后一个哲学家（p &#x3D; 4）右手边叉子的编号问题，就是餐叉 0。</p>
<p>为了拿到餐叉，我们依次获取每把餐叉的锁——先是左手边的，然后是右手边的。结束就餐时，释放掉锁</p>
<p>**问题:死锁 ** 假设每个哲学家都拿到了左手边的餐叉，他们每个都会阻塞住，并且一直等待另一个餐叉。具体来说，哲学家 0 拿到了餐叉 0，哲学家 1 拿到了餐叉 1，哲学家 2 拿到餐叉 2，哲学家 3 拿到餐叉 3，哲学家 4 拿到餐叉 4。所有的餐叉都被占有了，所有的哲学家都阻塞着，并且等待另一个哲学家占有的餐叉</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 void getforks() &#123;</span><br><span class="line">2 sem_wait(forks[left(p)]);</span><br><span class="line">3 sem_wait(forks[right(p)]);</span><br><span class="line">4 &#125;</span><br><span class="line">5</span><br><span class="line">6 void putforks() &#123;</span><br><span class="line">7 sem_post(forks[left(p)]);</span><br><span class="line">8 sem_post(forks[right(p)]);</span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决方案-破除依赖"><a href="#解决方案-破除依赖" class="headerlink" title="解决方案:破除依赖"></a>解决方案:破除依赖</h4><p>改变某位哲学家的用餐顺序,因为最后一个哲学家会尝试先拿右手边的餐叉，然后拿左手边，所以不会出现每个哲学家都拿着一个餐叉，卡住等待另一个的情况，等待循环被打破了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 void getforks() &#123;</span><br><span class="line">2 if (p == 4) &#123;</span><br><span class="line">3 sem_wait(forks[right(p)]);</span><br><span class="line">4 sem_wait(forks[left(p)]);</span><br><span class="line">5 &#125; else &#123;</span><br><span class="line">6 sem_wait(forks[left(p)]);</span><br><span class="line">7 sem_wait(forks[right(p)]);</span><br><span class="line">8 &#125;</span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何实现信号量"><a href="#如何实现信号量" class="headerlink" title="如何实现信号量"></a>如何实现信号量</h3><p>我们用底层的同步原语（锁和条件变量），来实现自己的信号量，名字叫作 Zemaphore。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Zem_t</span></span></span><br><span class="line"><span class="class"> &#123;</span> <span class="type">int</span> value;</span><br><span class="line">  <span class="type">pthread_cond_t</span> cond;</span><br><span class="line">  <span class="type">pthread_mutex_t</span> lock; &#125; Zem_t; <span class="comment">// only one thread can call this</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Zem_init</span><span class="params">(Zem_t *s, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    s-&gt;value = value;</span><br><span class="line">    Cond_init(&amp;s-&gt;cond);</span><br><span class="line">    Mutex_init(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Zem_wait</span><span class="params">(Zem_t *s)</span> &#123;</span><br><span class="line"> Mutex_lock(&amp;s-&gt;lock);                                  <span class="keyword">while</span> (s-&gt;value &lt;= <span class="number">0</span>)                                  Cond_wait(&amp;s-&gt;cond, &amp;s-&gt;lock);</span><br><span class="line"> s-&gt;value--;</span><br><span class="line"> Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Zem_post</span><span class="params">(Zem_t *s)</span></span><br><span class="line">&#123; Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line"> s-&gt;value++;</span><br><span class="line"> Cond_signal(&amp;s-&gt;cond);</span><br><span class="line"> Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>课后习题</strong></p>
<h2 id="第-32-章-常见的并发问题"><a href="#第-32-章-常见的并发问题" class="headerlink" title="第 32 章 常见的并发问题"></a>第 32 章 常见的并发问题</h2><h3 id="非死锁缺陷"><a href="#非死锁缺陷" class="headerlink" title="非死锁缺陷"></a>非死锁缺陷</h3><h2 id="第-31-章：信号量-1"><a href="#第-31-章：信号量-1" class="headerlink" title="第 31 章：信号量"></a>第 31 章：信号量</h2><h3 id="信号量定义-1"><a href="#信号量定义-1" class="headerlink" title="信号量定义"></a>信号量定义</h3><p>信号量作为锁和条件变量</p>
<p>是有一个整数值的对象,可以用两个函数来操作它</p>
<p>**sem_wait()**要么立刻返回（调用 sem_wait()时，信号量的值大于等于 1），要么会让调用线程挂起，直到之后的一个 post 操作。当然，也可能多个调用线程都调用 sem_wait()，因此都在队列中等待被唤醒。</p>
<p><strong>sem_post()</strong> sem_post()并没有等待某些条件满足。它直接增加信号量的值，如果有等待线程，唤醒其中一个。当信号量的值为负数时，这个值就是等待线程的个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 int sem_wait(sem_t *s) &#123;</span><br><span class="line">2 decrement the value of semaphore s by one</span><br><span class="line">3 wait if value of semaphore s is negative</span><br><span class="line">4 &#125; int sem_post(sem_t *s) &#123;</span><br><span class="line">7 increment the value of semaphore s by one</span><br><span class="line">8 if there are one or more threads waiting, wake one</span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="二值信号量（锁）-1"><a href="#二值信号量（锁）-1" class="headerlink" title="二值信号量（锁）"></a>二值信号量（锁）</h3><p>用信号量作为锁。信号量初始值为 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sem_t m;</span><br><span class="line">sem_init(&amp;m, 0, X); // initialize semaphore to X; what should X be?</span><br><span class="line"></span><br><span class="line">sem_wait(&amp;m);</span><br><span class="line">// critical section here</span><br><span class="line">sem_post(&amp;m);</span><br></pre></td></tr></table></figure>

<p>考虑两种场景</p>
<p>1.一个单线程,调用了 sem_wait()，它把信号量的值减为 0。然后，它只会在值小于 0 时等待。因为值是 0，调用线程从函数返回并继续，线程 0 现在可以自由进入临界区。线程 0 在临界区中，如果没有其他线程尝试获取锁，当它调用 sem_post()时，会将信号量重置为 1（因为没有等待线程，不会唤醒其他线程）。</p>
<p><img src="https://s2.loli.net/2022/01/09/jbrgBnfmG9HLztK.png" alt="image-20211117102303687"></p>
<h3 id="信号量用作条件变量-1"><a href="#信号量用作条件变量-1" class="headerlink" title="信号量用作条件变量"></a>信号量用作条件变量</h3><p>信号量初始值应为 1.</p>
<p>有两种情况需要考虑</p>
<p>第一种，父线程创建了子线程，但是子线程并没有运行。这种情况下（见表 31.3），父线程调用 sem_wait()会先于子线程调用 sem_post()。我们希望父线程等待子线程运行。为此，唯一的办法是让信号量的值不大于 0。因此，0 为初值。父线程运行，将信号量减为 −1，然后睡眠等待；子线程运行的时候，调用 sem_post()，信号量增加为 0，唤醒父线程，父线程然后从 sem_wait()返回，完成该程序。</p>
<p>第二种情况是子线程在父线程调用 sem_wait()之前就运行结束（见表 31.4）。在这种情况下，<br>子线程会先调用 sem_post()，将信号量从 0 增加到 1。然后当父线程有机会运行时，会调用<br>sem_wait()，发现信号量的值为 1。于是父线程将信号量从 1 减为 0，没有等待，直接从<br>sem_wait()返回，也达到了预期效果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">sem_t</span> s;</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="type">void</span> *<span class="title function_">child</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">5</span> <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line"><span class="number">6</span> sem_post(&amp;s); <span class="comment">// signal here: child is done</span></span><br><span class="line"><span class="number">7</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="number">8</span> &#125;</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">10</span> <span class="type">int</span></span><br><span class="line"><span class="number">11</span> main(<span class="type">int</span> argc, <span class="type">char</span> *argv[]) &#123;</span><br><span class="line"><span class="number">12</span> sem_init(&amp;s, <span class="number">0</span>, X); <span class="comment">// what should X be?</span></span><br><span class="line"><span class="number">13</span> <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line"><span class="number">14</span> <span class="type">pthread_t</span> c;</span><br><span class="line"><span class="number">15</span> Pthread_create(c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">16</span> sem_wait(&amp;s); <span class="comment">// wait here for child</span></span><br><span class="line"><span class="number">17</span> <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line"><span class="number">18</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">19</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="生产者-x2F-消费者（有界缓冲区）问题"><a href="#生产者-x2F-消费者（有界缓冲区）问题" class="headerlink" title="生产者&#x2F;消费者（有界缓冲区）问题"></a>生产者&#x2F;消费者（有界缓冲区）问题</h3><h4 id="初次尝试-1"><a href="#初次尝试-1" class="headerlink" title="初次尝试"></a>初次尝试</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">sem_t</span> empty;  <span class="comment">//生产者的条件判断变量,相当于缓冲区的剩余容量,被初始化为MAX</span></span><br><span class="line"><span class="number">2</span> <span class="type">sem_t</span> full;   <span class="comment">//消费者的条件判断变量,相当于缓冲区的数据数量,初始值为0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">5</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">6</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">7</span> sem_wait(&amp;empty);      <span class="comment">//line P1    //初始为MAX,函数返回,执行放入</span></span><br><span class="line"><span class="number">8</span> put(i);                <span class="comment">// line P2</span></span><br><span class="line"><span class="number">9</span> sem_post(&amp;full);       <span class="comment">// line P3  // full+1</span></span><br><span class="line"><span class="number">10</span> &#125;</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">14</span> <span class="type">int</span> i, tmp = <span class="number">0</span>;</span><br><span class="line"><span class="number">15</span> <span class="keyword">while</span> (tmp != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="number">16</span> sem_wait(&amp;full); <span class="comment">// line C1  //full初始值为0,缓冲区没有数据,wait函数将full-1,进入等待状态</span></span><br><span class="line"><span class="number">17</span> tmp = get(); <span class="comment">// line C2</span></span><br><span class="line"><span class="number">18</span> sem_post(&amp;empty); <span class="comment">// line C3</span></span><br><span class="line"><span class="number">19</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line"><span class="number">20</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">21</span> &#125;</span><br><span class="line"><span class="number">22</span></span><br><span class="line"><span class="number">23</span> <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="number">24</span> <span class="comment">// ...</span></span><br><span class="line"><span class="number">25</span> sem_init(&amp;empty, <span class="number">0</span>, MAX); <span class="comment">// MAX buffers are empty to begin with...</span></span><br><span class="line"><span class="number">26</span> sem_init(&amp;full, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// ... and 0 are full</span></span><br><span class="line"><span class="number">27</span> <span class="comment">// ...</span></span><br><span class="line"><span class="number">28</span> &#125;</span><br></pre></td></tr></table></figure>

<p><strong>存在的问题:竞态条件</strong></p>
<p>我们现在假设 MAX 大于 1（比如 MAX&#x3D;10）。对于这个例子，假定有多个生产者，多<br>个消费者。现在就有问题了：竞态条件。假设两个生产者（Pa 和 Pb）几乎同时调用 put()。当 Pa 先运行，在 f1 行先加入第一条数据（fill&#x3D;0），假设 Pa 在将 fill 计数器更新为 1 之前被中断，Pb 开始运行，也在 f1 行给缓冲区的 0 位置加入一条数据，这意味着那里的老数据被覆盖！</p>
<h4 id="解决竞态-增加互斥-1"><a href="#解决竞态-增加互斥-1" class="headerlink" title="解决竞态:增加互斥"></a>解决竞态:增加互斥</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 sem_t empty;</span><br><span class="line">2 sem_t full;</span><br><span class="line">3 sem_t mutex;</span><br><span class="line">4</span><br><span class="line">5 void *producer(void *arg) &#123;</span><br><span class="line">6 int i;</span><br><span class="line">7 for (i = 0; i &lt; loops; i++) &#123;</span><br><span class="line">8 sem_wait(&amp;mutex); // line p0 (NEW LINE)</span><br><span class="line">9 sem_wait(&amp;empty); // line p1</span><br><span class="line">10 put(i); // line p2</span><br><span class="line">11 sem_post(&amp;full); // line p3</span><br><span class="line">12 sem_post(&amp;mutex); // line p4 (NEW LINE)</span><br><span class="line">13 &#125;</span><br><span class="line">14 &#125;</span><br><span class="line">15</span><br><span class="line">16 void *consumer(void *arg) &#123;</span><br><span class="line">17 int i;</span><br><span class="line">18 for (i = 0; i &lt; loops; i++) &#123;</span><br><span class="line">19 sem_wait(&amp;mutex); // line c0 (NEW LINE)</span><br><span class="line">20 sem_wait(&amp;full); // line c1</span><br><span class="line">21 int tmp = get(); // line c2</span><br><span class="line">22 sem_post(&amp;empty); // line c3</span><br><span class="line">23 sem_post(&amp;mutex); // line c4 (NEW LINE)</span><br><span class="line">24 printf(&quot;%d\n&quot;, tmp);</span><br><span class="line">25 &#125;</span><br><span class="line">26 &#125;</span><br><span class="line">27</span><br><span class="line">28 int main(int argc, char *argv[]) &#123;</span><br><span class="line">29 // ...</span><br><span class="line">30 sem_init(&amp;empty, 0, MAX); // MAX buffers are empty to begin with...</span><br><span class="line">31 sem_init(&amp;full, 0, 0); // ... and 0 are full</span><br><span class="line">32 sem_init(&amp;mutex, 0, 1); // mutex=1 because it is a lock (NEW LINE)</span><br><span class="line">33 // ...</span><br><span class="line">34 &#125;</span><br></pre></td></tr></table></figure>

<h5 id="存在的问题-死锁-1"><a href="#存在的问题-死锁-1" class="headerlink" title="存在的问题:死锁"></a>存在的问题:死锁</h5><p>假设有两个线程，一个生产者和一个消费者。消费者首先运行，获得锁（c0 行），然后对 full 信号量执行 sem_wait() （c1 行）。因为还没有数据，所以消费者阻塞，让出 CPU。但是，重要的是，此时消费者仍然持有锁。然后生产者运行。假如生产者能够运行，它就能生产数据并唤醒消费者线程。遗憾的是，它首先对二值互斥信号量调用 sem_wait()（p0 行）。锁已经被持有，因此生产者也被卡住。这里出现了一个循环等待。消费者持有互斥量，等待在 full 信号量上。生产者可以发送 full 信号，却在等待互斥量。因此，生产者和消费者互相等待对方——典型的死锁。</p>
<h4 id="解决死锁-减少锁的作用域-1"><a href="#解决死锁-减少锁的作用域-1" class="headerlink" title="解决死锁:减少锁的作用域"></a>解决死锁:减少锁的作用域</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">6</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">7</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">8</span> sem_wait(&amp;empty); <span class="comment">// line p1</span></span><br><span class="line"><span class="number">9</span> sem_wait(&amp;mutex); <span class="comment">// line p1.5 (MOVED MUTEX HERE...)</span></span><br><span class="line"><span class="number">10</span> put(i); <span class="comment">// line p2</span></span><br><span class="line"><span class="number">11</span> sem_post(&amp;mutex); <span class="comment">// line p2.5 (... AND HERE)</span></span><br><span class="line"><span class="number">12</span> sem_post(&amp;full); <span class="comment">// line p3</span></span><br><span class="line"><span class="number">13</span> &#125;</span><br><span class="line"><span class="number">14</span> &#125;</span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">16</span> <span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"><span class="number">17</span> <span class="type">int</span> i;</span><br><span class="line"><span class="number">18</span> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line"><span class="number">19</span> sem_wait(&amp;full); <span class="comment">// line c1</span></span><br><span class="line"><span class="number">20</span> sem_wait(&amp;mutex); <span class="comment">// line c1.5 (MOVED MUTEX HERE...)</span></span><br><span class="line"><span class="number">21</span> <span class="type">int</span> tmp = get(); <span class="comment">// line c2</span></span><br><span class="line"><span class="number">22</span> sem_post(&amp;mutex); <span class="comment">// line c2.5 (... AND HERE)</span></span><br><span class="line"><span class="number">23</span> sem_post(&amp;empty); <span class="comment">// line c3</span></span><br><span class="line"><span class="number">24</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp);</span><br><span class="line"><span class="number">25</span> &#125;</span><br><span class="line"><span class="number">26</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="读者—写者锁-1"><a href="#读者—写者锁-1" class="headerlink" title="读者—写者锁"></a>读者—写者锁</h3><p>不同的数据结构访问可能需要不同类型的锁。</p>
<p>如果某个线程要更新数据结构，需要调用 rwlock_acquire_lock()获得写锁，调用 rwlock_release_writelock()释放锁。内部通过一个 writelock 的信号量保证只有一个写者能获得锁进入临界区，从而更新数据结构。</p>
<p>但有一些缺陷，尤其是公平性。读者很容易饿死写者。存在复杂一些的解决方案，也许你可以想到更好的实现？提示：有写者等待时，如何能够避更多的读者进入并持有锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rwlock_t</span> &#123;</span></span><br><span class="line"><span class="number">2</span> <span class="type">sem_t</span> lock; <span class="comment">// binary semaphore (basic lock)</span></span><br><span class="line"><span class="number">3</span> <span class="type">sem_t</span> writelock; <span class="comment">// used to allow ONE writer or MANY readers</span></span><br><span class="line"><span class="number">4</span> <span class="type">int</span> readers; <span class="comment">// count of readers reading in critical section</span></span><br><span class="line"><span class="number">5</span> &#125; <span class="type">rwlock_t</span>;</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span> <span class="type">void</span> <span class="title function_">rwlock_init</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line"><span class="number">8</span> rw-&gt;readers = <span class="number">0</span>;</span><br><span class="line"><span class="number">9</span> sem_init(&amp;rw-&gt;lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="number">10</span> sem_init(&amp;rw-&gt;writelock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="number">11</span> &#125;</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">13</span> <span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line"><span class="number">14</span> sem_wait(&amp;rw-&gt;lock);</span><br><span class="line"><span class="number">15</span> rw-&gt;readers++;</span><br><span class="line"><span class="number">16</span> <span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>)</span><br><span class="line"><span class="number">17</span> sem_wait(&amp;rw-&gt;writelock); <span class="comment">// first reader acquires writelock</span></span><br><span class="line"><span class="number">18</span> sem_post(&amp;rw-&gt;lock);</span><br><span class="line"><span class="number">19</span> &#125;</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">21</span> <span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line"><span class="number">22</span> sem_wait(&amp;rw-&gt;lock);</span><br><span class="line"><span class="number">23</span> rw-&gt;readers--;</span><br><span class="line"><span class="number">24</span> <span class="keyword">if</span> (rw-&gt;readers == <span class="number">0</span>)</span><br><span class="line"><span class="number">25</span> sem_post(&amp;rw-&gt;writelock); <span class="comment">// last reader releases writelock</span></span><br><span class="line"><span class="number">26</span> sem_post(&amp;rw-&gt;lock);</span><br><span class="line"><span class="number">27</span> &#125;</span><br><span class="line"><span class="number">28</span></span><br><span class="line"><span class="number">29</span> <span class="type">void</span> <span class="title function_">rwlock_acquire_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line"><span class="number">30</span> sem_wait(&amp;rw-&gt;writelock);</span><br><span class="line"><span class="number">31</span> &#125;</span><br><span class="line"><span class="number">32</span></span><br><span class="line"><span class="number">33</span> <span class="type">void</span> <span class="title function_">rwlock_release_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line"><span class="number">34</span> sem_post(&amp;rw-&gt;writelock);</span><br><span class="line"><span class="number">35</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="哲学家就餐问题-1"><a href="#哲学家就餐问题-1" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>假定有 5 位“哲学家”围着一个圆桌。每两位哲学家之间有一把餐叉（一共 5 把）。哲学家有时要思考一会，不需要餐叉；有时又要就餐。而一位哲学家只有同时拿到了左手边和右手边的两把餐叉，才能吃到东西。关于餐叉的竞争以及随之而来的同步问题，就是我们在并发编程中研<br>究它的原因。</p>
<p><img src="https://s2.loli.net/2022/01/09/VWqDckdmHh279oz.png" alt="image-20211117112437466"></p>
<h4 id="有问题的解决方案-1"><a href="#有问题的解决方案-1" class="headerlink" title="有问题的解决方案"></a>有问题的解决方案</h4><p>如果哲学家 p 希望用左手边的叉子，他们就调用 left(p)。类似地，右手边的叉子就用<br>right(p)。模运算解决了最后一个哲学家（p &#x3D; 4）右手边叉子的编号问题，就是餐叉 0。</p>
<p>为了拿到餐叉，我们依次获取每把餐叉的锁——先是左手边的，然后是右手边的。结束就餐时，释放掉锁</p>
<p>**问题:死锁 ** 假设每个哲学家都拿到了左手边的餐叉，他们每个都会阻塞住，并且一直等待另一个餐叉。具体来说，哲学家 0 拿到了餐叉 0，哲学家 1 拿到了餐叉 1，哲学家 2 拿到餐叉 2，哲学家 3 拿到餐叉 3，哲学家 4 拿到餐叉 4。所有的餐叉都被占有了，所有的哲学家都阻塞着，并且等待另一个哲学家占有的餐叉</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 void getforks() &#123;</span><br><span class="line">2 sem_wait(forks[left(p)]);</span><br><span class="line">3 sem_wait(forks[right(p)]);</span><br><span class="line">4 &#125;</span><br><span class="line">5</span><br><span class="line">6 void putforks() &#123;</span><br><span class="line">7 sem_post(forks[left(p)]);</span><br><span class="line">8 sem_post(forks[right(p)]);</span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决方案-破除依赖-1"><a href="#解决方案-破除依赖-1" class="headerlink" title="解决方案:破除依赖"></a>解决方案:破除依赖</h4><p>改变某位哲学家的用餐顺序,因为最后一个哲学家会尝试先拿右手边的餐叉，然后拿左手边，所以不会出现每个哲学家都拿着一个餐叉，卡住等待另一个的情况，等待循环被打破了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 void getforks() &#123;</span><br><span class="line">2 if (p == 4) &#123;</span><br><span class="line">3 sem_wait(forks[right(p)]);</span><br><span class="line">4 sem_wait(forks[left(p)]);</span><br><span class="line">5 &#125; else &#123;</span><br><span class="line">6 sem_wait(forks[left(p)]);</span><br><span class="line">7 sem_wait(forks[right(p)]);</span><br><span class="line">8 &#125;</span><br><span class="line">9 &#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何实现信号量-1"><a href="#如何实现信号量-1" class="headerlink" title="如何实现信号量"></a>如何实现信号量</h3><p>我们用底层的同步原语（锁和条件变量），来实现自己的信号量，名字叫作 Zemaphore。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Zem_t</span> &#123;</span></span><br><span class="line"> <span class="type">int</span> value;</span><br><span class="line"> <span class="type">pthread_cond_t</span> cond;</span><br><span class="line"> <span class="type">pthread_mutex_t</span> lock;</span><br><span class="line"> &#125; Zem_t;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// only one thread can call this</span></span><br><span class="line"> <span class="type">void</span> <span class="title function_">Zem_init</span><span class="params">(Zem_t *s, <span class="type">int</span> value)</span> &#123;</span><br><span class="line"> s-&gt;value = value;</span><br><span class="line"> Cond_init(&amp;s-&gt;cond);</span><br><span class="line"> Mutex_init(&amp;s-&gt;lock);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> <span class="title function_">Zem_wait</span><span class="params">(Zem_t *s)</span> &#123;</span><br><span class="line"> Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line"> <span class="keyword">while</span> (s-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line"> Cond_wait(&amp;s-&gt;cond, &amp;s-&gt;lock);</span><br><span class="line"> s-&gt;value--;</span><br><span class="line"> Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="type">void</span> <span class="title function_">Zem_post</span><span class="params">(Zem_t *s)</span> &#123;</span><br><span class="line"></span><br><span class="line"> Mutex_lock(&amp;s-&gt;lock);</span><br><span class="line"> s-&gt;value++;</span><br><span class="line"> Cond_signal(&amp;s-&gt;cond);</span><br><span class="line"> Mutex_unlock(&amp;s-&gt;lock);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>The-Operating-System-Notes</category>
      </categories>
      <tags>
        <tag>operating sysytem</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>3.operating-systems-three-easy-pieces answers</title>
    <url>/2021/05/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC4%E6%AC%A1%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<h1 id="操作系统第-4-次作业"><a href="#操作系统第-4-次作业" class="headerlink" title="操作系统第 4 次作业"></a>操作系统第 4 次作业</h1><p>201908010224 黄雅妮</p>
<h2 id="第-37-章——磁盘驱动器"><a href="#第-37-章——磁盘驱动器" class="headerlink" title="第 37 章——磁盘驱动器"></a>第 37 章——磁盘驱动器</h2><h3 id="37-1"><a href="#37-1" class="headerlink" title="37.1"></a>37.1</h3><p><strong>计算以下几组请求的寻道、旋转和传输时间：-a 0，-a 6，-a 30，-a 7，30，8，最后 -a 10，11，12，13。</strong></p>
<p>运行以下命令行</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">python2 disk.py  -a 0 -G</span><br><span class="line">python2 disk.py  -a 6 -G</span><br><span class="line">python2 disk.py  -a 30 -G</span><br><span class="line">python2 disk.py  -a 7,30,8 -G</span><br><span class="line">python2 disk.py  -a 10,11,12,13 -G</span><br></pre></td></tr></table></figure>

<p><strong>对于 -a 0,</strong></p>
<p>Rotate &#x3D; 165</p>
<p>Transfer &#x3D; 30</p>
<p>seek &#x3D; 0</p>
<p>total &#x3D; 165 + 30 + 0 &#x3D;195</p>
<p><strong>对于 -a 6,</strong></p>
<p>Rotate &#x3D; 345</p>
<p>Transfer &#x3D; 30</p>
<p>seek &#x3D; 0</p>
<p>total &#x3D; 345 + 30 + 0 &#x3D;375</p>
<p><strong>对于 -a 30,</strong></p>
<p>Rotate &#x3D; 265</p>
<p>Transfer &#x3D; 30</p>
<p>seek &#x3D; 80</p>
<p>total &#x3D;375</p>
<p><strong>对于 -a 7,30,8,</strong></p>
<p>Rotate &#x3D; 545</p>
<p>Transfer &#x3D; 90</p>
<p>seek &#x3D; 160</p>
<p>total &#x3D; 795</p>
<p><strong>对于 -a 10，11，12，13</strong></p>
<p>Rotate &#x3D; 425</p>
<p>Transfer &#x3D;120</p>
<p>seek &#x3D;40</p>
<p>total &#x3D; 585</p>
<h3 id="37-2"><a href="#37-2" class="headerlink" title="37.2"></a>37.2</h3><p><strong>执行上述相同请求，但将寻道速率更改为不同值：-S 2，-S 4，-S 8，-S 10，-S 40，-S 0.1。时间如何变化？</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>-a 0</th>
<th>-a 30</th>
<th>-a 7,30,8</th>
<th>-a 10,11,12,13</th>
</tr>
</thead>
<tbody><tr>
<td>- S 2</td>
<td>195</td>
<td>375</td>
<td>795</td>
<td>585</td>
</tr>
<tr>
<td>-S 4</td>
<td>195</td>
<td>375</td>
<td>435</td>
<td>585</td>
</tr>
<tr>
<td>-S 8</td>
<td>195</td>
<td>375</td>
<td>435</td>
<td>585</td>
</tr>
<tr>
<td>-S 10</td>
<td>195</td>
<td>375</td>
<td>435</td>
<td>585</td>
</tr>
<tr>
<td>-S 40</td>
<td>195</td>
<td>375</td>
<td>435</td>
<td>585</td>
</tr>
<tr>
<td>-S 0.1</td>
<td>195</td>
<td>1095</td>
<td>2235</td>
<td>945</td>
</tr>
</tbody></table>
<h3 id="37-3"><a href="#37-3" class="headerlink" title="37.3"></a>37.3</h3><table>
<thead>
<tr>
<th></th>
<th>-a 0</th>
<th>-a 30</th>
<th>-a 7,30,8</th>
<th>-a 10,11,12,13</th>
</tr>
</thead>
<tbody><tr>
<td>- R 0.1</td>
<td>1950</td>
<td>3750</td>
<td>4349</td>
<td>5850</td>
</tr>
<tr>
<td>- R 0.5</td>
<td>390</td>
<td>750</td>
<td>1590</td>
<td>1170</td>
</tr>
<tr>
<td>- R 0.01</td>
<td>19500</td>
<td>37501</td>
<td>43500</td>
<td>58501</td>
</tr>
</tbody></table>
<h3 id="37-4"><a href="#37-4" class="headerlink" title="37.4"></a>37.4</h3><p>你可能已经注意到，对于一些请求流，一些策略比 FIFO 更好。例如，对于请求流-a 7，30，8，处理请求的顺序是什么？现在在相同的工作负载上运行最短寻道时间优先（SSTF）调度程序（-p SSTF）。每个请求服务需要多长时间（寻道、旋转、传输）？</p>
<p>FIFO:7,30,8</p>
<p>SSTF:7,8,30</p>
<table>
<thead>
<tr>
<th></th>
<th>seek</th>
<th>rotate</th>
<th>transfer</th>
</tr>
</thead>
<tbody><tr>
<td>FIFO</td>
<td>160</td>
<td>545</td>
<td>90</td>
</tr>
<tr>
<td>SSTF</td>
<td>80</td>
<td>205</td>
<td>90</td>
</tr>
</tbody></table>
<h3 id="37-5"><a href="#37-5" class="headerlink" title="37.5"></a><strong>37.5</strong></h3><p><strong>现在做同样的事情，但使用最短的访问时间优先（SATF）调度程序（-p SATF）。它是否对-a 7，30，8 指定的一组请求有所不同？找到 SATF 明显优于 SSTF 的一组请求。出现显著差异的条件是什么？</strong></p>
<p>使用 SATF，磁盘的访问顺序依然是 7 ， 8, 30。寻道，旋转，传输都是一样的</p>
<p>-a 12,31 -c -S 40 -R 3 -p SSTF</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Block:  12  Seek:  1  Rotate: 54  Transfer: 10  Total:  65</span><br><span class="line">Block:  31  Seek:  1  Rotate: 59  Transfer: 10  Total:  70</span><br><span class="line"></span><br><span class="line">TOTALS      Seek:  2  Rotate:113  Transfer: 20  Total: 135</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>-a 12,31 -c -S 40 -R 3 -p SATF</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Block:  31  Seek:  2  Rotate:  3  Transfer: 10  Total:  15</span><br><span class="line">Block:  12  Seek:  1  Rotate: 39  Transfer: 10  Total:  50</span><br><span class="line"></span><br><span class="line">TOTALS      Seek:  3  Rotate: 42  Transfer: 20  Total:  65</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行以上两组参数。显然 SATF 优于 SSTF.</p>
<p>只要是，寻道时间远远小于旋转时间的情况，SATF 性能就会显著优于 SSTF。</p>
<h3 id="37-6"><a href="#37-6" class="headerlink" title="37.6"></a>37.6</h3><p><strong>你可能已经注意到，该磁盘没有特别好地处理请求流-a 10，11，12，13。这是为什么？你可以引入一个磁道偏斜来解决这个问题（-o skew，其中 skew 是一个非负整数）？考虑到默认寻道速率，偏斜应该是多少，才能尽量减少这一组请求的总时间？对于不同的寻道速率（例如，-S 2，-S 4）呢？一般来说，考虑到寻道速率和扇区布局信息，你能否写出一个公式来计算偏斜？</strong></p>
<p>寻道时间太长，导致更换磁道时，刚好旋转超过了 12，导致需要重新旋转一个周期</p>
<p><img src="https://s2.loli.net/2022/01/03/p3BAPZMqlvUgNVH.png" alt="image-20220103194714898"></p>
<p><img src="https://s2.loli.net/2022/01/03/eVHXtKjTdF2GcIm.png" alt="image-20220103194623054"></p>
<p>跨越相邻磁道的寻道时间约接近（小于）旋转过一个扇区的旋转时间，效果越好。</p>
<p>如果寻道速度为 V，寻道距离为 D，旋转角速度为 W，每扇区区域跨越的角度为 A，偏斜为 O，<strong>那么:<code>D / V &lt; A*O / W</code> ，所以偏斜量<code>O &gt; DW / VA</code>，并取满足该条件下的最小的整数。</strong></p>
<h2 id="第-38-章——RAID"><a href="#第-38-章——RAID" class="headerlink" title="第 38 章——RAID"></a>第 38 章——RAID</h2><h3 id="38-1"><a href="#38-1" class="headerlink" title="38.1"></a>38.1</h3><p><strong>使用模拟器执行一些基本的 RAID 映射测试。运行不同的级别（0、1、4、5），看看你是否可以找出一组请求的映射。对于 RAID-5，看看你是否可以找出左对称（left-symmetric）和左不对称（left-asymmetric）布局之间的区别。使用一些不同的随机种子，产生不同于上面的问题。</strong></p>
<p>运行以下命令行</p>
<p>❯ python2 raid.py -n 10 -L 5 -5 LS -c -W seq</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOGICAL READ from addr:0 size:4096</span><br><span class="line">  read  [disk 0, offset 0]</span><br><span class="line">LOGICAL READ from addr:1 size:4096</span><br><span class="line">  read  [disk 1, offset 0]</span><br><span class="line">LOGICAL READ from addr:2 size:4096</span><br><span class="line">  read  [disk 2, offset 0]</span><br><span class="line">LOGICAL READ from addr:3 size:4096</span><br><span class="line">  read  [disk 3, offset 1]</span><br><span class="line">LOGICAL READ from addr:4 size:4096</span><br><span class="line">  read  [disk 0, offset 1]</span><br><span class="line">LOGICAL READ from addr:5 size:4096</span><br><span class="line">  read  [disk 1, offset 1]</span><br><span class="line">LOGICAL READ from addr:6 size:4096</span><br><span class="line">  read  [disk 2, offset 2]</span><br><span class="line">LOGICAL READ from addr:7 size:4096</span><br><span class="line">  read  [disk 3, offset 2]</span><br><span class="line">LOGICAL READ from addr:8 size:4096</span><br><span class="line">  read  [disk 0, offset 2]</span><br><span class="line">LOGICAL READ from addr:9 size:4096</span><br><span class="line">  read  [disk 1, offset 3]</span><br></pre></td></tr></table></figure>

<p>❯ python2 raid.py -n 10 -L 5 -5 LA -c -W seq</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOGICAL READ from addr:0 size:4096</span><br><span class="line">  read  [disk 0, offset 0]</span><br><span class="line">LOGICAL READ from addr:1 size:4096</span><br><span class="line">  read  [disk 1, offset 0]</span><br><span class="line">LOGICAL READ from addr:2 size:4096</span><br><span class="line">  read  [disk 2, offset 0]</span><br><span class="line">LOGICAL READ from addr:3 size:4096</span><br><span class="line">  read  [disk 0, offset 1]</span><br><span class="line">LOGICAL READ from addr:4 size:4096</span><br><span class="line">  read  [disk 1, offset 1]</span><br><span class="line">LOGICAL READ from addr:5 size:4096</span><br><span class="line">  read  [disk 3, offset 1]</span><br><span class="line">LOGICAL READ from addr:6 size:4096</span><br><span class="line">  read  [disk 0, offset 2]</span><br><span class="line">LOGICAL READ from addr:7 size:4096</span><br><span class="line">  read  [disk 2, offset 2]</span><br><span class="line">LOGICAL READ from addr:8 size:4096</span><br><span class="line">  read  [disk 3, offset 2]</span><br><span class="line">LOGICAL READ from addr:9 size:4096</span><br><span class="line">  read  [disk 1, offset 3]</span><br><span class="line">&lt;/pre&gt;</span><br></pre></td></tr></table></figure>

<p>从上面读取的磁盘与偏移可以推测 left- symmetric）和 left-asymmetric 的物理磁盘布局：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">left-symmetric      left-asymmetric</span><br><span class="line">0  1  2  P          0  1  2  P</span><br><span class="line">4  5  P  3          3  4  P  5</span><br><span class="line">8  P  6  7          6  P  7  8</span><br></pre></td></tr></table></figure>

<h3 id="38-2"><a href="#38-2" class="headerlink" title="38.2"></a>38.2</h3><p><strong>与第一个问题一样，但这次使用 -C 来改变块的大小。大块的大小如何改变映射？</strong></p>
<p>❯ python2 raid.py -n 20 -L 5 -5 LS -c -W seq -C 8K</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOGICAL READ from addr:0 size:4096</span><br><span class="line">  read  [disk 0, offset 0]</span><br><span class="line">LOGICAL READ from addr:1 size:4096</span><br><span class="line">  read  [disk 0, offset 1]</span><br><span class="line">LOGICAL READ from addr:2 size:4096</span><br><span class="line">  read  [disk 1, offset 0]</span><br><span class="line">LOGICAL READ from addr:3 size:4096</span><br><span class="line">  read  [disk 1, offset 1]</span><br><span class="line">LOGICAL READ from addr:4 size:4096</span><br><span class="line">  read  [disk 2, offset 0]</span><br><span class="line">LOGICAL READ from addr:5 size:4096</span><br><span class="line">  read  [disk 2, offset 1]</span><br><span class="line">LOGICAL READ from addr:6 size:4096</span><br><span class="line">  read  [disk 3, offset 2]</span><br><span class="line">LOGICAL READ from addr:7 size:4096</span><br><span class="line">  read  [disk 3, offset 3]</span><br><span class="line">LOGICAL READ from addr:8 size:4096</span><br><span class="line">  read  [disk 0, offset 2]</span><br><span class="line">LOGICAL READ from addr:9 size:4096</span><br><span class="line">  read  [disk 0, offset 3]</span><br></pre></td></tr></table></figure>

<p>布局推测：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0  2  4  P</span><br><span class="line">1  3  5  P</span><br><span class="line">8  10 P  6</span><br><span class="line">9  11 P  7</span><br></pre></td></tr></table></figure>

<h3 id="38-3"><a href="#38-3" class="headerlink" title="38.3"></a><strong>38.3</strong></h3><p><strong>执行上述测试，但使用 r 标志来反转每个问题的性质。</strong></p>
<p>可以看到，磁盘布局没有发生变化</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">❯ python2 raid.py -n 12 -L 5 -5 LS -c -W seq -C 8K -r</span><br><span class="line">LOGICAL READ from addr:0 size:4096</span><br><span class="line">  read  [disk 0, offset 0]</span><br><span class="line">LOGICAL READ from addr:1 size:4096</span><br><span class="line">  read  [disk 0, offset 1]</span><br><span class="line">LOGICAL READ from addr:2 size:4096</span><br><span class="line">  read  [disk 1, offset 0]</span><br><span class="line">LOGICAL READ from addr:3 size:4096</span><br><span class="line">  read  [disk 1, offset 1]</span><br><span class="line">LOGICAL READ from addr:4 size:4096</span><br><span class="line">  read  [disk 2, offset 0]</span><br><span class="line">LOGICAL READ from addr:5 size:4096</span><br><span class="line">  read  [disk 2, offset 1]</span><br><span class="line">LOGICAL READ from addr:6 size:4096</span><br><span class="line">  read  [disk 3, offset 2]</span><br><span class="line">LOGICAL READ from addr:7 size:4096</span><br><span class="line">  read  [disk 3, offset 3]</span><br><span class="line">LOGICAL READ from addr:8 size:4096</span><br><span class="line">  read  [disk 0, offset 2]</span><br><span class="line">LOGICAL READ from addr:9 size:4096</span><br><span class="line">  read  [disk 0, offset 3]</span><br><span class="line">LOGICAL READ from addr:10 size:4096</span><br><span class="line">  read  [disk 1, offset 2]</span><br><span class="line">LOGICAL READ from addr:11 size:4096</span><br><span class="line">  read  [disk 1, offset 3]</span><br></pre></td></tr></table></figure>

<h3 id="38-4"><a href="#38-4" class="headerlink" title="38.4"></a>38.4</h3><p><strong>现在使用反转标志，但用-S 标志增加每个请求的大小。尝试指定 8 KB、12 KB 和 16 KB 的大小，同时改变 RAID 级别。当请求的大小增加时，底层 IO 模式会发生什么？请务必在顺序工作负载上尝试此操作（-W sequential）。对于什么请求大小，RAID-4 和 RAID-5 的 I0 效率更高？</strong></p>
<p>1.当请求块大小超过磁盘块大小时，一个请求需要读写多个磁盘</p>
<p>2.对于 RAID-4 和 RAID-5，请求块大小为 16 K 时，效率更高，因为可以同时利用多个磁盘，相当于全条带写入</p>
<h3 id="38-5"><a href="#38-5" class="headerlink" title="38.5"></a>38.5</h3><p><strong>使用模拟器的定时模式（-t）来估计 100 次随机读取到 RAID 的性能，同时改变 RAID 级别，使用 4 个磁盘。</strong></p>
<p>运行以下命令行，可以看到 RAID0 的性能是最优的，RAID4 由于可使用磁盘为 4-1&#x3D;3，读取性能较差</p>
<p><code>python2 raid.py -L 0 -t -n 100 -c -D 4</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disk:0  busy: 100.00  I/Os:    28 (sequential:0 nearly:1 random:27)</span><br><span class="line">disk:1  busy:  93.91  I/Os:    29 (sequential:0 nearly:6 random:23)</span><br><span class="line">disk:2  busy:  87.92  I/Os:    24 (sequential:0 nearly:0 random:24)</span><br><span class="line">disk:3  busy:  65.94  I/Os:    19 (sequential:0 nearly:1 random:18)</span><br><span class="line"></span><br><span class="line">STAT totalTime 275.7</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>python2 raid.py -L 1 -t -n 100 -c -D 4</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disk:0  busy: 100.00  I/Os:    28 (sequential:0 nearly:1 random:27)</span><br><span class="line">disk:1  busy:  86.98  I/Os:    24 (sequential:0 nearly:0 random:24)</span><br><span class="line">disk:2  busy:  97.52  I/Os:    29 (sequential:0 nearly:3 random:26)</span><br><span class="line">disk:3  busy:  65.23  I/Os:    19 (sequential:0 nearly:1 random:18)</span><br><span class="line"></span><br><span class="line">STAT totalTime 278.7</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>python2 raid.py -L 4 -t -n 100 -c -D 4</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">disk:0  busy:  78.48  I/Os:    30 (sequential:0 nearly:0 random:30)</span><br><span class="line">disk:1  busy: 100.00  I/Os:    40 (sequential:0 nearly:3 random:37)</span><br><span class="line">disk:2  busy:  76.46  I/Os:    30 (sequential:0 nearly:2 random:28)</span><br><span class="line">disk:3  busy:   0.00  I/Os:     0 (sequential:0 nearly:0 random:0)</span><br><span class="line"></span><br><span class="line">STAT totalTime 386.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>python2 raid.py -L 5 -t -n 100 -c -D 4</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">disk:0  busy: 100.00  I/Os:    28 (sequential:0 nearly:1 random:27)</span><br><span class="line">disk:1  busy:  95.84  I/Os:    29 (sequential:0 nearly:5 random:24)</span><br><span class="line">disk:2  busy:  87.60  I/Os:    24 (sequential:0 nearly:0 random:24)</span><br><span class="line">disk:3  busy:  65.70  I/Os:    19 (sequential:0 nearly:1 random:18)</span><br><span class="line"></span><br><span class="line">STAT totalTime 276.7</span><br></pre></td></tr></table></figure>

<h2 id="第-40-章——文件系统的实现"><a href="#第-40-章——文件系统的实现" class="headerlink" title="第 40 章——文件系统的实现"></a>第 40 章——文件系统的实现</h2><h3 id="40-1"><a href="#40-1" class="headerlink" title="40.1"></a>40.1</h3><p><strong>用一些不同的随机种子（比如 17、18、19、20）运行模拟器，看看你是否能确定每次状态变化之间一定发生了哪些操作。</strong></p>
<p>以随机种子 -s 17 为例</p>
<p>运行以下命令行</p>
<p><code>python2 vsfs.py -n 6 -s 17</code></p>
<p>每步发生的操作写在注释中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Initial state</span><br><span class="line"></span><br><span class="line">inode bitmap  10000000</span><br><span class="line">inodes        [d a:0 r:2] [] [] [] [] [] [] []</span><br><span class="line">data bitmap   10000000</span><br><span class="line">data          [(.,0) (..,0)] [] [] [] [] [] [] []</span><br><span class="line"></span><br><span class="line">Which operation took place?</span><br><span class="line">#创建了目录‘/u’  mkdir(&#x27;/u&#x27;)</span><br><span class="line">inode bitmap  11000000</span><br><span class="line">inodes        [d a:0 r:3] [d a:1 r:2] [] [] [] [] [] []</span><br><span class="line">data bitmap   11000000</span><br><span class="line">data          [(.,0) (..,0) (u,1)] [(.,1) (..,0)] [] [] [] [] [] []</span><br><span class="line"></span><br><span class="line">Which operation took place?</span><br><span class="line">#创建文件‘/a’  create(&#x27;/a&#x27;)</span><br><span class="line">inode bitmap  11100000</span><br><span class="line">inodes        [d a:0 r:3] [d a:1 r:2] [f a:-1 r:1] [] [] [] [] []</span><br><span class="line">data bitmap   11000000</span><br><span class="line">data          [(.,0) (..,0) (u,1) (a,2)] [(.,1) (..,0)] [] [] [] [] [] []</span><br><span class="line"></span><br><span class="line">Which operation took place?</span><br><span class="line">#删除文件‘/a’    unlink(&#x27;/a&#x27;)</span><br><span class="line">inode bitmap  11000000</span><br><span class="line">inodes        [d a:0 r:3] [d a:1 r:2] [] [] [] [] [] []</span><br><span class="line">data bitmap   11000000</span><br><span class="line">data          [(.,0) (..,0) (u,1)] [(.,1) (..,0)] [] [] [] [] [] []</span><br><span class="line"></span><br><span class="line">Which operation took place?</span><br><span class="line">#创建目录‘/z’    mkdir(/z)</span><br><span class="line">inode bitmap  11100000</span><br><span class="line">inodes        [d a:0 r:4] [d a:1 r:2] [d a:2 r:2] [] [] [] [] []</span><br><span class="line">data bitmap   11100000</span><br><span class="line">data          [(.,0) (..,0) (u,1) (z,2)] [(.,1) (..,0)] [(.,2) (..,0)] [] [] [] [] []</span><br><span class="line"></span><br><span class="line">Which operation took place?</span><br><span class="line">#创建目录‘/s’       mkdir(&#x27;/s&#x27;)</span><br><span class="line">inode bitmap  11110000</span><br><span class="line">inodes        [d a:0 r:5] [d a:1 r:2] [d a:2 r:2] [d a:3 r:2] [] [] [] []</span><br><span class="line">data bitmap   11110000</span><br><span class="line">data          [(.,0) (..,0) (u,1) (z,2) (s,3)] [(.,1) (..,0)] [(.,2) (..,0)] [(.,3) (..,0)] [] [] [] []</span><br><span class="line"></span><br><span class="line">Which operation took place?</span><br><span class="line">#创建文件‘/z/x’    create(/z/x)</span><br><span class="line">inode bitmap  11111000</span><br><span class="line">inodes        [d a:0 r:5] [d a:1 r:2] [d a:2 r:2] [d a:3 r:2] [f a:-1 r:1] [] [] []</span><br><span class="line">data bitmap   11110000</span><br><span class="line">data          [(.,0) (..,0) (u,1) (z,2) (s,3)] [(.,1) (..,0)] [(.,2) (..,0) (x,4)] [(.,3) (..,0)] [] [] [] []</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="40-2"><a href="#40-2" class="headerlink" title="40.2"></a>40.2</h3><p><strong>现在使用不同的随机种子（比如 21、22、23、24），但使用-r 标志运行，这样做可以让你在显示操作时猜测状态的变化。关于 inode 和数据块分配算法，根据它们喜欢分配的块，你可以得出什么结论？</strong></p>
<p>可以看到，操作系统按照最近可分配原则分配 inode 和数据块</p>
<p><code>python2 vsfs.py -s 21 -r</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Initial state</span><br><span class="line"></span><br><span class="line">inode bitmap  10000000</span><br><span class="line">inodes        [d a:0 r:2] [] [] [] [] [] [] []</span><br><span class="line">data bitmap   10000000</span><br><span class="line">data          [(.,0) (..,0)] [] [] [] [] [] [] []</span><br><span class="line"></span><br><span class="line">mkdir(&quot;/o&quot;);</span><br><span class="line"></span><br><span class="line">inode bitmap  11000000</span><br><span class="line">inodes        [d a:0 r:3] [d a:1 r:2] [] [] [] [] [] []</span><br><span class="line">data bitmap   11000000</span><br><span class="line">data          [(.,0) (..,0) (o,1)] [(.,1) (..,0)] [] [] [] [] [] []</span><br><span class="line"></span><br><span class="line">creat(&quot;/b&quot;);</span><br><span class="line"></span><br><span class="line">inode bitmap  11100000</span><br><span class="line">inodes        [d a:0 r:3] [d a:1 r:2] [f a:-1 r:1] [] [] [] [] []</span><br><span class="line">data bitmap   11000000</span><br><span class="line">data          [(.,0) (..,0) (o,1) (b,2)] [(.,1) (..,0)] [] [] [] [] [] []</span><br><span class="line"></span><br><span class="line">creat(&quot;/o/q&quot;);</span><br><span class="line"></span><br><span class="line">inode bitmap  11110000</span><br><span class="line">inodes        [d a:0 r:3] [d a:1 r:2] [f a:-1 r:1] [f a:-1 r:1] [] [] [] []</span><br><span class="line">data bitmap   11000000</span><br><span class="line">data          [(.,0) (..,0) (o,1) (b,2)] [(.,1) (..,0) (q,3)] [] [] [] [] [] []</span><br><span class="line"></span><br><span class="line">fd=open(&quot;/b&quot;, O_WRONLY|O_APPEND); write(fd, buf, BLOCKSIZE); close(fd);</span><br><span class="line"></span><br><span class="line">inode bitmap  11110000</span><br><span class="line">inodes        [d a:0 r:3] [d a:1 r:2] [f a:2 r:1] [f a:-1 r:1] [] [] [] []</span><br><span class="line">data bitmap   11100000</span><br><span class="line">data          [(.,0) (..,0) (o,1) (b,2)] [(.,1) (..,0) (q,3)] [m] [] [] [] [] []</span><br><span class="line"></span><br><span class="line">fd=open(&quot;/o/q&quot;, O_WRONLY|O_APPEND); write(fd, buf, BLOCKSIZE); close(fd);</span><br><span class="line"></span><br><span class="line">inode bitmap  11110000</span><br><span class="line">inodes        [d a:0 r:3] [d a:1 r:2] [f a:2 r:1] [f a:3 r:1] [] [] [] []</span><br><span class="line">data bitmap   11110000</span><br><span class="line">data          [(.,0) (..,0) (o,1) (b,2)] [(.,1) (..,0) (q,3)] [m] [j] [] [] [] []</span><br><span class="line"></span><br><span class="line">creat(&quot;/o/j&quot;);</span><br><span class="line"></span><br><span class="line">inode bitmap  11111000</span><br><span class="line">inodes        [d a:0 r:3] [d a:1 r:2] [f a:2 r:1] [f a:3 r:1] [f a:-1 r:1] [] [] []</span><br><span class="line">data bitmap   11110000</span><br><span class="line">data          [(.,0) (..,0) (o,1) (b,2)] [(.,1) (..,0) (q,3) (j,4)] [m] [j] [] [] [] []</span><br><span class="line"></span><br><span class="line">unlink(&quot;/b&quot;);</span><br><span class="line"></span><br><span class="line">inode bitmap  11011000</span><br><span class="line">inodes        [d a:0 r:3] [d a:1 r:2] [] [f a:3 r:1] [f a:-1 r:1] [] [] []</span><br><span class="line">data bitmap   11010000</span><br><span class="line">data          [(.,0) (..,0) (o,1)] [(.,1) (..,0) (q,3) (j,4)] [] [j] [] [] [] []</span><br><span class="line"></span><br><span class="line">fd=open(&quot;/o/j&quot;, O_WRONLY|O_APPEND); write(fd, buf, BLOCKSIZE); close(fd);</span><br><span class="line"></span><br><span class="line">inode bitmap  11011000</span><br><span class="line">inodes        [d a:0 r:3] [d a:1 r:2] [] [f a:3 r:1] [f a:2 r:1] [] [] []</span><br><span class="line">data bitmap   11110000</span><br><span class="line">data          [(.,0) (..,0) (o,1)] [(.,1) (..,0) (q,3) (j,4)] [g] [j] [] [] [] []</span><br><span class="line"></span><br><span class="line">creat(&quot;/o/x&quot;);</span><br><span class="line"></span><br><span class="line">inode bitmap  11111000</span><br><span class="line">inodes        [d a:0 r:3] [d a:1 r:2] [f a:-1 r:1] [f a:3 r:1] [f a:2 r:1] [] [] []</span><br><span class="line">data bitmap   11110000</span><br><span class="line">data          [(.,0) (..,0) (o,1)] [(.,1) (..,0) (q,3) (j,4) (x,2)] [g] [j] [] [] [] []</span><br><span class="line"></span><br><span class="line">mkdir(&quot;/o/t&quot;);</span><br><span class="line"></span><br><span class="line">inode bitmap  11111100</span><br><span class="line">inodes        [d a:0 r:3] [d a:1 r:3] [f a:-1 r:1] [f a:3 r:1] [f a:2 r:1] [d a:4 r:2] [] []</span><br><span class="line">data bitmap   11111000</span><br><span class="line">data          [(.,0) (..,0) (o,1)] [(.,1) (..,0) (q,3) (j,4) (x,2) (t,5)] [g] [j] [(.,5) (..,1)] [] [] []</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="40-3"><a href="#40-3" class="headerlink" title="40.3"></a>40.3</h3><p><strong>现在将文件系统中的数据块数量减少到非常少（比如两个），并用 100 个左右的请求来运行模拟器。在这种高度约束的布局中，哪些类型的文件最终会出现在文件系统中？什么类型的操作会失败？</strong></p>
<p>只有 inode 和 data 会出现在文件系统中</p>
<p>mkdir 操作会失败， create 操作不会失败,但 create 操作不会添加数据块</p>
<h3 id="40-4"><a href="#40-4" class="headerlink" title="40.4"></a>40.4</h3><p><strong>现在做同样的事情，但针对 inodes。只有非常少的 inode，什么类型的操作才能成功？哪些通常会失败？文件系统的最终状态可能是什么？</strong></p>
<p>mkdir 和 create 操作都会失败，最终文件系统的状态如下（vsfs 最后一个数据块不能使用）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inode bitmap  10</span><br><span class="line">inodes        [d a:0 r:2] []</span><br><span class="line">data bitmap   10000000</span><br><span class="line">data          [(.,0) (..,0)] [] [] [] [] [] [] []</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>The-Operating-System-Notes</category>
      </categories>
      <tags>
        <tag>operating sysytem</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>并发性</title>
    <url>/2021/05/15/%E6%8C%81%E4%B9%85%E6%80%A7/</url>
    <content><![CDATA[<h1 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h1><h2 id="第-36-章-I-x2F-O-设备"><a href="#第-36-章-I-x2F-O-设备" class="headerlink" title="第 36 章 I&#x2F;O 设备"></a>第 36 章 I&#x2F;O 设备</h2><h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>先看一个典型系统的架构：</p>
<p><img src="https://s2.loli.net/2022/01/04/6VZGklTiugHsnxY.png" alt="image-20220104191656489"></p>
<p>CPU 通过内存总线连接到系统内存，图像或者其它高性能 I&#x2F;O 设备通过常规的 I&#x2F;O 总线连接到系统，外围总线(SCSI,SATA,USB)将最慢的设备连接到系统中</p>
<p>采用这样的布局，是因为越短的总线越快，因此高性能的内存总线没有足够的空间连接太多设备，且高性能总线的造价很高，所以采用这种分层的布局，让要求高性能的设备(显卡)离 CPU 更近一点，低性能的设备离 CPU 远一点，将磁盘和其它低速设备连接到外围总线的好处有很多，如你可以在外围总线上连接大量的设备</p>
<h3 id="标准设备"><a href="#标准设备" class="headerlink" title="标准设备"></a>标准设备</h3><p>这是一个标准设备，通过它可以理解设备交互的机制，这个标准设备包含两部分重要组件</p>
<p><strong>硬件接口</strong>：同软件一样，硬件也需要一些接口，让系统来控制它的操作，所有的设备都有自己的特定接口以及特有的交互协议</p>
<p><strong>内部结构</strong>：包含设备功能的实现，一些非常简单的设备通常用一个或几个芯片来实现它们的功能，更复杂的设备会包含简单的 CPU，一些通用内存，设备相关的特定芯片，来完成它们的工作，如现代 RAID 控制器通常包含上千行固件(硬件中的软件)<br><img src="https://s2.loli.net/2022/01/04/Rs5MnIegQawJZuK.png" alt="image-20220104191807544"></p>
<h3 id="标准协议"><a href="#标准协议" class="headerlink" title="标准协议"></a>标准协议</h3><p>在标准设备的示意图中，设备接口包含了 3 个寄存器，一个状态寄存器(用于读取并查看当前设备的状态)，一个命令寄存器(用于通知设备执行某项任务)，一个数据寄存器(将数据传给设备或者从设备接收数据)，通过读写标准设备的这些寄存器，操作系统就可以控制该设备的行为</p>
<p>一个简单的交互协议：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//轮询设备当前状态</span><br><span class="line">while(STATUS == BUSY) &#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br><span class="line">//向数据寄存器和命令寄存器写入数据</span><br><span class="line">Write data to DATA register</span><br><span class="line">Write Command to COMMAND register</span><br><span class="line">//轮询设备是否成功执行命令</span><br><span class="line">while(STATUS == BUSY) &#123;</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

<p>这个简单的标准协议包含 4 步：<br>1，操作系统反复读取状态寄存器，等待设备进入可以直接接收命令的就绪状态，称为轮询设备<br>2，操作系统下发数据到数据寄存器<br>3，操作系统将命令写入命令寄存器，这时设备就知道数据已经准备好了，它开始执行命令<br>4，操作系统不断轮询设备，等待并判断设备是否完成了命令(可能得到一个代表执行成功或失败的数据)</p>
<p>这个协议简单且有效，但难免有些低效和不方便，第一个问题就是轮询比较低效，在等待设备执行完成命令时浪费了大量 CPU 时间，如果此时操作系统切换到下一个就绪进程，就可以大大提高 CPU 的利用率</p>
<h3 id="用中断减少-CPU-开销"><a href="#用中断减少-CPU-开销" class="headerlink" title="用中断减少 CPU 开销"></a>用中断减少 CPU 开销</h3><p>利用中断可以减少 CPU 的开销，在上述的标准协议中，有了中断，CPU 可以不用通过轮询设备来判断设备是否成功执行命令，而是向设备发出一个请求，然后让当前发起 I&#x2F;O 的进程睡眠，切换执行其它进程，当设备执行完命令后，会抛出一个硬件中断，引发 CPU 跳转执行系统预先定义好的中断服务例程或中断处理程序，它会唤醒先前发起 I&#x2F;O 的进程继续执行</p>
<p>因此中断允许计算与 I&#x2F;O 重叠，这是提高 CPU 利用率的关键</p>
<p>但是使用中断也<strong>并非是最佳</strong>方案，考虑下面两个场景：<br>1，如果有一个非常高性能的设备，它处理请求很快，通常在 CPU 第一次轮询就能返回结果，如果此时使用中断，反而会让系统变慢，使用中断切换到其它进程，处理中断再切换回来带来了进程切换的开销，如果设备很快，那么最好的方法反而是轮询，如果设备较慢，那么采用允许发生重叠的中断更好，如果设备速度时慢时快，那么可以采用<strong>混合策略，先轮询一小段时间，设备还没有完成命令时，再使用中断</strong><br>2，在网络中，网络端收到大量数据包，如果每个包引发一次中断，那么可能导致操作系统不断处理中断而无法处理用户的请求，<strong>这种情况下，采用轮询可以更好控制系统的行为，让服务器先处理一些请求，再轮询网卡是否有数据包到达</strong></p>
<p>对于中断的处理也可以优化，通过合并，设备在抛出中断前先等待一小段时间，在此期间其它请求可能也会完成，就可以将多个中断合并成一次中断抛出，从而降低处理中断的代价</p>
<h3 id="利用-DMA-进行更高效的数据传送"><a href="#利用-DMA-进行更高效的数据传送" class="headerlink" title="利用 DMA 进行更高效的数据传送"></a>利用 DMA 进行更高效的数据传送</h3><p>DMA 引擎是操作系统中的一个特殊设备，它可以协调完成内存和设备间的数据传递，不需要 CPU 介入</p>
<p>DMA 的工作过程：为了将数据传送给设备，操作系统通过编程告诉 DMA 引擎需要的数据所在内存的位置，要拷贝的大小以及要拷贝到哪个设备，之后操作系统就可以处理其他请求了，当 DMA 的任务完成后，DMA 控制器会抛出一个中断告诉操作系统自己已经完成了数据传输</p>
<p>数据的拷贝都是由 DMA 完成的，因此 CPU 在此时是空闲的，所以操作系统可以让它做一些其它事情，如调度其它进程法</p>
<h3 id="设备交互方法"><a href="#设备交互方法" class="headerlink" title="设备交互方法"></a>设备交互方法</h3><p><strong>使用明确的 I&#x2F;O 指令</strong>：这些 I&#x2F;O 指令规定了操作系统将数据发送到特定设备寄存器的方法，从而允许构造上文提到的协议</p>
<p>如在 x86 上，in 和 out 指令都可以用来与设备进行交互，当需要发送数据给设备时，调用 in 指令指定一个存入数据的特定寄存器和一个代表设备的特定端口，执行这个指令就可以实现期望的行为</p>
<p>这些指令通常是特权指令，操作系统是唯一可以直接与设备交互的实体，不允许其它的程序直接读写磁盘，控制外设，这样会变得一团糟</p>
<p><strong>内存映射 I&#x2F;O</strong>：通过这种方式，硬件将设备寄存器作为内存地址提供，当需要访问设备寄存器时，操作系统装载(读取)或者存入(写入)到该内存地址，然后硬件会将装载&#x2F;存入转移到设备上，而不是物理内存</p>
<p>这两种方式没有一种具有极大的优势，内存映射 I&#x2F;O 的好处是不需要引入新指令来实现设备交互，但两种方法都在使用</p>
<h3 id="入操作系统：设备驱动程序"><a href="#入操作系统：设备驱动程序" class="headerlink" title="入操作系统：设备驱动程序"></a>入操作系统：设备驱动程序</h3><p>我们希望操作系统尽可能地通用，例如文件系统，我们希望开发一个文件系统可以工作在 SCSI 硬盘，IDE 硬盘，USB 设备等设备之上，并且希望这个文件系统不那么清楚对这些不同设备发出读写地全部细节</p>
<p>这个问题可以通过抽象来解决，在最底层，操作系统的一部分软件清楚地知道设备如何工作，将这部分软件称为<strong>设备驱动程序</strong>，所有设备交互的细节都封装在其中</p>
<p>Linux 的文件系统栈：<br>文件系统完全不清楚它使用的是什么类型的磁盘，它只需要简单地向通用块设备层发送读写请求即可，设备层将这些请求交给设备驱动，然后设备驱动来完成真正的底层操作</p>
<p>这种封装也有不足的地方<br>1、如果一个设备可以提供很多特殊的功能，但因为兼容了大多数操作系统，它不得不提供一个通用的接口，<strong>这样就使得自身的特殊功能无处使用</strong></p>
<p>2、因为所有需要插入系统的设备都需要安装对应的驱动程序，所以久而久之，<strong>驱动程序在内核代码中占的比重越来越大</strong>，Linux 内核中 70%都是各种驱动程序，因为驱动程序的开发者不是专业的内核开发人员，所以他们更容易写出缺陷，因此他们是<strong>内核崩溃的主要贡献者</strong></p>
<h3 id="简单的-IDE-磁盘驱动程序"><a href="#简单的-IDE-磁盘驱动程序" class="headerlink" title="简单的 IDE 磁盘驱动程序"></a>简单的 IDE 磁盘驱动程序</h3><p>看一个真实的设备-IDE 磁盘驱动程序，IDE 磁盘暴露给操作系统的接口比较简单，包含 4 种类型的寄存器，即控制，命令块，状态，错误，在 x86 上，利用 I&#x2F;O 指令 in 和 out 向特定的 I&#x2F;O 地址读取或写入时，可以访问这些寄存器</p>
<p>下面是与设备交互的简单协议，假设它已经初始化了：<br>1，<strong>等待驱动就绪</strong>，读取状态寄存器，直到驱动 READY 而非忙碌<br>2，<strong>向命令寄存器写入参数</strong>，写入扇区数，待访问扇区对应的逻辑块地址，并将驱动编号写入命令寄存器<br>3，<strong>开启 I&#x2F;O</strong>，发送读写命令到命令寄存器<br>4，<strong>数据传送</strong>(针对写请求)，等待驱动状态为 READY<br>5，<strong>中断处理</strong>，完成后触发中断，恢复进程<br>6，<strong>错误处理</strong>，每次操作后读取状态寄存器，如果 ERROR 被置位，就可以读取错误寄存器获取详细信息</p>
<p>IDE 读写主要通过 4 个函数实现：<br>1，ide_rw()，它会将一个请求加入队列，调用它的进程睡眠<br>2，ide_wait_ready()，确保驱动处于就绪状态<br>3，ide_start_request()，将请求发送到磁盘，进行 in&#x2F;out 指令<br>4，ide intr()，完成后，发生中断，唤醒发起 I&#x2F;O 的进程</p>
<h2 id="第-37-章磁盘驱动器"><a href="#第-37-章磁盘驱动器" class="headerlink" title="第 37 章磁盘驱动器"></a>第 37 章磁盘驱动器</h2><p>磁盘驱动器（Hard Disk Driver）又称“磁盘机”，是以磁盘作为记录信息媒体的存储装置。它既是输入设备，又是输出设备</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>现代磁盘驱动器的接口都很简单，磁盘驱动器由大量扇区(512 字节)组成，每个扇区都可以读取或写入，在具有 n 个扇区的磁盘上，扇区从 0 到 n-1 编号，因此可以将磁盘视为一组扇区，从 0 到 n-1 是驱动器的地址空间</p>
<p>通常可以假设访问驱动器地址空间内两个彼此靠近的块比访问两个相隔很远的块更快，也可以假设访问连续块，是最快的访问模式，并且通常比任何随机的访问模式快得多</p>
<h3 id="基本几何形状"><a href="#基本几何形状" class="headerlink" title="基本几何形状"></a>基本几何形状</h3><p><img src="https://s2.loli.net/2022/01/04/Giyt2adqlFPVsO7.png" alt="image-20220104192611954"></p>
<h3 id="简单的磁盘驱动器"><a href="#简单的磁盘驱动器" class="headerlink" title="简单的磁盘驱动器"></a>简单的磁盘驱动器</h3><p>现在假设有一个单一磁道的简单磁盘：</p>
<p>该磁道只有 12 个扇区，每个扇区大小为 512 字节，用 0-11 表示这些扇区，这里的单个盘片围绕主轴旋转，电机连接到主轴，为了能读取或写入这些扇区，因此需要一个连接到磁盘臂上的磁头，磁盘表面逆时针旋转</p>
<p><img src="https://s2.loli.net/2022/01/04/mgs2NWxERiGqZY9.png" alt="image-20220104192735115"></p>
<p>(<strong>1) 单磁道延迟：旋转延迟</strong></p>
<p>现在加入收到了读取块 0 的请求，磁盘必须等待期望的扇区旋转到磁头下，这种等待在现代驱动器中经常发生，并且是 I&#x2F;O 服务时间的重要组成部分，它有一个特殊的名称：旋转延迟</p>
<p><strong>(2) 多磁道：寻道时间</strong></p>
<p><img src="https://s2.loli.net/2022/01/04/8MkQ3C2UDJoEwIn.png" alt="image-20220104192913854">单磁道是不现实的，现代磁盘有数以百万计的磁道，来看一个具有 3 条磁道的盘片表面：</p>
<p>现在追踪请求发生在远处扇区的情况，例如读取扇区 11，此时磁头处于扇区 30，在最内层的磁道，为了服务这个请求，驱动器首先将磁盘臂移动到正确的磁道，通过寻道过程，磁头被定位到了正确的磁道，接下来等待块 11 旋转经过磁头，当扇区 11 经过磁头时，I&#x2F;O 的最后阶段将发生，称为传输，数据从表面读取或写入表面</p>
<p>完整的 I&#x2F;O 时间轨迹：寻道-&gt;等待转动延迟-&gt;传输</p>
<p><strong>(3) 一些其它细节</strong><br>1，外圈磁道通常比内圈磁道具有更多扇区，这是几何结构的结果，外圈磁道的空间更大<br>2，任何现代磁盘驱动器都有一个重要组成部分，即它的缓存，该缓存只是很少的内存，驱动器可以用这些内存来保存磁盘读取或写入磁盘的数据，</p>
<h3 id="I-x2F-O-时间"><a href="#I-x2F-O-时间" class="headerlink" title="I&#x2F;O 时间"></a>I&#x2F;O 时间</h3><p>寻道：磁头从开始移动到数据所在<strong>磁道</strong>所需要的时间。寻道时间越短，I&#x2F;O 操作越快，</p>
<p>旋转延迟：盘片旋转将请求数据所在 扇区 移至读写 磁头 下方所需要的时间</p>
<p>数据传输时间：完成传输所请求的数据所需要的时间。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I/O时间T</span><br><span class="line">T = T寻道 + T旋转 + T传输</span><br><span class="line"></span><br><span class="line">I/O速率R</span><br><span class="line">R = 传输大小 / T</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>假设有两个工作负载，一个称为随机工作负载，它向磁盘上的随机位置发出小的读取请求，随机工作负载在许多重要的程序中很常见，包括数据库，第二种称为顺序工作负载，只是从磁盘连续读取大量的扇区，不会跳过，顺序访问也很常见</p>
<p>现在对希捷的一个高性能磁盘和一个大容量磁盘来估计这两个工作负载：</p>
<p>1，随机工作负载：<br>假设容量为 4kb，在 Cheetah 上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T寻道 = 4ms //采用数据中的平均寻道时间</span><br><span class="line">T旋转 = 2ms	//PRM=15000，则每次旋转需要4ms，半圈平均为2ms</span><br><span class="line">T传输 = 30μs //传输大小除以最大传输速率</span><br><span class="line">Cheetah的T = T寻道 + T旋转 + T传输 = 6ms</span><br><span class="line">Cheetah的R = 4kb / T = 0.66MB/s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>在 Barracuda 上</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Barracuda的T = T寻道 + T旋转 + T传输 = 13.2ms</span><br><span class="line">Barracuda的R = 4kb / T = 0.31MB/s</span><br></pre></td></tr></table></figure>

<p>顺序工作负载：<br>假设容量为 100MB，在 Cheetah 上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cheetah的T = T寻道 + T旋转 + T传输 = 800ms</span><br><span class="line">Cheetah的R = 100MB / T = 125MB/s</span><br></pre></td></tr></table></figure>

<p>在 Barracuda 上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Barracuda的T = T寻道 + T旋转 + T传输 = 950ms</span><br><span class="line">Barracuda的R = 100MB / T = 105MB/s</span><br></pre></td></tr></table></figure>

<p>随机和顺序工作负载之间的驱动性能很大，对于 Cheetah 来说几乎是 200 倍左右，对于对于 Barracuda 来说差不多是 300 倍</p>
<h3 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h3><p>由于 I&#x2F;O 的高成本，操作系统决定发送给 I 磁盘的 I&#x2F;O 顺序方面发挥作用，即给定一组 I&#x2F;O 请求，磁盘调度程序检查请求并决定下一个要调度的请求</p>
<p>与任务调度不同，每个任务的长度通常是不知道的，对于磁盘调度，可以很好的检测每个任务 I&#x2F;O 请求的时间，通过估计请求的查找和可能的旋转延迟，磁盘调度程序可以知道每个请求会花费多长时间，因此将优先服务花费时间少的请求，因此磁盘调度程序对于一组 I&#x2F;O 请求将尝试遵循 SJF(最短任务优先)原则</p>
<p><strong>SSTF：最短寻道时间优先</strong><br>一种早期的调度方法被称为 SSTF shortest seek time first，即最短寻道时间优先，SSTF 按磁道对 I&#x2F;O 请求队列排序，选择在最近磁道上的请求先完成</p>
<p>假设磁头在处于 30 扇区，现在的请求有 21 和 2，根据 SSTF，那么就会率先完成对 21 的请求，待扇区 21 的读写完成后，再处理对扇区 2 的请求</p>
<p>但是 SSTF 也存在一些缺陷：<br>1，操作系统并不知道驱动器的几何结构，在操作系统眼里整个驱动器只是一系列的块，采用 SSTF 并不能满足现代驱动器<br>2，饥饿，如果采用了 SSTF，现在对邻近磁道上的块一直有请求，那么距离远的块的请求，就无法得到服务</p>
<p><strong>SCAN：跨越磁道顺序</strong><br>为了解决饥饿，有一种算法称为 SCAN，简单地以跨越磁道顺序来服务磁盘请求，将一次跨越磁盘称为扫一遍，如果请求的块所属的磁道在这次扫一遍中已经服务过了那么它就不会立刻处理，而是排队等待下次扫一遍</p>
<p>SCAN 虽然能避免饥饿，但并没有严格遵循 SJF 原则，它忽视了旋转</p>
<p><strong>SPTF：最短定位时间优先</strong><br>SPTF shortest positioning time first，即最短定位时间优先，现代驱动器中，寻道和旋转大致相当，使用 SPTF 能提高性能</p>
<h2 id="第-38-章——-廉价冗余磁盘阵列-RAID"><a href="#第-38-章——-廉价冗余磁盘阵列-RAID" class="headerlink" title="第 38 章—— 廉价冗余磁盘阵列 RAID"></a>第 38 章—— 廉价冗余磁盘阵列 RAID</h2><p>廉价冗余磁盘阵列(RAID)，这种技术使用多个磁盘一起构建更快，更大，更可靠的磁盘系统</p>
<p>RAID 有许多好处，一个好处就是<strong>性能</strong>，并行使用多个磁盘可以大大加快 I&#x2F;O 时间，另一个好处是<strong>容量</strong>，大型数据集需要大型磁盘，最后 RAID 可以提高<strong>可靠性</strong>，通过冗余，RAID 允许损失一个磁盘并继续工作</p>
<h3 id="接口和-RAID-内部"><a href="#接口和-RAID-内部" class="headerlink" title="接口和 RAID 内部"></a>接口和 RAID 内部</h3><p>RAID 看起来是一个快速的，可靠的，很大的磁盘。<strong>它将自己展现为线性的块数组，每个块都可以通过文件系统读取或写入</strong></p>
<p><strong>当文件系统向 RAID 发出逻辑 I&#x2F;O 请求时，RAID 内部必须计算要访问的磁盘以完成请求，然后发出一个或多个物理 I&#x2F;O 来执行此操作</strong></p>
<h3 id="RAID-的简单评估标准"><a href="#RAID-的简单评估标准" class="headerlink" title="RAID 的简单评估标准"></a>RAID 的简单评估标准</h3><p>容量，性能，可靠性</p>
<h3 id="RAID-0-级：条带化"><a href="#RAID-0-级：条带化" class="headerlink" title="RAID 0 级：条带化"></a>RAID 0 级：条带化</h3><p>第一个 RAID 级别实际上不是 RAID 级别，因为没有<strong>冗余</strong>，但是 RAID 0 级拥有高性能和大容量，所以值得了解</p>
<p><strong>RAID 0 级的原理</strong></p>
<p>以轮转的方式将磁盘阵列的块分布在磁盘上，这种方法的目的是在对数组的连续块进行请求时，从阵列中获取最大的并行性(如在一个大的顺序读取中)，将同一行中的块称为条带，因此块 0，1，2，3 在相同的条带中</p>
<p>上述的示例中，假设同一行条带的每个磁盘只有一个块(4KB)，但是这不是必要的，也可以增大块的大小：</p>
<p><img src="https://s2.loli.net/2022/01/04/P4qUnMiv3ZmDHfh.png" alt="image-20220104194624669"></p>
<p>大块大小不同的结果<br><strong>一方面，大块大小主要影响阵列的性能</strong>，如大小较小的大块意为着许多文件将跨多个磁盘进行条带化，从而增加了对单个文件的读取和写入的并行性，但是跨多个磁盘访问块的定位时间会增加</p>
<p><strong>另一方面，较大的大块大小减少了这种文件内的并行性</strong>，因此依靠多个并发请求来实现高吞吐量，但是较大的大块减少了定位时间</p>
<p>因此确定“最佳”大块大小是很难做到的，因为需要大量关于提供给磁盘系统的工作负载的知识<br><strong>RAID 0 级的评估</strong></p>
<p>从容量的角度来看，RAID 0 级是顶级的，给定 N 个磁盘，就有 N 个磁盘的可用空间.</p>
<p>从可靠性的角度来看，条带化最糟糕的是：任何磁盘故障都会导致数据丢失。</p>
<p>最后，其性能非常好，通常并行使用所有磁盘来为用户 I&#x2F;O 请求提供服务</p>
<h3 id="RAID-1-级：镜像"><a href="#RAID-1-级：镜像" class="headerlink" title="RAID 1 级：镜像"></a>RAID 1 级：镜像</h3><p>即<strong>镜像</strong>，对于镜像系统，只需要<strong>生成系统中每个块的多个副本，每个副本放在一个单独的磁盘上，通过这样做，可以容许磁盘故障</strong></p>
<p><strong>RAID 1 级的原理</strong></p>
<p>从镜像阵列读取块时，RAID 有一个选择，它可以读取任一副本，如对 RAID 发出逻辑块 5 的读取，则可以自由地从磁盘 2 或磁盘 3 读取它，但是在<strong>写入块时，RAID 必须更新两个副本的数据，以保证可靠性，这种写入可以并行执行</strong></p>
<p><img src="https://s2.loli.net/2022/01/04/7aGN2yKT6znlgbX.png" alt="image-20220104195048374"></p>
<p><strong>RAID 1 级的评估</strong></p>
<p>从容量角度看，RAID 1 级价格昂贵，在镜像级别等于 2 的情况下，只能获得峰值有用容量的一半，因此对于 N 个磁盘，镜像的有用容量为 N&#x2F;2。</p>
<p>从可靠性的角度看，RAID 1 级表现良好，它可以容许任何一个磁盘的故障</p>
<p>最后，我们分析性能。从单个读取请求的延迟角度来看，我们可以看到它与单个磁盘上的延迟相同。写入有点不同：以它遭遇到两个请求中最差的寻道和旋转延迟，因此（平均而言）比写入单个磁盘略高。</p>
<h3 id="RAID-4-级：通过奇偶校验节省空间"><a href="#RAID-4-级：通过奇偶校验节省空间" class="headerlink" title="RAID 4 级：通过奇偶校验节省空间"></a>RAID 4 级：通过奇偶校验节省空间</h3><p><strong>RAID 4 级的原理</strong><br>现在有一种向磁盘阵列添加冗余的不同方法，称为奇偶校验，基于奇偶校验的方法视图使用较少的容量，从而克服由镜像系统付出的巨大空间损失，不过这也会降低性能对于每一条数据，都添加一个奇偶校验块，用于存储该条块的冗余信息，如奇偶校验块 P1 具有块 4，5，6，7 计算出的冗余信息：<br><img src="https://s2.loli.net/2022/01/04/CYT53n2zhWbHdVP.png" alt="image-20220104195611490"></p>
<p><strong>RAID 4 级的评估</strong></p>
<p>从容量的角度来看，RAID 4 级使用 1 个磁盘作为它所保护的每组磁盘的奇偶校验信息，因此 RAID 组的有效容量是 N-1.</p>
<p>可靠性也很容易理解，RAID 4 级允许 1 个磁盘故障，不允许更多，如果丢失多个磁盘，则无法重建丢失的数据</p>
<p>性能：</p>
<p>这些磁盘的数据位于磁盘 0 和 1 上，因此对数据的读写操作可以并行进行，这很好。出现的问题是奇偶校验磁盘。这两个请求都必须读取 4 和 13 的奇偶校验块，即奇偶校验块 1 和 3（用+标记）。估计你已明白了这个问题：在这种类型的工作负载下，奇偶校验磁盘是瓶颈。因此我们有时将它称为基于奇偶校验的 RAID 的小写入问题（small-write problem）。<br>因此，即使可以并行访问数据磁盘，奇偶校验磁盘也不会实现任何并行。由于奇偶校验磁盘，所有对系统的写操作都将被序列化。由于奇偶校验磁盘必须为每个逻辑 I&#x2F;O 执行两次 I&#x2F;O（一次读取，一次写入），我们可以通过计算奇偶校验磁盘在这两个 I&#x2F;O 上的性能来计算 RAID-4 中的小的随机写入的性能，从而得到（R &#x2F; 2）MB&#x2F;s。随机小写入下的 RAID-4 吞吐量很糟糕，向系统添加磁盘也不会改善。</p>
<p><img src="https://s2.loli.net/2022/01/04/6v4H7OkAgUdFlNB.png" alt="image-20220104200703836"></p>
<p>**延迟:**你现在知道，单次读取（假设没有失败）只映射到单个磁盘，因此其延迟等同于单个磁盘请求的延迟。单次写入的延迟需要两次读取，<br>然后两次写入。读操作可以并行进行，写操作也是如此，因此总延迟大约是单个磁盘的两<br>倍。（有一些差异，因为我们必须等待两个读取操作完成，所以会得到最差的定位时间，但<br>是之后，更新不会导致寻道成本，因此可能是比平均水平更好的定位成本。）</p>
<h3 id="RAID-5-级：旋转奇偶校验"><a href="#RAID-5-级：旋转奇偶校验" class="headerlink" title="RAID 5 级：旋转奇偶校验"></a>RAID 5 级：旋转奇偶校验</h3><p><strong>RAID5 与 RAID4 原理几乎相同，只是它将奇偶校验块跨驱动器旋转</strong></p>
<p>如你所见，每个条带的奇偶校验块现在都在磁盘上旋转，以消除 RAID-4 的奇偶校验磁盘瓶颈。</p>
<p><img src="https://s2.loli.net/2022/01/04/yRzGsjq7VPZ2UC6.png" alt="image-20220104200939827"></p>
<p><strong>RAID 5 级的评估</strong></p>
<p>RAID 5 大部分与 RAID 4 相同，如两级的有效容量和容错能力是相同的，顺序读写性能也是如此，单个请求的延迟也与 RAID 4 相同</p>
<p>由于 RAID 5 基本上和 RAID 4 相同，只是少数情况下它更好，所以它几乎完全取代了市场上的 RAID 4，唯一没有取代的地方是系统知道自己绝对不会执行大写入以外的任何事情，从而完全避免小写入问题</p>
<h3 id="RAID-性能比较"><a href="#RAID-性能比较" class="headerlink" title="RAID 性能比较"></a>RAID 性能比较</h3><p>我们将假设磁盘可以在连续工作负载下以 S MB&#x2F;s 传输数据，并且在随机工作负载下以 R MB&#x2F;s 传输数据。一般来说，S 比 R 大得多。</p>
<p><img src="https://s2.loli.net/2022/01/08/2acJ57dMneEFOrv.png" alt="image-20220108210313664"></p>
<p><img src="https://s2.loli.net/2022/01/08/FE8QVhLjwtJaNZD.png" alt="image-20220108210340613"></p>
<h2 id="第-40-章——文件系统的实现"><a href="#第-40-章——文件系统的实现" class="headerlink" title="第 40 章——文件系统的实现"></a>第 40 章——文件系统的实现</h2><p>关于文件系统的两个问题<br>理解文件系统时，需要考虑它们的两个不同方面：</p>
<p><strong>文件系统的数据结构</strong>，即文件系统在磁盘上采用哪些类型的数据结构来组织其数据和元数据？较为简单的文件系统(如 VSFS)采用简单的数据结构，如块和其它对象的数组，而复杂些的文件系统(如 XFS)使用更复杂的基于树的结构</p>
<p><strong>访问方法</strong>，即如何将进程发出的调用，如 open()，read()，write()等映射到它的数据结构上？在执行特定系统调用期间读取哪些结构？改写哪些结构？这些步骤的执行效率如何？</p>
<h3 id="VSFS-的整体组织"><a href="#VSFS-的整体组织" class="headerlink" title="VSFS 的整体组织"></a>VSFS 的整体组织</h3><p><strong>1、将磁盘分成块</strong></p>
<p>简单的文件系统只使用一种块大小，这里也是这样，块大小选择 4KB，对于构建简单文件系统的磁盘分区的做法很简单，<strong>即将磁盘看成线性的一些块，每块大小为 4KB</strong></p>
<p>在大小为 N 个 4KB 块的分区中，这些块的地址从 0~N-1，假设有一个非常小的磁盘，只有 64 块</p>
<p><img src="https://s2.loli.net/2022/01/04/AicRfgk2qUDF5aM.png" alt="image-20220104202058947"></p>
<p><strong>2、 用户数据的存放：数据区域</strong></p>
<p>有了一系列等大的线性块后，接着要像其中存储数据，首先是用户数据，<strong>任何文件系统中大多数空间都应该是用户数据</strong>，将用于存放用户数据的磁盘区域称为<strong>数据区域</strong>，这里将最后 56 个块作为数据区域：</p>
<p><img src="https://s2.loli.net/2022/01/04/7ob1WJAqGM3BkTQ.png" alt="image-20220104202210608"></p>
<p><strong>3、记录每个文件的详细信息：inode 表</strong></p>
<p>inode：记录了文件中包含哪些数据块，文件的大小，文件的所有者和访问权限，访问和修改时间等类似的详细信息，为了存储这些信息</p>
<p>为了存放 inode，还需要在磁盘上留出一些空间，称这部分磁盘空间为 inode 表（inodemap），它只是保存了一个磁盘上 inode 的数组，假设 inode 表大小为 5 个块，磁盘看起来如下：</p>
<p><img src="https://s2.loli.net/2022/01/04/q8uIwKtBgkRbC6E.png" alt="image-20220104202429458"></p>
<p><strong>4、空闲空间的记录：位图</strong></p>
<p>目前为止，文件系统有了数据块和 inode 表，但是还需要某种方法记录 inode 或数据块是空闲还是已分配，因此这种分配结构是所有文件系统中必需的部分</p>
<p>存在很多可行的分配方法，如采用空闲列表，指向第一个空闲块，然后它又指向下一个空闲块，这里采用一种简单又流行的结构<br>位图(位图是一种简单的结构，每个位用于指示相应的块是否空闲)，一种用于数据区域，一种用于 inode 表<br><img src="https://s2.loli.net/2022/01/04/Aucng1mHXMvUsWe.png" alt="image-20220104202532655"></p>
<p><strong>文件系统信息的存储：超级块</strong></p>
<p>对于上述的磁盘布局，还有一块，这块留给<strong>超级块</strong>，<strong>超级块包含关于该特定文件系统的信息</strong>，包括例如文件系统中有多少个 inode 和数据块，inode 表的开始位置，还可能包括一些幻数用来标识文件系统的类型(如 VSFS)</p>
<p><img src="https://s2.loli.net/2022/01/04/6bhgijvTuw4YcUN.png" alt="image-20220104202851081"></p>
<h3 id="文件组织：inode-index-node-索引节点"><a href="#文件组织：inode-index-node-索引节点" class="headerlink" title="文件组织：inode(index node 索引节点)"></a>文件组织：inode(index node 索引节点)</h3><p><strong>(1) inode 结构寻址</strong><br>每个 inode 都由一个数字隐式引用，也称为文件的低级名称，如在 VSFS 中，给定一个文件低级名称，应该可以计算出该文件的 inode 结构在磁盘上的位置，根据之前的磁盘结构，假设 inode 表为 20KB，因此最多存在 80 个 inode 结构，假设 inode 表从 12KB 开始，读取 inode 号 32 号：<br>文件系统首先开始计算 inode 区域的偏移量</p>
<p><img src="https://s2.loli.net/2022/01/04/kJrB6mL9S3fcW8I.png" alt="image-20220104203031326"></p>
<p>(32*inode 的大小 1&#x2F;4KB &#x3D; 8192B)，<br>将它加上磁盘 inode 表的其实地址(12KB)，从而得到 20KB<br>inode 号为 32 的 inode 结构</p>
<p><strong>(3) inode 结构中的内容</strong></p>
<p>在每个 inode 中，实际上是关于对应文件的所有信息：文件类型，大小，所得数据块数，权限，时间信息等</p>
<p><img src="https://s2.loli.net/2022/01/04/LgKrTwuYmNjeVaC.png" alt="image-20220104203210640"></p>
<p><strong>(3) 多级索引</strong></p>
<p>设计 inode 时，最重要的决定之一是它如何引用数据块的位置，一种简单的方法是在 inode 中有一个或多个直接指针，每个指针指向属于该文件的一个磁盘，但当面对大文件时，直接指针不能满足需要：</p>
<p>当文件足够大时，分配一个间接块里面存储指向文件的块的指针，而 inode 结构中的间接指针则指向这个块，如果想支持更大的文件，可以使用双重间接指针，双重间接指针允许访问最大为 102410244KB 的文件，即所支持访问的文件大小超过了 4GB，如果不够，还可以使用三重间接指针</p>
<p>许多文件系统使用多级索引，包括常用的文件系统，Linux 的 ext2 和 ext3，以及原始的 UNIX 等，多级索引的机制能让 inode 直接指向较小的文件，也可以通过一个或多个间接块指向大文件</p>
<h3 id="目录组织"><a href="#目录组织" class="headerlink" title="目录组织"></a>目录组织</h3><p><strong>一个目录基本上只包含一个二元组(条目名称，inode 号)的列表</strong></p>
<p>加上 dir 中有 3 个文件，dir 在磁盘上的数据可能如下显示：</p>
<p><img src="https://s2.loli.net/2022/01/04/vEtcr8KV5zJPOe9.png" alt="image-20220104204232785"></p>
<p><strong>每个目录都有两个额外的条目，.(当前目录 dir) 和 …(父目录 &#x2F;)</strong></p>
<p>通常文件系统将目录视为特殊类型的文件，目录有一个 inode，位于 inode 表，该目录也有 inode 指向的数据块，这些数据块存在于我们简单文件系统的数据区域中</p>
<h3 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h3><p>文件系统必须要记录哪些 inode 和数据块是空闲的，哪些不是，这样在分配文件或目录时，就可以为它找到空间，空闲空间管理对于所有文件系统都很重要，VSFS 采用两个位图来完成</p>
<p>当创建一个文件时，必须为该文件分配一个 inode，文件系统将通过位图来搜索一个空闲的 inode 结构并分配个该文件，文件系统将该 inode 结构标记为已经使用(位图中置 1)<br>接着分配数据块时，大致是相同的，不过是根据数据块位图来寻找空闲空间，但是一些 LInux 文件系统在创建文件并需要数据块时，会寻找一系列数据块，通过查找一系列的数据块，将它们分配给创建的文件，文件系统保证该文件的一部分在磁盘上是连续的，从而提高性能，这种预分配策略，是为数据块分配空间时的常用方法</p>
<h3 id="访问路径：读取和写入"><a href="#访问路径：读取和写入" class="headerlink" title="访问路径：读取和写入"></a>访问路径：读取和写入</h3><p><strong>(1) 从磁盘读取</strong><br>假设要打开一个文件(如&#x2F;foo&#x2F;bar，该文件只有 4KB)，读取后并关闭</p>
<p>第 1 步：<strong>发出一个 open(“&#x2F;foo&#x2F;bar”, O_RDONLY)调用时</strong>，文件系统先要找到文件 bar 的 inode</p>
<p>第 2 步：<strong>开始遍历，从根目录 &#x2F; 开始</strong>，文件系统第一次磁盘读取是根目录的 inode&#x3D;2</p>
<p>第 3 步：根<strong>据 inode 中指向数据块的指针来查找条目 foo</strong>，一旦找到，文件系统也会找到下一个需要的 foo 的 inode 号</p>
<p>第 4 步：<strong>递归遍历路径名，直到找到所需的 inode</strong>，本例中，文件系统读取包含 foo 的 inode 及其目录的数据的块，最后找到 bar 的 inode</p>
<p>第 5 步：<strong>open()将 bar 的 inode 读入内存</strong>，然后文件系统对它进行最后的权限检查，在每个进程的打开文件表中，<strong>为此进程分配一个文件描述符</strong>，并将它返回给用户</p>
<p>第 6 步：<strong>发出 read()调用，从文件中读取</strong>，第一次读取将在文件的第一个块中，读取将进一步更新此文件描述符在内存中的打开文件表，更新文件偏移量，以便下一次读取会读取第二个文件块</p>
<p>第 7 步：<strong>关闭文件</strong>，文件描述符被释放</p>
<p>整个过程中，打开文件导致了多次读取，以便找到目标文件的 inode，之后，读取每个块需要文件系统先查询 inode，然后读取该块，再使用写入更新 inode 的最后访问时间字段</p>
<p><strong>open()导致的 I&#x2F;O 量与路径长度成正比</strong>，对于路径中每个增加的目录，都需要读取它的 inode 及其数据，更糟的是会出现大型目录，对于大型目录需要读取更多的块</p>
<p><strong>(2) 向磁盘写入</strong><br>写入文件是一个类似的过程，首先文件必须被找到且打开，其次应用程序可以发出 write()调用以更新文件内容，最后关闭文件</p>
<p>与读取不同，写入文件时可能会分配一个块，当写入一个新文件时，每次的操作不仅要将数据写入磁盘，还要先先决定将那个块分配给文件，从而更新磁盘的其它结构(数位图，inode 表)，因此每次<strong>写入文件在逻辑上有 5 个 I&#x2F;O：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1，一个读取数据位图</span><br><span class="line">2，一个写入位图</span><br><span class="line">3，读取inode</span><br><span class="line">4，写inode</span><br><span class="line">5，写入数据块</span><br></pre></td></tr></table></figure>

<p>创建一个文件的工作量比向已存在的文件中写数据更大，要创建一个文件，文件系统不仅要分别配一个 inode，还要在包含新文件的目录中分配空间，这样的 I&#x2F;O 总量非常大</p>
<h3 id="缓存和缓冲"><a href="#缓存和缓冲" class="headerlink" title="缓存和缓冲"></a>缓存和缓冲</h3><p><strong>减少读的 I&#x2F;O：缓存</strong></p>
<p>读取和写入文件是昂贵的，会导致磁盘有很多 I&#x2F;O，因此降低性能，为了弥补这个问题，大多数文件系统积极使用系统内存 DRAM 来缓存重要的块</p>
<p>想象一个有缓存的文件打开的例子，第一次可能引起很多 I&#x2F;O，来读取目录中的 inode 和数据，但是随后打开该文件，大部分会命中缓存，因此不需要或只进行少量 I&#x2F;O</p>
<p><strong>减少写的 I&#x2F;O：缓冲</strong><br>尽管可以通过足够大的缓存来避免读取&#x2F;O，但写入操作必须进入磁盘，高速缓存不能减少写流量，可以通过写缓冲来弥补，首先，通过延迟写入，文件系统可以将零碎的一些更新积攒成一批，放入一组较小的 I&#x2F;O 中，通过减少写 I&#x2F;O 的次数来减少写 I&#x2F;O 引起的问题</p>
<p>如果一在创建一个文件时，inode 位图被更新，稍后再创建另一个文件时又被更新，则文件系统可以再第一次更新后延迟写入，从而节省一次 I&#x2F;O，其次，通过将一些写入缓冲的内存中，系统可以调度后续的 I&#x2F;O，从而提高性能</p>
<p>由于上述原因，大多数现代文件系统将写入在内存中缓冲 5~30s，这代表了另一种折中，如果系统在更新传递到磁盘之前崩溃，更新就会丢失，但是如果时间延长，则可以通过批处理，调度甚至避免写入来提高性能，而像数据库管理系统这种软件不喜欢这种折中，它会调用 fsync()立刻强制写入磁盘，以保证数据更新不会丢失</p>
<h2 id="第-42-章——崩溃一致性：FSCK-和日志"><a href="#第-42-章——崩溃一致性：FSCK-和日志" class="headerlink" title="第 42 章——崩溃一致性：FSCK 和日志"></a>第 42 章——崩溃一致性：FSCK 和日志</h2><p>文件系统面临的一个主要挑战在于，如何在出现断电（power loss）或系统崩溃（system crash）的情况下，更新持久数据结构。（为崩溃一致性问题（crash-consistency problem）。）</p>
<h3 id="崩溃场景"><a href="#崩溃场景" class="headerlink" title="崩溃场景"></a><strong>崩溃场景</strong></h3><ul>
<li>只将数据块（Db）写入磁盘</li>
<li>只有更新的 inode（I[v2]）写入了磁盘</li>
<li>只有更新后的位图（B [v2]）写入了磁盘</li>
<li>inode（I[v2]）和位图（B[v2]）写入了磁盘，但没有写入数据（Db）</li>
<li>写入了 inode（I[v2]）和数据块（Db），但没有写入位图（B[v2]）</li>
<li>写入了位图（B[v2]）和数据块（Db），但没有写入 inode（I[v2]）</li>
</ul>
<p>在文件系统数据结构中可能存在不一致性。可能有<strong>空间泄露</strong>，可能<strong>将垃圾数据返回给用户</strong>，等等。理想的做法是将文件系统从一个一致状态（在文件被追加之前），原子地（atomically）移动到另一个状态（在 inode、位图和新数据块被写入磁盘之后）。遗憾的是这不容易实现</p>
<h3 id="解决方案-1：文件系统检查程序"><a href="#解决方案-1：文件系统检查程序" class="headerlink" title="解决方案 1：文件系统检查程序"></a>解决方案 1：文件系统检查程序</h3><p>fsck 是一个 UNIX 工具，用于查找这些不一致并修复它们。它在文件系<br>统挂载并可用之前运行（fsck 假定在运行时没有其他文件系统活动正在进行）。</p>
<p>以下是 fsck 的基本总结：<br><strong>超级块</strong>：fsck 首先检查超级块是否合理，主要是进行健全性检查，例如确保文件系统大小大于分配的块数。通常，这些健全性检查的目的是找到一个可疑的（冲突的）超级块。在这种情况下，系统（或管理员）可以决定使用超级块的备用副本。<br><strong>空闲块</strong>：接下来，fsck 扫描 inode、间接块、双重间接块等，以了解当前在文件系统中分配的块。它利用这些知识生成正确版本的分配位图。因此，如果位图和 inode 之间存在任何不一致，则通过信任 inode 内的信息来解决它。对所有 inode 执行相同类型的检查，确保所有看起来像在用的 inode，都在 inode 位图中有标记。<br><strong>inode 状态</strong>：检查每个 inode 是否存在损坏或其他问题。例如，fsck 确保每个分配的 inode 具有有效的类型字段（即常规文件、目录、符号链接等）。如果 inode 字段存在问题，不易修复，则 inode 被认为是可疑的，并被 fsck 清除，inode 位图相应地更新。<br><strong>inode 链接</strong>：fsck 还会验证每个已分配的 inode 的链接数<br><strong>重复</strong>：fsck 还检查重复指针，即两个不同的 inode 引用同一个块的情况。<br><strong>坏块</strong>：在扫描所有指针列表时，还会检查坏块指针。如果指针显然指向超出其有效范围的某个指针，则该指针被认为是“坏的”，例如，它的地址指向大于分区大小的块。在这种情况下，fsck 不能做任何太聪明的事情。它只是从 inode 或间接块中删除（清除）该指针。<br><strong>目录检查</strong>：fsck 对每个目录的内容执行额外的完整性检查，确保“.”和“..”是前面的条目，目录条目中引用的每个 inode 都已分配，并确保整个层次结构中没有目录的引用超过一次。</p>
<p><strong>缺点</strong>：</p>
<ol>
<li>构建有效工作的 fsck 需要复杂的文件系统知识。确保这样的代码在所有情<br>况下都能正常工作可能具有挑战性</li>
<li>它们太慢了。有效但低效</li>
</ol>
<h3 id="解决方案-2：日志（或预写日志）"><a href="#解决方案-2：日志（或预写日志）" class="headerlink" title="解决方案 2：日志（或预写日志）"></a>解决方案 2：日志（或预写日志）</h3><h4 id="数据日志"><a href="#数据日志" class="headerlink" title="数据日志"></a>数据日志</h4><p>基本思路：</p>
<p>更新磁盘时，在覆写结构之前，首先写下一点小注记（在磁盘上的其他地方，在一个众所周知的位置），描述你将要做的事情。写下这个注记就是“预写”部分，我们把它写入一个结构，并组织成“日志”。因此，就有了<strong>预写日志</strong>。</p>
<p>日志功能在更新期间通过将注释写入磁盘增加了一工作量，从而大大减少了恢复期间所需的工作量。</p>
<p><strong>写入日志的文件系统协议</strong></p>
<p>1．<strong>日志写入</strong>：将事务的内容（包括 TxB、元数据和数据）写入日志，等待这些写入完成。<br>2．<strong>日志提交</strong>：将事务提交块（包括 TxE）写入日志，等待写完成，事务被认为已提交（committed）。<br>3．<strong>加检查点</strong>：将更新内容（元数据和数据）写入其最终的磁盘位置。</p>
<p><img src="https://s2.loli.net/2022/01/04/3kWiFytMvcbPpzX.png" alt="一个例子"></p>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a><strong>恢复</strong></h4><p>1、<strong>如果崩溃发生在事务被安全地写入日志之前</strong>：简单地跳过待执行的更新。</p>
<p>2、<strong>如果在事务已提交到日志之后但在加检查点完成之前</strong>：<br>系统引导时，文件系统恢复过程将扫描日志，并查找已提交到磁盘的事务。然后，这些事务被重放（replayed，按顺序），文件系统再次尝试将事务中的块写入它们最终的磁盘位置。<br>这种形式为<strong>重做日志</strong>（redo logging）</p>
<h4 id="批处理日志更新"><a href="#批处理日志更新" class="headerlink" title="批处理日志更新"></a><strong>批处理日志更新</strong></h4><p>一些文件系统不会一次一个地向磁盘提交每个更新。与此不同，可以将所有更新缓冲到全局事务中。</p>
<p>通过缓冲更新，文件系统在许多情况下可以避免对磁盘的过多的写入流量。</p>
<h4 id="使日志有限"><a href="#使日志有限" class="headerlink" title="使日志有限"></a>使日志有限</h4><p>一旦事务被加检查点，文件系统应释放它在日志中占用的空间，允许重用日志空间。</p>
<p>1．<strong>日志写入</strong>：将事务的内容（包括 TxB 和更新内容）写入日志，等待这些写入完成。<br>2．<strong>日志提交</strong>：将事务提交块（包括 TxE）写入日志，等待写完成，事务被认为已提交<br>（committed）。<br>3．<strong>加检查点</strong>：将更新内容写入其最终的磁盘位置。<br>4．<strong>释放</strong>：一段时间后，通过更新日志超级块，在日志中标记该事务为空闲。</p>
<h4 id="元数据日志"><a href="#元数据日志" class="headerlink" title="元数据日志"></a>元数据日志</h4><p><strong>最常用的是有序元数据日志</strong>，它可以减少日志流量，同时仍然保证文件系统元数据和用户数据的合理一致性。</p>
<p>写入数据块的代价通常很昂贵，如何避免两次 IO 写入？</p>
<p>1．<strong>数据写入</strong>：将数据写入最终位置，等待完成（等待是可选的，详见下文）。<br>2．<strong>日志元数据写入</strong>：将开始块和元数据写入日志，等待写入完成。<br>3．<strong>日志提交</strong>：将事务提交块（包括 TxE）写入日志，等待写完成，现在认为事务（包<br>括数据）已提交（committed）。<br>4．<strong>加检查点元数据</strong>：将元数据更新的内容写入文件系统中的最终位置。<br>5．<strong>释放</strong>：稍后，在日志超级块中将事务标记为空闲。<br>通过强制先写入数据，文件系统可以保证指针永远不会指向垃圾。</p>
<h4 id="棘手的情况：块复用"><a href="#棘手的情况：块复用" class="headerlink" title="棘手的情况：块复用"></a>棘手的情况：块复用</h4><p>可以永远不再重复使用块，直到所述块的删除加上检查点，从日志中清除。Linux ext3 的做法是将新类型的记录添加到日志中，称为撤销（revoke）记录。在上面的情况中，删除目录将导致撤销记录被写入日志。在重放日志时，系统首先扫描这样的重新记录。任何此类被撤销的数据都不会被重放，从而避免了上述问题。</p>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ol>
<li><strong>软更新</strong></li>
<li><strong>写时复制（Copy-On-Write，COW）</strong></li>
<li><strong>基于反向指针的一致性</strong></li>
<li><strong>乐观崩溃一致性</strong></li>
</ol>
]]></content>
      <categories>
        <category>The-Operating-System-Notes</category>
      </categories>
      <tags>
        <tag>operating sysytem</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>2.operating-systems-three-easy-pieces answers</title>
    <url>/2021/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AC%A1%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<h1 id="操作系统第三次作业"><a href="#操作系统第三次作业" class="headerlink" title="操作系统第三次作业"></a>操作系统第三次作业</h1><p>201908010224黄雅妮</p>
<h2 id="第15章——地址转换"><a href="#第15章——地址转换" class="headerlink" title="第15章——地址转换"></a>第15章——地址转换</h2><h3 id="15-1"><a href="#15-1" class="headerlink" title="15.1"></a>15.1</h3><p><strong>用种子1、2 和3 运行，并计算进程生成的每个虚拟地址是处于界限内还是界限外?如果在界限内，请计算地址转换。</strong></p>
<p>有效地址为</p>
<p> VA  1: 0x00000105 (decimal:  261)</p>
<p>转换后地址为 PA：0x00000105+ 0x0000363c&#x3D;261+13384&#x3D;   13645</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//种子1</span><br><span class="line">python2 relocation.py -s 1</span><br><span class="line"></span><br><span class="line">ARG seed 1</span><br><span class="line">ARG address space size 1k</span><br><span class="line">ARG phys mem size 16k</span><br><span class="line"></span><br><span class="line">Base-and-Bounds register information:</span><br><span class="line"></span><br><span class="line">  Base   : 0x0000363c (decimal 13884)</span><br><span class="line">  Limit  : 290</span><br><span class="line"></span><br><span class="line">Virtual Address Trace</span><br><span class="line">  VA  0: 0x0000030e (decimal:  782) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  1: 0x00000105 (decimal:  261) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  2: 0x000001fb (decimal:  507) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  3: 0x000001cc (decimal:  460) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  4: 0x0000029b (decimal:  667) --&gt; PA or segmentation violation?</span><br></pre></td></tr></table></figure>

<p><strong>种子    -s 2</strong></p>
<p>以下地址有效</p>
<p>  VA  0: 0x00000039 (decimal:   57)</p>
<p>  VA  1: 0x00000056 (decimal:   86) </p>
<p>转换后地址</p>
<p>PA 0 :0x00000039 + 0x00003ca9 &#x3D;57+15529&#x3D;15586</p>
<p>PA 1:0x00000056 + 0x00003ca9&#x3D;86+15529&#x3D;15615</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nnilk@nnilk-VirtualBox:~/文档/ostep-homework/vm-mechanism$ python2 relocation.py -s 2</span><br><span class="line"></span><br><span class="line">ARG seed 2</span><br><span class="line">ARG address space size 1k</span><br><span class="line">ARG phys mem size 16k</span><br><span class="line"></span><br><span class="line">Base-and-Bounds register information:</span><br><span class="line"></span><br><span class="line">  Base   : 0x00003ca9 (decimal 15529)</span><br><span class="line">  Limit  : 500</span><br><span class="line"></span><br><span class="line">Virtual Address Trace</span><br><span class="line">  VA  0: 0x00000039 (decimal:   57) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  1: 0x00000056 (decimal:   86) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  2: 0x00000357 (decimal:  855) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  3: 0x000002f1 (decimal:  753) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  4: 0x000002ad (decimal:  685) --&gt; PA or segmentation violation?</span><br></pre></td></tr></table></figure>



<p><strong>种子    -s 3</strong></p>
<p>以下地址有效</p>
<p> VA  3: 0x00000043 (decimal:   67)</p>
<p> VA  4: 0x0000000d (decimal:   13)</p>
<p>转换后地址</p>
<p>PA 3: 0x00000043  + 0x00003ca9 &#x3D;67+8916&#x3D;8983</p>
<p>PA 4: 0x0000000d  + 0x00003ca9&#x3D;13+8916&#x3D;8929</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nnilk@nnilk-VirtualBox:~/文档/ostep-homework/vm-mechanism$ python2 relocation.py -s 3</span><br><span class="line"></span><br><span class="line">ARG seed 3</span><br><span class="line">ARG address space size 1k</span><br><span class="line">ARG phys mem size 16k</span><br><span class="line"></span><br><span class="line">Base-and-Bounds register information:</span><br><span class="line"></span><br><span class="line">  Base   : 0x000022d4 (decimal 8916)</span><br><span class="line">  Limit  : 316</span><br><span class="line"></span><br><span class="line">Virtual Address Trace</span><br><span class="line">  VA  0: 0x0000017a (decimal:  378) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  1: 0x0000026a (decimal:  618) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  2: 0x00000280 (decimal:  640) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  3: 0x00000043 (decimal:   67) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  4: 0x0000000d (decimal:   13) --&gt; PA or segmentation violation?</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="15-3"><a href="#15-3" class="headerlink" title="15.3"></a>15.3</h3><p><strong>使用以下标志运行:-s1-n10-1100。可以设置基址寄存器界限的最大值是多少,以便地址空间仍然完全放在物理内存中?</strong></p>
<p>物理内存大小为2^14^ B,要是地址完全放在物理内存中,基址寄存器最大值为 2^14^ - 100 &#x3D; 16284</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nnilk@nnilk-VirtualBox:~/文档/ostep-homework/vm-mechanism$ python2 relocation.py -s 1 -n 10 -l 100</span><br><span class="line"></span><br><span class="line">ARG seed 1</span><br><span class="line">ARG address space size 1k</span><br><span class="line">ARG phys mem size 16k</span><br><span class="line"></span><br><span class="line">Base-and-Bounds register information:</span><br><span class="line"></span><br><span class="line">  Base   : 0x00000899 (decimal 2201)</span><br><span class="line">  Limit  : 100</span><br><span class="line"></span><br><span class="line">Virtual Address Trace</span><br><span class="line">  VA  0: 0x00000363 (decimal:  867) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  1: 0x0000030e (decimal:  782) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  2: 0x00000105 (decimal:  261) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  3: 0x000001fb (decimal:  507) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  4: 0x000001cc (decimal:  460) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  5: 0x0000029b (decimal:  667) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  6: 0x00000327 (decimal:  807) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  7: 0x00000060 (decimal:   96) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  8: 0x0000001d (decimal:   29) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  9: 0x00000357 (decimal:  855) --&gt; PA or segmentation violation?</span><br></pre></td></tr></table></figure>

<h2 id="第16章——分段"><a href="#第16章——分段" class="headerlink" title="第16章——分段"></a>第16章——分段</h2><h3 id="16-1"><a href="#16-1" class="headerlink" title="16.1"></a>16.1</h3><p><strong>1．先让我们用一个小地址空间来转换一些地址。这里有一组简单的参数和几个不同的</strong><br><strong>随机种子。你可以转换这些地址吗？</strong><br><strong>segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 0</strong></p>
<p>运行结果如下，转换后每个VA所在段计算如下</p>
<p>VA  0: 0x0000006c (decimal:  108) –&gt; sPA(段1)(物理地址492)<br>VA  1: 0x00000061 (decimal:   97) –&gt; segmentation violation(段1)<br>VA  2: 0x00000035 (decimal:   53) –&gt; segmentation violation(段0)<br>VA  3: 0x00000021 (decimal:   33) –&gt; segmentation violation(段0)<br>VA  4: 0x00000041 (decimal:   65) –&gt; segmentation violation(段1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.种子 s -0</span><br><span class="line">$ python2 segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 0</span><br><span class="line"></span><br><span class="line">ARG seed 0</span><br><span class="line">ARG address space size 128</span><br><span class="line">ARG phys mem size 512</span><br><span class="line"></span><br><span class="line">Segment register information:</span><br><span class="line"></span><br><span class="line">  Segment 0 base  (grows positive) : 0x00000000 (decimal 0)</span><br><span class="line">  Segment 0 limit                  : 20</span><br><span class="line"></span><br><span class="line">  Segment 1 base  (grows negative) : 0x00000200 (decimal 512)</span><br><span class="line">  Segment 1 limit                  : 20</span><br><span class="line"></span><br><span class="line">Virtual Address Trace</span><br><span class="line">  VA  0: 0x0000006c (decimal:  108) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  1: 0x00000061 (decimal:   97) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  2: 0x00000035 (decimal:   53) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  3: 0x00000021 (decimal:   33) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  4: 0x00000041 (decimal:   65) --&gt; PA or segmentation violation?</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 1</strong></p>
<p>运行结果如下，转换后每个VA所在段计算如下</p>
<p>  VA  0: 0x00000011 (decimal:   17) –&gt; PA(段0)(物理地址:17)<br>  VA  1: 0x0000006c (decimal:  108) –&gt; PA(段1)(物理地址:492)<br>  VA  2: 0x00000061 (decimal:   97) –&gt; segmentation violation(段1)<br>  VA  3: 0x00000020 (decimal:   32) –&gt; segmentation violation(段0)<br>  VA  4: 0x0000003f (decimal:   63) –&gt; segmentation violation(段0)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python2 segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 1</span><br><span class="line">ARG seed 1</span><br><span class="line">ARG address space size 128</span><br><span class="line">ARG phys mem size 512</span><br><span class="line"></span><br><span class="line">Segment register information:</span><br><span class="line"></span><br><span class="line">  Segment 0 base  (grows positive) : 0x00000000 (decimal 0)</span><br><span class="line">  Segment 0 limit                  : 20</span><br><span class="line"></span><br><span class="line">  Segment 1 base  (grows negative) : 0x00000200 (decimal 512)</span><br><span class="line">  Segment 1 limit                  : 20</span><br><span class="line"></span><br><span class="line">Virtual Address Trace</span><br><span class="line">  VA  0: 0x00000011 (decimal:   17) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  1: 0x0000006c (decimal:  108) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  2: 0x00000061 (decimal:   97) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  3: 0x00000020 (decimal:   32) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  4: 0x0000003f (decimal:   63) --&gt; PA or segmentation violation?</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 2</strong></p>
<p>运行结果如下，转换后每个VA所在段</p>
<p>Virtual Address Trace：<br>  VA  0: 0x0000007a (decimal:  122) –&gt; PA(段1)(物理地址:506)<br>  VA  1: 0x00000079 (decimal:  121) –&gt; PA(段1)(物理地址:505)<br>  VA  2: 0x00000007 (decimal:    7) –&gt; PA(段0)(物理地址:7)<br>  VA  3: 0x0000000a (decimal:   10) –&gt; PA(段0)(物理地址:10)<br>  VA  4: 0x0000006a (decimal:  106) –&gt; segmentation violation(段1)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python2 segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 2</span><br><span class="line">ARG seed 2</span><br><span class="line">ARG address space size 128</span><br><span class="line">ARG phys mem size 512</span><br><span class="line"></span><br><span class="line">Segment register information:</span><br><span class="line"></span><br><span class="line">  Segment 0 base  (grows positive) : 0x00000000 (decimal 0)</span><br><span class="line">  Segment 0 limit                  : 20</span><br><span class="line"></span><br><span class="line">  Segment 1 base  (grows negative) : 0x00000200 (decimal 512)</span><br><span class="line">  Segment 1 limit                  : 20</span><br><span class="line"></span><br><span class="line">Virtual Address Trace</span><br><span class="line">  VA  0: 0x0000007a (decimal:  122) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  1: 0x00000079 (decimal:  121) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  2: 0x00000007 (decimal:    7) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  3: 0x0000000a (decimal:   10) --&gt; PA or segmentation violation?</span><br><span class="line">  VA  4: 0x0000006a (decimal:  106) --&gt; PA or segmentation violation?</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="16-2"><a href="#16-2" class="headerlink" title="16.2"></a>16.2</h3><p><strong>现在，让我们看看是否理解了这个构建的小地址空间（使用上面问题的参数）。段0中最高的合法虚拟地址是什么？段1 中最低的合法虚拟地址是什么？在整个地址空间中，最低和最高的非法地址是什么？最后，如何运行带有-A 标志的segmentation.py 来测试你是否正确？</strong></p>
<p>段0 中最高的合法虚拟地址 19,</p>
<p>段 1 中最低的合法虚拟地址 108</p>
<p>在整个地址空间中,最低和最高的非法地址是 20,107</p>
<p>运行<code>python2 segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 1 -A 19,108,20,107 -c</code></p>
<p>可以看到，虚拟地址19,108分别在段0和段1中是合法地址，虚拟地址20,107分别在段0和段1中是非法地址，验证正确</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ python2 segmentation.py -a <span class="number">128</span> -p <span class="number">512</span> -b <span class="number">0</span> -l <span class="number">20</span> -B <span class="number">512</span> -L <span class="number">20</span> -s <span class="number">1</span> -A </span><br><span class="line"><span class="number">19</span>,<span class="number">108</span>,<span class="number">20</span>,<span class="number">107</span> -c</span><br><span class="line">ARG seed <span class="number">1</span></span><br><span class="line">ARG address space size <span class="number">128</span></span><br><span class="line">ARG phys mem size <span class="number">512</span></span><br><span class="line"></span><br><span class="line">Segment <span class="keyword">register</span> information:</span><br><span class="line"></span><br><span class="line">  Segment <span class="number">0</span> base  (grows positive) : <span class="number">0x00000000</span> (decimal <span class="number">0</span>)</span><br><span class="line">  Segment <span class="number">0</span> limit                  : <span class="number">20</span></span><br><span class="line"></span><br><span class="line">  Segment <span class="number">1</span> base  (grows negative) : <span class="number">0x00000200</span> (decimal <span class="number">512</span>)</span><br><span class="line">  Segment <span class="number">1</span> limit                  : <span class="number">20</span></span><br><span class="line"></span><br><span class="line">Virtual Address Trace</span><br><span class="line">  VA  <span class="number">0</span>: <span class="number">0x00000013</span> (decimal:   <span class="number">19</span>) --&gt; VALID in SEG0: <span class="number">0x00000013</span> (decimal:   <span class="number">19</span>)</span><br><span class="line">  VA  <span class="number">1</span>: <span class="number">0x0000006c</span> (decimal:  <span class="number">108</span>) --&gt; VALID in SEG1: <span class="number">0x000001ec</span> (decimal:  <span class="number">492</span>)</span><br><span class="line">  VA  <span class="number">2</span>: <span class="number">0x00000014</span> (decimal:   <span class="number">20</span>) --&gt; SEGMENTATION <span class="title function_">VIOLATION</span> <span class="params">(SEG0)</span></span><br><span class="line">  VA  3: 0<span class="title function_">x0000006b</span> <span class="params">(decimal:  <span class="number">107</span>)</span> --&gt; SEGMENTATION <span class="title function_">VIOLATION</span> <span class="params">(SEG1)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="16-3"><a href="#16-3" class="headerlink" title="16.3"></a>16.3</h3><p><strong>假设我们在一个128 字节的物理内存中有一个很小的16 字节地址空间。你会设置什么样的基址和界限，以便让模拟器为指定的地址流生成以下转换结果：有效，有效，违规，违反，有效，有效？假设用以下参数：</strong><br><strong>segmentation.py -a 16 -p 128 -A 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15</strong><br><strong>–b0 ? –l0 ? –b1 ? –l1 ?</strong></p>
<p><em>注: 原书问题为:valid, valid, violation, …, violation, valid, valid,即要求 0,1,14,15 有效,其余无效</em></p>
<p>段0只有虚拟地址为0和1有效，段1只有虚拟地址14,15有效，所以</p>
<p>L0 &#x3D; L1 &#x3D; 2</p>
<p>Base 0 &#x3D; 0</p>
<p>Base 1 &#x3D; 15</p>
<p>运行<code>python2 segmentation.py -a 16 -p 128 -A 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 --b0 0 --l0 2 --b1 15 --l1 2 -c</code></p>
<p>可以看到只有虚拟地址0,1,14,15有效，验证正确</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">python2 segmentation.py -a <span class="number">16</span> -p <span class="number">128</span> -A <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span> --b0 <span class="number">0</span> --l0 <span class="number">2</span> --b1 <span class="number">15</span> --l1 <span class="number">2</span> -c</span><br><span class="line">ARG seed <span class="number">0</span></span><br><span class="line">ARG address space size <span class="number">16</span></span><br><span class="line">ARG phys mem size <span class="number">128</span></span><br><span class="line"></span><br><span class="line">Segment <span class="keyword">register</span> information:</span><br><span class="line"></span><br><span class="line">  Segment <span class="number">0</span> base  (grows positive) : <span class="number">0x00000000</span> (decimal <span class="number">0</span>)</span><br><span class="line">  Segment <span class="number">0</span> limit                  : <span class="number">2</span></span><br><span class="line"></span><br><span class="line">  Segment <span class="number">1</span> base  (grows negative) : <span class="number">0x0000000f</span> (decimal <span class="number">15</span>)</span><br><span class="line">  Segment <span class="number">1</span> limit                  : <span class="number">2</span></span><br><span class="line"></span><br><span class="line">Virtual Address Trace</span><br><span class="line">  VA  <span class="number">0</span>: <span class="number">0x00000000</span> (decimal:    <span class="number">0</span>) --&gt; VALID in SEG0: <span class="number">0x00000000</span> (decimal:    <span class="number">0</span>)</span><br><span class="line">  VA  <span class="number">1</span>: <span class="number">0x00000001</span> (decimal:    <span class="number">1</span>) --&gt; VALID in SEG0: <span class="number">0x00000001</span> (decimal:    <span class="number">1</span>)</span><br><span class="line">  VA  <span class="number">2</span>: <span class="number">0x00000002</span> (decimal:    <span class="number">2</span>) --&gt; SEGMENTATION <span class="title function_">VIOLATION</span> <span class="params">(SEG0)</span></span><br><span class="line">  VA  3: 0<span class="title function_">x00000003</span> <span class="params">(decimal:    <span class="number">3</span>)</span> --&gt; SEGMENTATION <span class="title function_">VIOLATION</span> <span class="params">(SEG0)</span></span><br><span class="line">  VA  4: 0<span class="title function_">x00000004</span> <span class="params">(decimal:    <span class="number">4</span>)</span> --&gt; SEGMENTATION <span class="title function_">VIOLATION</span> <span class="params">(SEG0)</span></span><br><span class="line">  VA  5: 0<span class="title function_">x00000005</span> <span class="params">(decimal:    <span class="number">5</span>)</span> --&gt; SEGMENTATION <span class="title function_">VIOLATION</span> <span class="params">(SEG0)</span></span><br><span class="line">  VA  6: 0<span class="title function_">x00000006</span> <span class="params">(decimal:    <span class="number">6</span>)</span> --&gt; SEGMENTATION <span class="title function_">VIOLATION</span> <span class="params">(SEG0)</span></span><br><span class="line">  VA  7: 0<span class="title function_">x00000007</span> <span class="params">(decimal:    <span class="number">7</span>)</span> --&gt; SEGMENTATION <span class="title function_">VIOLATION</span> <span class="params">(SEG0)</span></span><br><span class="line">  VA  8: 0<span class="title function_">x00000008</span> <span class="params">(decimal:    <span class="number">8</span>)</span> --&gt; SEGMENTATION <span class="title function_">VIOLATION</span> <span class="params">(SEG1)</span></span><br><span class="line">  VA  9: 0<span class="title function_">x00000009</span> <span class="params">(decimal:    <span class="number">9</span>)</span> --&gt; SEGMENTATION <span class="title function_">VIOLATION</span> <span class="params">(SEG1)</span></span><br><span class="line">  VA 10: 0<span class="title function_">x0000000a</span> <span class="params">(decimal:   <span class="number">10</span>)</span> --&gt; SEGMENTATION <span class="title function_">VIOLATION</span> <span class="params">(SEG1)</span></span><br><span class="line">  VA 11: 0<span class="title function_">x0000000b</span> <span class="params">(decimal:   <span class="number">11</span>)</span> --&gt; SEGMENTATION <span class="title function_">VIOLATION</span> <span class="params">(SEG1)</span></span><br><span class="line">  VA 12: 0<span class="title function_">x0000000c</span> <span class="params">(decimal:   <span class="number">12</span>)</span> --&gt; SEGMENTATION <span class="title function_">VIOLATION</span> <span class="params">(SEG1)</span></span><br><span class="line">  VA 13: 0<span class="title function_">x0000000d</span> <span class="params">(decimal:   <span class="number">13</span>)</span> --&gt; SEGMENTATION <span class="title function_">VIOLATION</span> <span class="params">(SEG1)</span></span><br><span class="line">  VA 14: 0<span class="title function_">x0000000e</span> <span class="params">(decimal:   <span class="number">14</span>)</span> --&gt; VALID in SEG1: 0<span class="title function_">x0000000d</span> <span class="params">(decimal:   <span class="number">13</span>)</span></span><br><span class="line">  VA 15: 0<span class="title function_">x0000000f</span> <span class="params">(decimal:   <span class="number">15</span>)</span> --&gt; VALID in SEG1: 0<span class="title function_">x0000000e</span> <span class="params">(decimal:   <span class="number">14</span>)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第17章——空闲内存管理"><a href="#第17章——空闲内存管理" class="headerlink" title="第17章——空闲内存管理"></a>第17章——空闲内存管理</h2><h3 id="17-1"><a href="#17-1" class="headerlink" title="17.1"></a><strong>17.1</strong></h3><p><strong>首先运行flag -n 10 -H 0 -p BEST -s 0 来产生一些随机分配和释放。你能预测malloc()&#x2F;free()会返回什么吗？你可以在每次请求后猜测空闲列表的状态吗？随着时间的推移，你对空闲列表有什么发现？</strong></p>
<p>1.ptr[0] &#x3D; Alloc(3) </p>
<p>返回ptr[0]的起始地址空间1000</p>
<p>空闲链表当前只有一块size&#x3D;97的空闲块</p>
<p>2.free(ptr[0])</p>
<p>返回0</p>
<p>空闲链表当前有一块size&#x3D;3和size&#x3D;97的空闲块</p>
<p>3.ptr[1] &#x3D; Alloc(5)</p>
<p>返回ptr[1]的起始地址空间1003</p>
<p>空闲链表当前有一块size&#x3D;3和size&#x3D;92的空闲块</p>
<p>4.free(ptr[1]）</p>
<p>返回0</p>
<p>空闲链表当前有一块size&#x3D;3，一块size&#x3D;5和size&#x3D;92的空闲块</p>
<p>5.ptr[2] &#x3D; Alloc(8)</p>
<p>返回ptr[2]的起始地址空间1011</p>
<p>空闲链表当前有三个空闲块，size1 &#x3D; 3，size2 &#x3D;5 ，size3 &#x3D; 84</p>
<p>6.free(ptr[2]）</p>
<p>返回0</p>
<p>空闲链表当前有4个空闲块，size1 &#x3D; 3，size2 &#x3D;5 ，size3 &#x3D;8，size4 &#x3D; 84</p>
<p>7.ptr[3] &#x3D; Alloc(8)</p>
<p>返回ptr[3]的起始地址空间1016</p>
<p>空闲链表当前有3个空闲块，size1 &#x3D; 3，size2 &#x3D;5 ，size4 &#x3D;84</p>
<p>8.free(ptr[3]）</p>
<p>返回0</p>
<p>空闲链表当前有4个空闲块，size1 &#x3D; 3，size2 &#x3D;5 ，size3 &#x3D;8，size4 &#x3D; 84</p>
<p>9.ptr[4] &#x3D; Alloc(2)</p>
<p>返回1000</p>
<p>空闲链表当前有4个空闲块，size1 &#x3D;1，size2 &#x3D;5 ，size3 &#x3D;8，size4 &#x3D; 84</p>
<p>10.ptr[5] &#x3D; Alloc(7)</p>
<p>返回1008</p>
<p>空闲链表当前有4个空闲块，size1 &#x3D;1，size2 &#x3D;5 ，size3 &#x3D;1，size4 &#x3D; 84</p>
<p>可以看出返回malloc和free，申请释放内存，空闲内存链表的空闲块增多，内存碎片在家</p>
<p>运行<code>python2 malloc.py -n 10 -H 0 -p BEST -s 0 -c</code>，验证正确</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ python2 <span class="built_in">malloc</span>.py -n <span class="number">10</span> -H <span class="number">0</span> -p BEST -s <span class="number">0</span> -c</span><br><span class="line">seed <span class="number">0</span></span><br><span class="line">size <span class="number">100</span></span><br><span class="line">baseAddr <span class="number">1000</span></span><br><span class="line">headerSize <span class="number">0</span></span><br><span class="line">alignment <span class="number">-1</span></span><br><span class="line">policy BEST</span><br><span class="line">listOrder ADDRSORT</span><br><span class="line">coalesce False</span><br><span class="line">numOps <span class="number">10</span></span><br><span class="line">range <span class="number">10</span></span><br><span class="line">percentAlloc <span class="number">50</span></span><br><span class="line">allocList </span><br><span class="line">compute True</span><br><span class="line"></span><br><span class="line">ptr[<span class="number">0</span>] = Alloc(<span class="number">3</span>)  returned <span class="number">1000</span> (searched <span class="number">1</span> elements)</span><br><span class="line">Free List [ Size <span class="number">1</span> ]:  [ addr:<span class="number">1003</span> sz:<span class="number">97</span> ] </span><br><span class="line"></span><br><span class="line">Free(ptr[<span class="number">0</span>]) returned <span class="number">0</span></span><br><span class="line">Free List [ Size <span class="number">2</span> ]:  [ addr:<span class="number">1000</span> sz:<span class="number">3</span> ] [ addr:<span class="number">1003</span> sz:<span class="number">97</span> ] </span><br><span class="line"></span><br><span class="line">ptr[<span class="number">1</span>] = Alloc(<span class="number">5</span>)  returned <span class="number">1003</span> (searched <span class="number">2</span> elements)</span><br><span class="line">Free List [ Size <span class="number">2</span> ]:  [ addr:<span class="number">1000</span> sz:<span class="number">3</span> ] [ addr:<span class="number">1008</span> sz:<span class="number">92</span> ] </span><br><span class="line"></span><br><span class="line">Free(ptr[<span class="number">1</span>]) returned <span class="number">0</span></span><br><span class="line">Free List [ Size <span class="number">3</span> ]:  [ addr:<span class="number">1000</span> sz:<span class="number">3</span> ] [ addr:<span class="number">1003</span> sz:<span class="number">5</span> ] [ addr:<span class="number">1008</span> sz:<span class="number">92</span> ] </span><br><span class="line"></span><br><span class="line">ptr[<span class="number">2</span>] = Alloc(<span class="number">8</span>)  returned <span class="number">1008</span> (searched <span class="number">3</span> elements)</span><br><span class="line">Free List [ Size <span class="number">3</span> ]:  [ addr:<span class="number">1000</span> sz:<span class="number">3</span> ] [ addr:<span class="number">1003</span> sz:<span class="number">5</span> ] [ addr:<span class="number">1016</span> sz:<span class="number">84</span> ] </span><br><span class="line"></span><br><span class="line">Free(ptr[<span class="number">2</span>]) returned <span class="number">0</span></span><br><span class="line">Free List [ Size <span class="number">4</span> ]:  [ addr:<span class="number">1000</span> sz:<span class="number">3</span> ] [ addr:<span class="number">1003</span> sz:<span class="number">5</span> ] [ addr:<span class="number">1008</span> sz:<span class="number">8</span> ] [ addr:<span class="number">1016</span> sz:<span class="number">84</span> ] </span><br><span class="line"></span><br><span class="line">ptr[<span class="number">3</span>] = Alloc(<span class="number">8</span>)  returned <span class="number">1008</span> (searched <span class="number">4</span> elements)</span><br><span class="line">Free List [ Size <span class="number">3</span> ]:  [ addr:<span class="number">1000</span> sz:<span class="number">3</span> ] [ addr:<span class="number">1003</span> sz:<span class="number">5</span> ] [ addr:<span class="number">1016</span> sz:<span class="number">84</span> ] </span><br><span class="line"></span><br><span class="line">Free(ptr[<span class="number">3</span>]) returned <span class="number">0</span></span><br><span class="line">Free List [ Size <span class="number">4</span> ]:  [ addr:<span class="number">1000</span> sz:<span class="number">3</span> ] [ addr:<span class="number">1003</span> sz:<span class="number">5</span> ] [ addr:<span class="number">1008</span> sz:<span class="number">8</span> ] [ addr:<span class="number">1016</span> sz:<span class="number">84</span> ] </span><br><span class="line"></span><br><span class="line">ptr[<span class="number">4</span>] = Alloc(<span class="number">2</span>)  returned <span class="number">1000</span> (searched <span class="number">4</span> elements)</span><br><span class="line">Free List [ Size <span class="number">4</span> ]:  [ addr:<span class="number">1002</span> sz:<span class="number">1</span> ] [ addr:<span class="number">1003</span> sz:<span class="number">5</span> ] [ addr:<span class="number">1008</span> sz:<span class="number">8</span> ] [ addr:<span class="number">1016</span> sz:<span class="number">84</span> ] </span><br><span class="line"></span><br><span class="line">ptr[<span class="number">5</span>] = Alloc(<span class="number">7</span>)  returned <span class="number">1008</span> (searched <span class="number">4</span> elements)</span><br><span class="line">Free List [ Size <span class="number">4</span> ]:  [ addr:<span class="number">1002</span> sz:<span class="number">1</span> ] [ addr:<span class="number">1003</span> sz:<span class="number">5</span> ] [ addr:<span class="number">1015</span> sz:<span class="number">1</span> ] [ addr:<span class="number">1016</span> sz:<span class="number">84</span> ] </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="17-3"><a href="#17-3" class="headerlink" title="17.3"></a>17.3</h3><p><strong>如果使用首次匹配（-p FIRST）会如何？使用首次匹配时，什么变快了？</strong></p>
<p>首次匹配（first fit）找到第一个足够大的块，将请求的空间返回给用户。，有速度优势。</p>
<p>运行<code>python2 malloc.py -n 10 -H 0 -p FIRST -s 0 -c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">python2 <span class="built_in">malloc</span>.py -n <span class="number">10</span> -H <span class="number">0</span> -p FIRST -s <span class="number">0</span> -c</span><br><span class="line">seed <span class="number">0</span></span><br><span class="line">size <span class="number">100</span></span><br><span class="line">baseAddr <span class="number">1000</span></span><br><span class="line">headerSize <span class="number">0</span></span><br><span class="line">alignment <span class="number">-1</span></span><br><span class="line">policy FIRST</span><br><span class="line">listOrder ADDRSORT</span><br><span class="line">coalesce False</span><br><span class="line">numOps <span class="number">10</span></span><br><span class="line">range <span class="number">10</span></span><br><span class="line">percentAlloc <span class="number">50</span></span><br><span class="line">allocList </span><br><span class="line">compute True</span><br><span class="line"></span><br><span class="line">ptr[<span class="number">0</span>] = Alloc(<span class="number">3</span>)  returned <span class="number">1000</span> (searched <span class="number">1</span> elements)</span><br><span class="line">Free List [ Size <span class="number">1</span> ]:  [ addr:<span class="number">1003</span> sz:<span class="number">97</span> ] </span><br><span class="line"></span><br><span class="line">Free(ptr[<span class="number">0</span>]) returned <span class="number">0</span></span><br><span class="line">Free List [ Size <span class="number">2</span> ]:  [ addr:<span class="number">1000</span> sz:<span class="number">3</span> ] [ addr:<span class="number">1003</span> sz:<span class="number">97</span> ] </span><br><span class="line"></span><br><span class="line">ptr[<span class="number">1</span>] = Alloc(<span class="number">5</span>)  returned <span class="number">1003</span> (searched <span class="number">2</span> elements)</span><br><span class="line">Free List [ Size <span class="number">2</span> ]:  [ addr:<span class="number">1000</span> sz:<span class="number">3</span> ] [ addr:<span class="number">1008</span> sz:<span class="number">92</span> ] </span><br><span class="line"></span><br><span class="line">Free(ptr[<span class="number">1</span>]) returned <span class="number">0</span></span><br><span class="line">Free List [ Size <span class="number">3</span> ]:  [ addr:<span class="number">1000</span> sz:<span class="number">3</span> ] [ addr:<span class="number">1003</span> sz:<span class="number">5</span> ] [ addr:<span class="number">1008</span> sz:<span class="number">92</span> ] </span><br><span class="line"></span><br><span class="line">ptr[<span class="number">2</span>] = Alloc(<span class="number">8</span>)  returned <span class="number">1008</span> (searched <span class="number">3</span> elements)</span><br><span class="line">Free List [ Size <span class="number">3</span> ]:  [ addr:<span class="number">1000</span> sz:<span class="number">3</span> ] [ addr:<span class="number">1003</span> sz:<span class="number">5</span> ] [ addr:<span class="number">1016</span> sz:<span class="number">84</span> ] </span><br><span class="line"></span><br><span class="line">Free(ptr[<span class="number">2</span>]) returned <span class="number">0</span></span><br><span class="line">Free List [ Size <span class="number">4</span> ]:  [ addr:<span class="number">1000</span> sz:<span class="number">3</span> ] [ addr:<span class="number">1003</span> sz:<span class="number">5</span> ] [ addr:<span class="number">1008</span> sz:<span class="number">8</span> ] [ addr:<span class="number">1016</span> sz:<span class="number">84</span> ] </span><br><span class="line"></span><br><span class="line">ptr[<span class="number">3</span>] = Alloc(<span class="number">8</span>)  returned <span class="number">1008</span> (searched <span class="number">3</span> elements)</span><br><span class="line">Free List [ Size <span class="number">3</span> ]:  [ addr:<span class="number">1000</span> sz:<span class="number">3</span> ] [ addr:<span class="number">1003</span> sz:<span class="number">5</span> ] [ addr:<span class="number">1016</span> sz:<span class="number">84</span> ] </span><br><span class="line"></span><br><span class="line">Free(ptr[<span class="number">3</span>]) returned <span class="number">0</span></span><br><span class="line">Free List [ Size <span class="number">4</span> ]:  [ addr:<span class="number">1000</span> sz:<span class="number">3</span> ] [ addr:<span class="number">1003</span> sz:<span class="number">5</span> ] [ addr:<span class="number">1008</span> sz:<span class="number">8</span> ] [ addr:<span class="number">1016</span> sz:<span class="number">84</span> ] </span><br><span class="line"></span><br><span class="line">ptr[<span class="number">4</span>] = Alloc(<span class="number">2</span>)  returned <span class="number">1000</span> (searched <span class="number">1</span> elements)</span><br><span class="line">Free List [ Size <span class="number">4</span> ]:  [ addr:<span class="number">1002</span> sz:<span class="number">1</span> ] [ addr:<span class="number">1003</span> sz:<span class="number">5</span> ] [ addr:<span class="number">1008</span> sz:<span class="number">8</span> ] [ addr:<span class="number">1016</span> sz:<span class="number">84</span> ] </span><br><span class="line"></span><br><span class="line">ptr[<span class="number">5</span>] = Alloc(<span class="number">7</span>)  returned <span class="number">1008</span> (searched <span class="number">3</span> elements)</span><br><span class="line">Free List [ Size <span class="number">4</span> ]:  [ addr:<span class="number">1002</span> sz:<span class="number">1</span> ] [ addr:<span class="number">1003</span> sz:<span class="number">5</span> ] [ addr:<span class="number">1015</span> sz:<span class="number">1</span> ] [ addr:<span class="number">1016</span> sz:<span class="number">84</span> ] </span><br></pre></td></tr></table></figure>

<h3 id="17-4"><a href="#17-4" class="headerlink" title="17.4"></a>17.4</h3><p><strong>对于上述问题，列表在保持有序时，可能会影响某些策略找到空闲位置所需的时间。使用不同的空闲列表排序（-l ADDRSORT，-l SIZESORT +，-l SIZESORT-）查看策略和列表排序如何相互影响。</strong></p>
<p>对于这三种排序方式，bestfit策略的alloc运行速度都不会有变化。</p>
<p>按照空闲块大小递减排序worstfit和firstfit的alloc运行速度会提升。</p>
<p>三种排序方式在 free 时会变慢,因为插入空闲块时需要遍历空闲列表,来达成某种排序方式,</p>
<p>默认按照地址排序</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">python2 malloc.py -n 10 -H 0 -p BEST -s 0 -l ADDRSORT</span><br></pre></td></tr></table></figure>

<p>按照空闲块大小递增排序:</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">python2 malloc.py -n 10 -H 0 -p WORST -s 0 -l SIZESORT +</span><br></pre></td></tr></table></figure>

<p>按照空闲块大小递减排序，该方式会让最差适应算法搜索更快</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">python2 malloc.py -n 10 -H 0 -p WORST -s 0 -l SIZESORT -</span><br></pre></td></tr></table></figure>

<h2 id="第18章——分页"><a href="#第18章——分页" class="headerlink" title="第18章——分页"></a>第18章——分页</h2><h3 id="18-1"><a href="#18-1" class="headerlink" title="18.1"></a>18.1</h3><p><strong>在做地址转换之前，让我们用模拟器来研究线性页表在给定不同参数的情况下如何改变大小。在不同参数变化时，计算线性页表的大小。一些建议输入如下，通过使用-v 标志，你可以看到填充了多少个页表项。首先，要理解线性页表大小如何随着地址空间的增长而变化：</strong><br><strong><code>paging-linear-translate.py -P 1k -a 1m -p 512m -v -n 0</code></strong><br><strong><code>paging-linear-translate.py -P 1k -a 2m -p 512m -v -n 0</code></strong><br><strong><code>paging-linear-translate.py -P 1k -a 4m -p 512m -v -n 0</code></strong><br><strong>然后，理解线性页面大小如何随页大小的增长而变化：</strong><br><strong><code>paging-linear-translate.py -P 1k -a 1m -p 512m -v -n 0</code></strong><br><strong><code>paging-linear-translate.py -P 2k -a 1m -p 512m -v -n 0</code></strong><br><strong><code>paging-linear-translate.py -P 4k -a 1m -p 512m -v -n 0</code></strong><br><strong>在运行这些命令之前，请试着想想预期的趋势。页表大小如何随地址空间的增长而改变？随着页大小的增长呢？为什么一般来说，我们不应该使用很大的页呢？</strong></p>
<p>Q1：页表大小如何随地址空间的增长而改变？随着页大小的增长呢？</p>
<p>linear page table size&#x3D;addr size &#x2F;page size</p>
<p>所有线性页面大小随地址空间增大而增大，随页面大小增大而减小。地址空间增长，页表大小也会增长；</p>
<p>如，**<code>paging-linear-translate.py -P 1k -a 1m -p 512m -v -n 0</code>**，linear page table size&#x3D;1m&#x2F;1k&#x3D;1024</p>
<p>Q2：为什么一般来说，我们不应该使用很大的页呢？</p>
<p>过大的页会造成空间浪费</p>
<h3 id="18-2"><a href="#18-2" class="headerlink" title="18.2"></a>18.2</h3><p><strong>现在让我们做一些地址转换。从一些小例子开始，使用-u 标志更改分配给地址空间</strong><br><strong>的页数。例如：</strong><br><strong><code>paging-linear-translate.py -P 1k -a 16k -p 32k -v -u 0</code></strong><br><strong><code>paging-linear-translate.py -P 1k -a 16k -p 32k -v -u 25</code></strong><br><strong><code>paging-linear-translate.py -P 1k -a 16k -p 32k -v -u 50</code></strong><br><strong><code>paging-linear-translate.py -P 1k -a 16k -p 32k -v -u 75</code></strong><br><strong><code>paging-linear-translate.py -P 1k -a 16k -p 32k -v -u 100</code></strong><br><strong>如果增加每个地址空间中的页的百分比，会发生什么？</strong></p>
<p>依次运行以上案例，可以发现，页表中的有效页增多</p>
<p><code>paging-linear-translate.py -P 1k -a 16k -p 32k -v -u 0</code>（0个有效页表项）<br><code>paging-linear-translate.py -P 1k -a 16k -p 32k -v -u 25</code>（5个有效页表项）<br><code>paging-linear-translate.py -P 1k -a 16k -p 32k -v -u 50</code>（8个有效页表项）<br><code>paging-linear-translate.py -P 1k -a 16k -p 32k -v -u 75</code>（15个有效页表项）<br><code>paging-linear-translate.py -P 1k -a 16k -p 32k -v -u 100</code>（15个有效页表项）</p>
<h3 id="18-3"><a href="#18-3" class="headerlink" title="18.3"></a>18.3</h3><p><strong>现在让我们尝试一些不同的随机种子，以及一些不同的（有时相当疯狂的）地址空</strong><br><strong>间参数：</strong><br><strong>paging-linear-translate.py -P 8 -a 32 -p 1024 -v -s 1</strong><br><strong>paging-linear-translate.py -P 8k -a 32k -p 1m -v -s 2</strong><br><strong>paging-linear-translate.py -P 1m -a 256m -p 512m -v -s 3</strong><br><strong>哪些参数组合是不现实的？为什么？</strong></p>
<p>第三个页太大，（页面默认大小为4KB）导致太多空间被浪费</p>
<h2 id="第20章——分页：较小的表"><a href="#第20章——分页：较小的表" class="headerlink" title="第20章——分页：较小的表"></a>第20章——分页：较小的表</h2><h3 id="20-1"><a href="#20-1" class="headerlink" title="20.1"></a>20.1</h3><p><strong>对于线性页表，你需要一个寄存器来定位页表，假设硬件在TLB 未命中时进行查找。你需要多少个寄存器才能找到两级页表？三级页表呢？</strong></p>
<p>不论是二级页表还是三级页表，都只需要一个寄存器就够</p>
<h3 id="20-2"><a href="#20-2" class="headerlink" title="20.2"></a>20.2</h3><p><strong>使用模拟器对随机种子0、1 和2 执行翻译，并使用-c 标志检查你的答案。需要多少内存引用来执行每次查找？</strong></p>
<p>分别执行命令行</p>
<p><code>python2 paging-multilevel-translate.py -s 0</code></p>
<p><code>python2 paging-multilevel-translate.py -s 1</code></p>
<p><code>python2 paging-multilevel-translate.py -s 2</code></p>
<p>从运行结果可以看出，每次都需要10次内存引用</p>
<h3 id="20-3"><a href="#20-3" class="headerlink" title="20.3"></a>20.3</h3><p><strong>根据你对缓存内存的工作原理的理解，你认为对页表的内存引用如何在缓存中工作？它们是否会导致大量的缓存命中（并导致快速访问）或者很多未命中（并导致访问缓慢）？</strong></p>
<p>经常访问和最近访问的数据一般会放在缓存中，所以会导致大量的缓存命中。当然这也去决定于缓存的替换算法和访问的行为模式，在一些情况下可能会导致极低的命中率。</p>
<h2 id="第22章——超越物理内存：策略"><a href="#第22章——超越物理内存：策略" class="headerlink" title="第22章——超越物理内存：策略"></a>第22章——超越物理内存：策略</h2><h3 id="22-1"><a href="#22-1" class="headerlink" title="22.1"></a>22.1</h3><p><strong>使用以下参数生成随机地址：-s 0 -n 10，-s 1 -n 10 和-s 2 -n 10。将策略从FIFO 更改为LRU，并将其更改为OPT。计算所述地址追踪中的每个访问是否命中或未命中。</strong></p>
<p><code>python2 paging-policy.py -s 0 -n 10</code></p>
<p>一共10次访存，9次未命中，一次命中</p>
<p>Access: 8  Miss  State of Memory:[8]<br>Access: 7  Miss  State of Memory:[8,7]<br>Access: 4  Miss  State of Memory:[8,7,4]<br>Access: 2  Miss  State of Memory:[7,4,2]<br>Access: 5  Miss  State of Memory:[4,2,5]<br>Access: 4  Hit   State of Memory:[4,2,5]<br>Access: 7  Miss  State of Memory:[2,5,7]<br>Access: 3  Miss  State of Memory:[5,7,3]<br>Access: 4  Miss  State of Memory:[7,3,4]<br>Access: 5  Miss  State of Memory:[3,4,5]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Access: 8  MISS FirstIn -&gt;          [8] &lt;- Lastin  Replaced:- [Hits:0 Misses:1]</span><br><span class="line">Access: 7  MISS FirstIn -&gt;       [8, 7] &lt;- Lastin  Replaced:- [Hits:0 Misses:2]</span><br><span class="line">Access: 4  MISS FirstIn -&gt;    [8, 7, 4] &lt;- Lastin  Replaced:- [Hits:0 Misses:3]</span><br><span class="line">Access: 2  MISS FirstIn -&gt;    [7, 4, 2] &lt;- Lastin  Replaced:8 [Hits:0 Misses:4]</span><br><span class="line">Access: 5  MISS FirstIn -&gt;    [4, 2, 5] &lt;- Lastin  Replaced:7 [Hits:0 Misses:5]</span><br><span class="line">Access: 4  HIT  FirstIn -&gt;    [4, 2, 5] &lt;- Lastin  Replaced:- [Hits:1 Misses:5]</span><br><span class="line">Access: 7  MISS FirstIn -&gt;    [2, 5, 7] &lt;- Lastin  Replaced:4 [Hits:1 Misses:6]</span><br><span class="line">Access: 3  MISS FirstIn -&gt;    [5, 7, 3] &lt;- Lastin  Replaced:2 [Hits:1 Misses:7]</span><br><span class="line">Access: 4  MISS FirstIn -&gt;    [7, 3, 4] &lt;- Lastin  Replaced:5 [Hits:1 Misses:8]</span><br><span class="line">Access: 5  MISS FirstIn -&gt;    [3, 4, 5] &lt;- Lastin  Replaced:7 [Hits:1 Misses:9]</span><br><span class="line"></span><br><span class="line">FINALSTATS hits 1   misses 9   hitrate 10.00</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>python2 paging-policy.py -s 1 -n 10 -c</code></p>
<p>8Miss，2Hit</p>
<p>Access: 1  Miss  State of Memory:[1]<br>Access: 8  Miss  State of Memory:[1,8]<br>Access: 7  Miss  State of Memory:[1,8,7]<br>Access: 2  Miss  State of Memory:[8,7,2]<br>Access: 4  Miss  State of Memory:[7,2,4]<br>Access: 4  Hit   State of Memory:[7,2,4]<br>Access: 6  Miss  State of Memory:[2,4,6]<br>Access: 7  Miss  State of Memory:[4,6,7]<br>Access: 0  Miss  State of Memory:[6,7,0]<br>Access: 0  Hit   State of Memory:[6,7,0]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python2 paging-policy.py -s 1 -n 10 -c</span><br><span class="line">ARG addresses -1</span><br><span class="line">ARG addressfile </span><br><span class="line">ARG numaddrs 10</span><br><span class="line">ARG policy FIFO</span><br><span class="line">ARG clockbits 2</span><br><span class="line">ARG cachesize 3</span><br><span class="line">ARG maxpage 10</span><br><span class="line">ARG seed 1</span><br><span class="line">ARG notrace False</span><br><span class="line"></span><br><span class="line">Solving...</span><br><span class="line"></span><br><span class="line">Access: 1  MISS FirstIn -&gt;          [1] &lt;- Lastin  Replaced:- [Hits:0 Misses:1]</span><br><span class="line">Access: 8  MISS FirstIn -&gt;       [1, 8] &lt;- Lastin  Replaced:- [Hits:0 Misses:2]</span><br><span class="line">Access: 7  MISS FirstIn -&gt;    [1, 8, 7] &lt;- Lastin  Replaced:- [Hits:0 Misses:3]</span><br><span class="line">Access: 2  MISS FirstIn -&gt;    [8, 7, 2] &lt;- Lastin  Replaced:1 [Hits:0 Misses:4]</span><br><span class="line">Access: 4  MISS FirstIn -&gt;    [7, 2, 4] &lt;- Lastin  Replaced:8 [Hits:0 Misses:5]</span><br><span class="line">Access: 4  HIT  FirstIn -&gt;    [7, 2, 4] &lt;- Lastin  Replaced:- [Hits:1 Misses:5]</span><br><span class="line">Access: 6  MISS FirstIn -&gt;    [2, 4, 6] &lt;- Lastin  Replaced:7 [Hits:1 Misses:6]</span><br><span class="line">Access: 7  MISS FirstIn -&gt;    [4, 6, 7] &lt;- Lastin  Replaced:2 [Hits:1 Misses:7]</span><br><span class="line">Access: 0  MISS FirstIn -&gt;    [6, 7, 0] &lt;- Lastin  Replaced:4 [Hits:1 Misses:8]</span><br><span class="line">Access: 0  HIT  FirstIn -&gt;    [6, 7, 0] &lt;- Lastin  Replaced:- [Hits:2 Misses:8]</span><br><span class="line"></span><br><span class="line">FINALSTATS hits 2   misses 8   hitrate 20.00</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>python2 paging-policy.py -s 2 -n 10 -c</code></p>
<p>6Miss，4Hit</p>
<p>Access: 9  Miss  State of Memory:[9]<br>Access: 9  Hit   State of Memory:[9]<br>Access: 0  Miss  State of Memory:[9,0]<br>Access: 0  Hit   State of Memory:[9,0]<br>Access: 8  Miss  State of Memory:[9,0,8]<br>Access: 7  Miss  State of Memory:[0,8,7]<br>Access: 6  Miss  State of Memory:[8,7,6]<br>Access: 3  Miss  State of Memory:[7,6,3]<br>Access: 6  Hit   State of Memory:[7,6,3]<br>Access: 6  Hit   State of Memory:[7,6,3]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python2 paging-policy.py -s 2 -n 10 -c</span><br><span class="line">ARG addresses -1</span><br><span class="line">ARG addressfile </span><br><span class="line">ARG numaddrs 10</span><br><span class="line">ARG policy FIFO</span><br><span class="line">ARG clockbits 2</span><br><span class="line">ARG cachesize 3</span><br><span class="line">ARG maxpage 10</span><br><span class="line">ARG seed 2</span><br><span class="line">ARG notrace False</span><br><span class="line"></span><br><span class="line">Solving...</span><br><span class="line"></span><br><span class="line">Access: 9  MISS FirstIn -&gt;          [9] &lt;- Lastin  Replaced:- [Hits:0 Misses:1]</span><br><span class="line">Access: 9  HIT  FirstIn -&gt;          [9] &lt;- Lastin  Replaced:- [Hits:1 Misses:1]</span><br><span class="line">Access: 0  MISS FirstIn -&gt;       [9, 0] &lt;- Lastin  Replaced:- [Hits:1 Misses:2]</span><br><span class="line">Access: 0  HIT  FirstIn -&gt;       [9, 0] &lt;- Lastin  Replaced:- [Hits:2 Misses:2]</span><br><span class="line">Access: 8  MISS FirstIn -&gt;    [9, 0, 8] &lt;- Lastin  Replaced:- [Hits:2 Misses:3]</span><br><span class="line">Access: 7  MISS FirstIn -&gt;    [0, 8, 7] &lt;- Lastin  Replaced:9 [Hits:2 Misses:4]</span><br><span class="line">Access: 6  MISS FirstIn -&gt;    [8, 7, 6] &lt;- Lastin  Replaced:0 [Hits:2 Misses:5]</span><br><span class="line">Access: 3  MISS FirstIn -&gt;    [7, 6, 3] &lt;- Lastin  Replaced:8 [Hits:2 Misses:6]</span><br><span class="line">Access: 6  HIT  FirstIn -&gt;    [7, 6, 3] &lt;- Lastin  Replaced:- [Hits:3 Misses:6]</span><br><span class="line">Access: 6  HIT  FirstIn -&gt;    [7, 6, 3] &lt;- Lastin  Replaced:- [Hits:4 Misses:6]</span><br><span class="line"></span><br><span class="line">FINALSTATS hits 4   misses 6   hitrate 40.00</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="22-2"><a href="#22-2" class="headerlink" title="22.2"></a>22.2</h3><p><strong>对于大小为5 的高速缓存，为以下每个策略生成最差情况的地址引用序列：FIFO、LRU 和MRU（最差情况下的引用序列导致尽可能多的未命中）。对于最差情况下的引用序列，需要的缓存增大多少，才能大幅提高性能，并接近OPT？</strong></p>
<p>FIFO:</p>
<pre>
python2 paging-policy.py -a 1,2,3,4,5,6,7,8 -C 5
</pre>

<p>LRU:</p>
<pre>
python2 paging-policy.py -a 1,2,3,4,5,6,7,8 -C 5 -p LRU
</pre>

<p>MRU:</p>
<pre>
python2 paging-policy.py -a 1,2,3,4,5,6,7,8 -C 5 -p MRU
</pre>

<p>最差情况需要缓存增大到与页号相同</p>
<h3 id="22-3"><a href="#22-3" class="headerlink" title="22.3"></a>22.3</h3><p><strong>生成一个随机追踪序列（使用Python 或Perl）。你预计不同的策略在这样的追踪序列上的表现如何？</strong></p>
<p>该序列在OPT策略中表现一般，在其他策略的表现都相当糟糕</p>
<pre>
❯ python2 paging-policy.py -s 0 -n 10 -c -p FIFO
FINALSTATS hits 1   misses 9   hitrate 10.00
</pre>

<pre>
❯ python2 paging-policy.py -s 0 -n 10 -c -p LRU
FINALSTATS hits 2   misses 8   hitrate 20.00
</pre>

<pre>
❯ python2 paging-policy.py -s 0 -n 10 -c -p OPT
FINALSTATS hits 4   misses 6   hitrate 40.00
</pre>

<pre>
❯ python2 paging-policy.py -s 0 -n 10 -c -p UNOPT
FINALSTATS hits 0   misses 10   hitrate 0.00
</pre>

<pre>
❯ python2 paging-policy.py -s 0 -n 10 -c -p RAND
FINALSTATS hits 0   misses 10   hitrate 0.00
</pre>

<pre>
❯ python2 paging-policy.py -s 0 -n 10 -c -p CLOCK
FINALSTATS hits 1   misses 9   hitrate 10.00
</pre>

<h3 id="22-4"><a href="#22-4" class="headerlink" title="22.4"></a>22.4</h3><p><strong>现在生成一些局部性追踪序列。如何能够产生这样的追踪序列？LRU 表现如何？RAND比LRU 好多少？CLOCK 表现如何？CLOCK 使用不同数量的时钟位，表现如何？</strong></p>
<p>可以使用tool.py生成具有空间和时间局部性序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#tool.py</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">numAddr = <span class="number">10</span></span><br><span class="line"><span class="comment"># 空间局部性</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_spatial_locality_trace</span>():</span><br><span class="line">    trace = [random.randint(<span class="number">0</span>, numAddr)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        l = trace[-<span class="number">1</span>]</span><br><span class="line">        rand = [l, (l + <span class="number">1</span>) % numAddr, (l - <span class="number">1</span>) % numAddr, random.randint(<span class="number">0</span>, numAddr)]</span><br><span class="line">        trace.append(random.choice(rand))</span><br><span class="line">    <span class="comment"># 问题给的paging-policy.py -a参数里, 逗号后不能空格,因此拼接再打印</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> trace]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间局部性</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">generate_temporal_locality_trace</span>():</span><br><span class="line">    trace = [random.randint(<span class="number">0</span>, numAddr)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        rand = [random.randint(<span class="number">0</span>, numAddr), random.choice(trace)]</span><br><span class="line">        trace.append(random.choice(rand))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;,&#x27;</span>.join([<span class="built_in">str</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> trace]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;-t&#x27;</span>:</span><br><span class="line">        generate_temporal_locality_trace()</span><br><span class="line">    <span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">&#x27;-s&#x27;</span>:</span><br><span class="line">        generate_spatial_locality_trace()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>tool.py 用法</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">python3 tool.py -s#产生具有空间局部性序列</span><br><span class="line">python3 tool.py -t#产生具有时间局部性序列</span><br></pre></td></tr></table></figure>

<p>运行以下命令行，比较各个策略的表现</p>
<p>可以看到LRU在具有空间局部性序列的内存访问中表现更好。时间局部性序列的命中率在44%左右</p>
<p>Rand策略在时间局部性的策略上优于LRU策略，高了11%的命中率，然而在空间局部性序列中表现不如LRU</p>
<p>CLOCK bit为2时表现差于LRU，提高bit时出现好于LRU的情况，且在一定数值内（5左右）bit越高表现越好。</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">python2 paging-policy.py -p LRU -c -a  $(python3 tool.py -t)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;FINALSTATS hits 4   misses 5   hitrate 44.44</span></span><br><span class="line"></span><br><span class="line">python2 paging-policy.py -p LRU -c -a  $(python3 tool.py -s)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;FINALSTATS hits 6   misses 3   hitrate 66.67</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">python2 paging-policy.py -p RAND -c -a  $(python3 tool.py -t)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;FINALSTATS hits 5   misses 4   hitrate 55.56</span></span><br><span class="line"></span><br><span class="line">python2 paging-policy.py -p RAND -c -a  $(python3 tool.py -s)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;FINALSTATS hits 3   misses 6   hitrate 33.33</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">python2 paging-policy.py -p CLOCK -c -a  $(python3 tool.py -t)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;FINALSTATS hits 1   misses 8   hitrate 11.11</span></span><br><span class="line"></span><br><span class="line">python2 paging-policy.py -p CLOCK -c -a  $(python3 tool.py -s)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;FINALSTATS hits 1   misses 8   hitrate 11.11</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>The-Operating-System-Notes</category>
      </categories>
      <tags>
        <tag>operating sysytem</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>内存虚拟化</title>
    <url>/2021/03/23/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="第-13-章-抽象：地址空间"><a href="#第-13-章-抽象：地址空间" class="headerlink" title="第 13 章 抽象：地址空间"></a>第 13 章 抽象：地址空间</h2><p><strong>多道程序</strong></p>
<p>其中多个进程在给定时间准备运行，比如当有一个进程在等待 I&#x2F;O 操作的时候，操作系统会切换这些进程，这样增加了 CPU 的有效利用率（utilization）</p>
<p><strong>时分共享</strong></p>
<p>一种实现时分共享的方法，是让一个进程单独占用全部内存运行一小段时间，然后停止它，并将它所有的状态信息保存在磁盘上（包含所有的物理内存），加载其他进程的状态信息，再运行一段时间，这就实现了某种比较粗糙的机器共享</p>
<p>但是效率极低，特别是当内存增长的时候。因此，在进程切换的时候，我们仍然将进程信息放在内存中，这样操作系统可以更有效率地实现时分共享</p>
<p><strong>地址空间</strong>※</p>
<p>操作系统给运行中的程序提供的一个易用的物理内存抽象，叫做地址空间</p>
<p>一个进程的地址空间包含运行的程序的所有<strong>内存状态</strong>，如程序的<strong>代码</strong>，<strong>栈</strong>(利用栈来保存当前函数的调用信息，分配空间给局部变量，传递参数和函数返回值)和<strong>堆</strong>(管理动态的，用户分配的内存)<br><img src="https://s2.loli.net/2022/01/06/S7rHtdVyAD3BmZK.png" alt="image-20220106145020187"></p>
<p><strong>虚拟化内存的目标</strong></p>
<ul>
<li><p>透明：操作系统实现虚拟内存的方式，应该让运行的程序看不到，因此程序感知不到内存被虚拟化的事实，操作系统和硬件完成这些工作，实现了地址空间这个假象</p>
</li>
<li><p>效率：操作系统应该使得虚拟化在时间上和空间上尽可能地高效</p>
</li>
<li><p>保护：操作系统应该确保进程受到保护，不被其它进程影响，每个进程在自己独立的环境中运行，避免其它出错或恶意进程的干扰</p>
</li>
</ul>
<p>虚拟内存系统负责为程序提供一个巨大的，稀疏的，私有的地址空间的假象，其中保存了程序的所有指令和数据，操作系统在硬件的帮助下，通过每一个虚拟内存的索引，将其转换成物理地址，物理内存根据获得获得的物理地址去获取所需的信息，操作系统会同时对许多进程执行此操作，并且确保程序之间不会受到影响，也不会干扰操作系统</p>
<h2 id="第-14-章-插叙：内存操作-API"><a href="#第-14-章-插叙：内存操作-API" class="headerlink" title="第 14 章 插叙：内存操作 API"></a><strong>第 14 章 插叙：内存操作 API</strong></h2><h3 id="内存类型"><a href="#内存类型" class="headerlink" title="内存类型"></a><strong>内存类型</strong></h3><p><strong>栈内存</strong></p>
<p>栈内存的申请和释放操作是编译器来隐式管理的，所以有时也称为自动（automatic）内存。</p>
<p><strong>堆内存</strong></p>
<p>所有的申请和释放操作都由程序员显式地完成。满足长期内存的需求</p>
<h3 id="malloc-调用"><a href="#malloc-调用" class="headerlink" title="malloc()调用"></a>malloc()调用</h3><h3 id="Free-调用"><a href="#Free-调用" class="headerlink" title="Free()调用"></a>Free()调用</h3><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>忘记分配内存</p>
<p>没有分配足够的内存</p>
<p>忘记初始化分配的内存</p>
<p>忘记释放内存</p>
<p>在用完之前释放内存</p>
<p>反复释放内存</p>
<p>错误地调用 free()</p>
<p><strong>关于内存泄漏</strong></p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/202111251745711.png" alt="image-20211125174454450"></p>
<h2 id="第-15-章-机制：地址转换"><a href="#第-15-章-机制：地址转换" class="headerlink" title="第 15 章 机制：地址转换"></a>第 15 章 机制：地址转换</h2><p>在<strong>CPU 虚拟化</strong>时，使用了受限直接访问 LDE，LDE 背后的想法很简单：让程序运行的大部分指令直接访问硬件，在一些关键点(进程发生系统调用和发生时钟中断)由操作系统介入来确保高效和控制</p>
<p>对<strong>内存虚拟化</strong>时，同样追求高效和控制，高效决定我们要利用硬件的支持，控制意味着操作系统确保每个应用只能访问自己的内存空间，要保护应用程序不会互相影响，更不会影响操作系统，灵活性即希望程序能以任何方式访问它们自己的内存空间，从而让系统更容易编程</p>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a><strong>地址转换</strong></h3><p>为了完成这些，采用了称为<strong>基于硬件的地址转换，即地址转换</strong>，利用地址转换，硬件对每次内存访问进行处理，将指令中的虚拟地址转换为数据实际存储的物理地址，因此在每次内存引用时，硬件都会进行地址转换，将应用程序的内存引用重定位到内存中实际所在的位置</p>
<p>仅仅<strong>依靠硬件不足以实现虚拟内存，操作系统必须在关键的位置介入</strong>，设置好硬件，以便完成正确的地址转换，操作系统必须管理内存，记录被占用和空闲的内存位置，保存对内存使用的控制。</p>
<h3 id="动态-基于硬件-重定位"><a href="#动态-基于硬件-重定位" class="headerlink" title="动态(基于硬件)重定位"></a>动态(基于硬件)重定位</h3><p>每个 CPU 需要两个硬件寄存器：基址（base）寄存器和界限（bound）寄存<br>器，有时称为限制（limit）寄存器。这组基址和界限寄存器，让我们能够将地址空间放在物理内存的任何位置，同时又能确保进程只能访问自己的地址空间。</p>
<p>$physical address &#x3D; virtual address + base$</p>
<p>将虚拟地址转换为物理地址，这正是所谓的地址转换（addresstranslation）技术。由于这种重定位是在运行时发生的，而且我们甚至可以在进程开始运行后改变其地址空间，这种技术一般被称为动态重定位</p>
<p><strong>(1) 基址寄存器</strong><br>采用基址界限机制时，在编写和编译程序时假设地址空间从 0 开始，但是当程序真正开始运行时，操作系统会决定其在物理内存中的实际加载地址，并将起始地址记录在基址寄存器上</p>
<p>之后该进程的所有内存引用，都会通过如下方式从虚拟地址转换成物理地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">物理地址 = 虚拟地址 + 基址地址(进程在物理内存中的起始地址)</span><br></pre></td></tr></table></figure>

<p>进程中使用的内存都是虚拟地址，硬件接下来将虚拟地址加上基址寄存器中的内容，得到物理地址</p>
<p>对于上述示例的一条指令进行追踪：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">128: movl 0x0(%ebx), %eax</span><br><span class="line">首先程序计数器(PC)被设置为128，当硬件需要执行这条指令时，它先将这个值加上基址寄存器中的32kb，得到实际的物理地址32896，再从32896这个物理地址获取指令并执行</span><br></pre></td></tr></table></figure>

<p>将虚拟地址转换成物理地址，就是地址转换，硬件取得进程认为它要访问的地址，将它转换成数据实际位于的物理地址</p>
<p><strong>(2) 界限寄存器</strong><br>基址界限机制中另一部分是界限寄存器，界限寄存器提供了访问保护，在示例中，地址空间为 16kb，界限寄存器被设置为 16kb，如果进程想访问超过这个界限或者为负数的虚拟地址，CPU 将触发异常，进程可能被终止</p>
<p>界限寄存器通常有两种使用方式：<br>1，界限寄存器记录地址空间的大小，硬件在将虚拟地址与基址寄存器内容求和前，先检查这个界限<br>2，界限寄存器存储地址空间结束的物理地址，硬件在转化虚拟地址到物理地址之后再检查这个界限</p>
<p>这两种方式本质是相同的，默认使用第一种<br><strong>为了完成地址转换，需要一些硬件支持</strong></p>
<p>1，两种 CPU 模式，特权和用户模式<br>2，基址寄存器和界限寄存器，用户程序运行时，硬件会转换每个地址，硬件也必须检查地址是否可用，通过基址寄存器，界限寄存器和一些电路来完成<br>3，硬件应该提供一些特殊的指令，用于修改基址寄存器和界限寄存器中的值，允许操作系统在切换进程时改变它们，且这些指令必须在 kernel 模式下，如果用户程序可以更改基址寄存器和界限寄存器，那么这个程序就可以访问内存中的任意位置<br>4，用户程序非法访问内存时，CPU 必须能产生异常，CPU 应该阻止该应用程序的运行，并安排操作系统的对应异常处理程序终止该进程</p>
<p>利用地址转换，<strong>操作系统可以控制进程的所有内存访问，确保访问在地址空间的界限内。</strong>这个技术的关键在于<strong>硬件支持</strong>，硬件快速的将所有内存访问操作中的虚拟地址转换为物理地址，所有这一切对于进程来说都是透明的，进程并不知道自己使用的物理内存已经被重定位</p>
<p>但使用基址加界限重定位有<strong>效率低下</strong>的问题，由于进程的堆区和栈区可能不是很大<strong>整块内存利用率不高</strong>，导致这块内存区域中大量的空间被浪费，这种浪费称为内部碎片，因此需要更复杂的机制，以便更好利用物理内存，避免内部碎片</p>
<h2 id="第-16-章——分段"><a href="#第-16-章——分段" class="headerlink" title="第 16 章——分段"></a><strong>第 16 章——分段</strong></h2><p>为了避免内部碎片和提高物理内存的利用率，<strong>分段</strong>应运而生</p>
<p>分段：</p>
<p>在内存管理单元(MMU)中引进不止一对基址，界限寄存器，<strong>而是给地址空间内的每个逻辑段一对基址，界限寄存器</strong>，把虚拟地址空间中的虚拟内存组织成一些长度可变的称为段的内存块单元。</p>
<p>典型的地址空间有 3 个逻辑段，代码段，堆段，栈段</p>
<p><strong>一个分段例子</strong></p>
<p><img src="https://s2.loli.net/2022/01/06/ozmRQk9u7OSbpLn.png" alt="image-20220106154129353"></p>
<p>假设引用虚拟地址 100(在代码段中)，代码段基址为 32kb，虚拟地址 100 在代码段地址空间中的偏移量为 100-0，则物理地址为 32kb+100&#x3D;32868，然后检查该地址是否在界限内(100&lt;2kb)，通过后发起对物理地址 32868 的引用</p>
<p>假设引用虚拟地址 4200(在堆中)，堆基址为 34kb，虚拟地址 4200 在堆地址空间中的偏移量为 4200-4kb&#x3D;104，则物理地址为 34kb+104&#x3D;34920，然后检查该地址是否在界限内(104&lt;2kb)，通过后发起对物理地址 34920 的引用</p>
<p>如果试图访问非法的地址，硬件会发现越界，因此 trap 进内核，操作系统终止进程</p>
<p>分段与分页：</p>
<p><a href="https://blog.csdn.net/qq_37924084/article/details/78360003">https://blog.csdn.net/qq_37924084/article/details/78360003</a></p>
<h2 id="第-17-章-空闲空间管理"><a href="#第-17-章-空闲空间管理" class="headerlink" title="第 17 章 空闲空间管理"></a>第 17 章 空闲空间管理</h2><p>在堆上管理空闲空间的数据结构通常称为空闲列表（free list）</p>
<h3 id="假设"><a href="#假设" class="headerlink" title="假设"></a><strong>假设</strong></h3><p>1.假定基本的接口就像 malloc()和 free()提供的那样，在只传入一个指针的情况下，库必须能够弄清楚这块内存的大小</p>
<p>2.我们主要关心的是外部碎片（external fragmentation）</p>
<p>3.内存一旦被分配给客户，就不可以被重定位到其他位置。</p>
<p>4.分配程序所管理的是连续的一块字节区域</p>
<h3 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a><strong>底层机制</strong></h3><p>分割与合并</p>
<p>追踪已分配空间的大小</p>
<p>让堆增长</p>
<h3 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h3><p><strong>最优匹配（best fit）</strong></p>
<p>首先遍历整个空闲列表，找到和请求大小一样或更大的空闲块，然后返回这组候选者中最小的一块。</p>
<p>最优匹配背后的想法很简单：选择最接近它用户请求大小的块，从而尽量避免空间浪费。然而，这有代价。简单的实现在遍历查找正确的空闲块时，要付出较高的性能代价。</p>
<p><strong>最差匹配（worst fit）</strong></p>
<p>它尝试找最大的空闲块，分割并满足用户需求后，将剩余的块（很大）加入空闲列表</p>
<p>它的表现非常差，导致过量的碎片，同时还有很高的开销。</p>
<p><strong>首次匹配（first fit）</strong></p>
<p>从空闲列表头开始，找到第一个足够大的块，将请求的空间返回给用户。</p>
<p>首次匹配有速度优势。</p>
<p>分配程序如何管理空闲列表的顺序就变得很重要。一种方式是基于地址排序（address-based ordering）。通过保持空闲块按内存地址有序，合并操作会很容易，从而减少了内存碎片。</p>
<p><strong>下次匹配（next fit）</strong></p>
<p>算法多维护一个指针，指向上一次查找结束的位置。其想法是将对空闲空间的查找操作扩散到整个列表中去，避免对列表开头频繁的分割。</p>
<p>这种策略的性能与首次匹配很接近，同样避免了遍历查找。</p>
<p><strong>分离空闲列表</strong></p>
<p>如果某个应用程序经常申请一种（或几种）大小的内存空间，那就用一个独立的列表，只管理这样大小的对象。其他大小的请求都一给更通用的内存分配程序。<br>好处显而易见。通过拿出一部分内存专门满足某种大小的请求，碎片就不再是问题了（避免碎片）。而且，由于没有复杂的列表查找过程，这种特定大小的内存分配和释放都很快。</p>
<p><strong>伙伴系统</strong></p>
<h2 id="第-18-章-分页"><a href="#第-18-章-分页" class="headerlink" title="第 18 章 分页"></a>第 18 章 分页</h2><p><strong>基本思想：</strong></p>
<p><strong>将内存空间分割成固定大小的单元，每个单元称一页</strong></p>
<p><strong>相应的把物理内存看成定长槽块的阵列，叫做页帧，每个页帧包含一个虚拟内存页</strong></p>
<p><strong>分页中的地址转换过程</strong><br>假设一个 64 字节的进程正在访问内存：</p>
<p>为了转换该过程生成的虚拟地址，首先要将其分成两个组件：<br>虚拟页面号(VPN)和页内的偏移量(offset)，由于虚拟地址空间为 64 字节，所以地址空间需要 6 位表示(2^6&#x3D;64)</p>
<p>页面大小位 16 字节，位于 64 字节的地址空间，因此需要表示 4 个页，所以用虚拟地址前 2 位表示是哪个页，即虚拟页号，后四位用来表示该地址在该页内的偏移量</p>
<p>地址转换的过程中，查询页表根据虚拟页号找到对应的物理页帧，偏移量保持不变就能得到真实的物理地址<br><img src="https://s2.loli.net/2022/01/06/HeigOZrwnhlD3VE.png" alt="image-20220106162445765"></p>
<p><strong>页表中的内容</strong></p>
<p>每个 PTE 中有许多不同的位：<br>1，有效位：通常用于指示特定地址转换是否有效，如当一个程序开始运行时，它的代码和堆在其地址空间的一端，栈在另一端，中间没被使用的空间被标记位无效，如果进程尝试访问这些内存，就会陷入内核，导致进程终止，有效位对稀疏地址空间至关重要，通过简单地将地址空间中未使用地页面标记为无效，就不需要为这些页面分配物理帧，从而节省大量内存</p>
<p>2，保护位：表明页是否可以读取，写入或执行，同样地以这些位不允许地方式访问页，会陷入操作系统，终止进程</p>
<p>3，存在位：表示该页是在物理存储器中还是在磁盘上，交换机制可以让操作系统将很少使用的页移动到磁盘，从而释放物理内存</p>
<p>4，脏位：表明页面从磁盘被带入内存后是否被修改过</p>
<p>5，参考位：有时用于追踪页是否被访问，也用于确定哪些页被频繁使用，因此将其保留在内存中</p>
<p>优点：它不会导致外部碎片，因为分页（按设计）将内存划分为固定大小的单元。其次，它非常灵活，支持稀疏虚拟地址空间。</p>
<p>缺点：会导致较慢的机器有许多额外的内存访问来访问页表，和内存浪费（内存被页表塞满而不是有用的应用程序数据）</p>
<h3 id="分段机制和分页机制的区别"><a href="#分段机制和分页机制的区别" class="headerlink" title="分段机制和分页机制的区别"></a>分段机制和分页机制的区别</h3><p>1、分页机制会使用大小固定的内存块，而分段管理则使用了大小可变的块来管理内存。</p>
<p>2、分页使用固定大小的块更为适合管理物理内存，分段机制使用大小可变的块更适合处理复杂系统的逻辑分区。</p>
<p>3、段表存储在线性地址空间，而页表则保存在物理地址空间。</p>
<h2 id="第-19-章-分页：快速地址转换（TLB）"><a href="#第-19-章-分页：快速地址转换（TLB）" class="headerlink" title="第 19 章　分页：快速地址转换（TLB）"></a>第 19 章　分页：快速地址转换（TLB）</h2><h3 id="快速地址转换-TLB※"><a href="#快速地址转换-TLB※" class="headerlink" title="快速地址转换 TLB※"></a>快速地址转换 TLB※</h3><p>为了加速地址转换，使得分页机制更加完备，需要硬件的支持，**地址转换旁路缓冲存储器(TLB)**，也称地址转换缓存，即频繁发生的虚拟地址到物理地址转换的硬件缓存，对每次内存访问，硬件先检查 TLB，看看其中是否有期望的转换映射，如果有，就完成转换，由于是硬件完成的，所以速度很快，不需要再访问页表查找页表项中的物理页帧</p>
<p>TLB 带来了巨大的性能提升，它使得虚拟内存成为可能</p>
<h3 id="TLB-的基本算法"><a href="#TLB-的基本算法" class="headerlink" title="TLB 的基本算法"></a>TLB 的基本算法</h3><p>TLB 的基本算法<br>硬件算法的大体流程如下：</p>
<p>首先从虚拟地址中提取虚拟页号(VPN)，然后检查 TLB 是否有该 VPN 的转换映射，如果有就有了 TLB 命中，即 TLB 有该虚拟页号的转换映射，接下来从 TLB 中取出物理页帧号(PFN)，与虚拟地址中的偏移量结合形成期望的物理地址，并访问内存</p>
<p>如果 CPU 没有在 TLB 中找到转换映射(TLB 未命中)，硬件访问页表来寻找地址转换，并用该转换更新 TLB，当 TLB 更新后，系统会重新尝试该指令，这时 TLB 中有这个转换映射，内存引用很快得到处理</p>
<p>TLB 和其它缓存相似，一般情况下，转换映射会在缓存中(TLB 命中)，通过缓存来引用内存，只增加了很少的开销，如果 TLB 未命中，就会带来很大的分页开销，必须先从页表中查找转换映射，如果一段程序中多次 TLB 未命中，程序的运行就会显著变慢，因此尽可能希望避免 TLB 未命中</p>
<h3 id="TLB未命中处理"><a href="#TLB未命中处理" class="headerlink" title="ＴＬＢ未命中处理"></a>ＴＬＢ未命中处理</h3><p><strong>硬件或软件（操作系统）</strong></p>
<p>软件管理的方法：更现代的体系结构，都是精简的指令集计算机。发生 TLB 未命中时，硬件系统会抛出一个异常，这会暂停当前的指令流，将特权级提升至内核模式，跳转至陷阱处理程序（trap handler）。这个陷阱处理程序是操作系统的一段代码，用于处理 TLB 未命中。</p>
<p>主要优势是<strong>灵活性</strong>，操作系统可以用任意数据结构来实现页表，不需要改变硬件。另一个优势是<strong>简单性</strong>。硬件不需要对未命中做太多工作，它抛出异常，操作系统的未命中处理程序会负责剩下的工作。</p>
<h3 id="TLB的内容"><a href="#TLB的内容" class="headerlink" title="ＴＬＢ的内容"></a>ＴＬＢ的内容</h3><p>注意，VPN 和 PFN 同时存在于 TLB 中，因为一条地址映射可能出现在任意位置（用硬件的术语，TLB 被称为全相联的（fully-associative）缓存）。硬件并行地查找这些项，看看是否有匹配。</p>
<p><strong>！TLB 的有效位!&#x3D;页表的有效位</strong></p>
<h3 id="上下文切换时对-TLB-的处理"><a href="#上下文切换时对-TLB-的处理" class="headerlink" title="上下文切换时对 TLB 的处理"></a>上下文切换时对 TLB 的处理</h3><p>TLB 中包含的虚拟到物理的地址映射只对当前进程有效，对其他进程是没有意义的。所以在发生进程切换时，硬件或操作系统（或二者）必须注意确保即将运行的进程不要误读了之前进程的地址映射。</p>
<p><strong>解决方案</strong></p>
<p>１.一种方法是在上下文切换时，简单地清空（flush）TLB。但是，有一定开销：每次进程运行，当它访问数据和代码页时，都会触发 TLB 未命中。如果操作系统频繁地切换进程，这种开销会很高。</p>
<p>２.为了减少这种开销，一些系统增加了硬件支持，实现跨上下文切换的 TLB 共享。比如有的系统在 TLB 中添加了一个地址空间标识符（Address Space Identifier，ASID）。可以把 ASID 看作是进程标识符（Process Identifier，PID），但通常比 PID 位数少（PID 一般 32 位，ASID 一般是 8 位）。</p>
<p><strong>尽可能利用缓存</strong><br>缓存技术是计算机系统中最基本的性能改进技术之一，一次又一次地用于让“常见地情况更快”，硬件缓存背后的思想是利用指令和数据引用的局部性，通常有两种局部性：</p>
<p>时间局部性：最近访问过的指令或数据很快会再次访问，如循环中的循环变量或指令</p>
<p>空间局部性：当程序访问内存地址 x 时，可能很快会访问邻近 x 的内存，如上</p>
<p><strong>TLB 替换策略</strong><br>TLB 中的内容是有限的，需要替换缓存，即向 TLB 中插入新项时，会替换一个旧项，那应该替换哪一个？</p>
<p>有两种常用策略：<br>1，替换最近最少使用的项 LRU，LRU 尝试利用内存引用流中的局限性，假定最近没有用过的项，作为被替换的候选项<br>2，随机策略，随机换一个出去，这种策略虽然很简单，但能避免一些极端情况</p>
<h2 id="第２０章-分页：较小的表"><a href="#第２０章-分页：较小的表" class="headerlink" title="第２０章　分页：较小的表"></a>第２０章　分页：较小的表</h2><p>用来解决分页引入的第二个问题：页表太大，因此消耗的内存太多</p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p><strong>基本思想</strong>：首先，将页表分成页大小的单元。然后，如果整页的页<br>表项（PTE）无效，就完全不分配该页的页表。为了追踪页表的页是否有效（以及如果有效，它在内存中的位置），使用了名为页目录（page directory）的新结构。页目录因此可以告诉你页表的页在哪里，或者页表的整个页不包含有效页。</p>
<p><strong>优势</strong>：多级页表分配的页表空间，与你正在使用的地址空间内存量成比例。因此它通常很紧凑，并且支持稀疏的地址空间。</p>
<p>如果仔细构建，页表的每个部分都可以整齐地放入一页中，从而更容易管理内存。</p>
<p><strong>缺点</strong>：多级页表是有成本的。在 TLB 未命中时，需要从内存加载两次，才能从页表中获取正确的地址转换信息（一次用于页目录，另一次用于 PTE 本身），而用线性页表只需要一次加载。因此，多级表是一个时间—空间折中的小例子</p>
<p>另一个明显的缺点是复杂性</p>
<h2 id="第-22-章-物理内存管理策略"><a href="#第-22-章-物理内存管理策略" class="headerlink" title="第 22 章 物理内存管理策略"></a>第 22 章 物理内存管理策略</h2><p><strong>页替换算法</strong></p>
<p>1.最优替换算法</p>
<p>最优替换策略：<strong>替换内存中在最远将来才会被访问到的页</strong>，可以达到缓存未命中率最低</p>
<p>2.FIFO</p>
<p>3.随机替换算法</p>
<p>缺点：可能会替换出常用的重要页</p>
<p>4.LRU（最早未使用）</p>
<p><strong>最近最久未使用（LRU）算法</strong>根据页面调入内存后的使用情况进行决策，选择最近最久未使用的页面予以淘汰；该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问一来所经历的时间 T，当需要淘汰一个页面时，选择现有页面中 T 值最大的，即最近最久未使用的页面予以淘汰。</p>
<p>5.<strong>时钟算法</strong></p>
<p>系统中的所有页放在一个循环列表中，时钟指针开始指向某个页，当进行页替换时，操作系统检查当前时钟指针指向的页的引用位是 1 还是 0，如果是 1，操作系统将其引用位置 0，时钟指针指向下一个页，直到找到一个引用位为 0 的页，将其换出</p>
<p>基于局部性</p>
]]></content>
      <categories>
        <category>The-Operating-System-Notes</category>
      </categories>
      <tags>
        <tag>operating sysytem</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>1.operating-systems-three-easy-pieces answers</title>
    <url>/2021/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC2%E6%AC%A1%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<h1 id="操作系统第-2-次作业"><a href="#操作系统第-2-次作业" class="headerlink" title="操作系统第 2 次作业"></a>操作系统第 2 次作业</h1><p>201908010224 黄雅妮</p>
<h2 id="第-26-章"><a href="#第-26-章" class="headerlink" title="第 26 章"></a>第 26 章</h2><h4 id="26-1"><a href="#26-1" class="headerlink" title="26.1"></a>26.1</h4><p><strong>开始，我们来看一个简单的程序，“loop.s”。首先，阅读这个程序，看看你是否能理解它：cat loop.s。然后，用这些参数运行它：</strong><br><strong>.&#x2F;x86.py -p loop.s -t 1 -i 100 -R dx</strong><br><strong>这指定了一个单线程，每 100 条指令产生一个中断，并且追踪寄存器%dx。你能弄清楚%dx 在运行过程中的价值吗？你有答案之后，运行上面的代码并使用-c 标志来检查你的答案。注意答案的左边显示了右侧指令运行后寄存器的值（或内存的值）。</strong></p>
<p>loop.S 试图修改寄存器%dx 的值，将寄存器%dx 的值减一后，再测试其是否为 0，如果大于等于 0 则跳转至 top 处。从运行结果来看，线程在第一轮减 1 操作后便终止了程序，所以可以推断出%dx 的原值为 0；</p>
<p>？0</p>
<p>？-1</p>
<p>？ -1</p>
<p>？ -1</p>
<p>？ -1</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111121019512.png" alt="image-20211112101945421"></p>
<p>加上-c 标志，验证正确</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111121037711.png" alt="image-20211112103721614"></p>
<h4 id="26-2"><a href="#26-2" class="headerlink" title="26.2"></a>26.2</h4><p><strong>现在运行相同的代码，但使用这些标志：</strong></p>
<p><strong>.&#x2F;x86.py -p loop.s -t 2 -i 100 -a dx&#x3D;3,dx&#x3D;3 -R dx</strong><br><strong>这指定了两个线程，并将每个%dx 寄存器初始化为 3。%dx 会看到什么值？使用-c 标志验证你的答案。多个线程的存在是否会影响计算？这段代码有竞态条件吗？</strong></p>
<p>可以看到看到线程 T0 进行 4 轮减 1 操作后，%dx 的值为-1，然后终止了程序。此时发生中断，恢复上下文，线程 T1 再次进 行 4 轮减 1 操作后终止程序。所以最终结果并没有受到影响。</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111121043689.png" alt="image-20211112104310522"></p>
<p>加上-c 标志，可以看到中断时间大于线程执行时间，不存在竞态条件</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111121100246.png" alt="image-20211112110037895"></p>
<h4 id="26-3"><a href="#26-3" class="headerlink" title="26.3"></a>26.3</h4><p><strong>现在运行以下命令：</strong><br><strong>.&#x2F;x86.py -p loop.s -t 2 -i 3 -r -a dx&#x3D;3,dx&#x3D;3 -R dx</strong><br><strong>这使得中断间隔非常小且随机。使用不同的种子和-s 来查看不同的交替。中断频率是否会改变这个程序的行为？</strong></p>
<p>可以看到，两个线程之间频繁地发生中断。但是两个线程的行为未改变，都是进行了 4 轮减 1 操作后终止。所以中断频率并不会改变程序的行为。</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111121103638.png" alt="image-20211112110339370"></p>
<p>加上-c 标志， 可以看到，计算结果的确未收到影响，因为线程 0 和线程 1 修改的不是共享变量</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111121114756.png" alt="image-20211112111454021"></p>
<h4 id="26-4"><a href="#26-4" class="headerlink" title="26.4"></a>26.4</h4><p><strong>接下来我们将研究一个不同的程序（looping-race-nolock.s）。</strong><br><strong>该程序访问位于内存地址 2000 的共享变量。简单起见，我们称这个变量为 x。使用单线程运行它，并确保你了解它的功能，如下所示：</strong><br><strong>.&#x2F;x86.py -p looping-race-nolock.s -t 1 -M 2000</strong></p>
<p><strong>在整个运行过程中，x（即内存地址为 2000）的值是多少？使用-c 来检查你的答案。</strong></p>
<p>looping-race-nolock.s 将 X 加 1 后回存到内存 2000，然后再将 bx 寄存器的值减一后，再检测 bx%是否大于 0，如果大于 0 则再次循环，否则终止程序。</p>
<p>因为不知道内存地址 2000 初始值，无法推断出 x 的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.main</span><br><span class="line">.top</span><br><span class="line">mov 2000, %ax  # get &#x27;value&#x27; at address 2000</span><br><span class="line">add $1, %ax    # increment it</span><br><span class="line">mov %ax, 2000  # store it back</span><br><span class="line">sub  $1, %bx</span><br><span class="line">test $0, %bx</span><br><span class="line">jgt .top</span><br><span class="line">halt</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111121122346.png" alt="image-20211112112224072"></p>
<p>加上-c 标志，可以看到 x 的初始值为 0，执行程序后，x 的值变为 1</p>
<p><img src="https://gitee.com/nnilk/cloudimage/raw/master/img/202111121145016.png" alt="image-20211112114556739"></p>
<h2 id="第-28-章"><a href="#第-28-章" class="headerlink" title="第 28 章"></a>第 28 章</h2><h4 id="28-1"><a href="#28-1" class="headerlink" title="28.1"></a><strong>28.1</strong></h4><p><strong>首先用标志-p flag.s 运行 x86.py。该代码通过一个内存标志“实现”锁。你能理解汇编代码试图做什么吗？</strong></p>
<p>flag.s 汇编代码如下：</p>
<p>代码实现了一个简单的锁。flag 变量指示锁是否被持有，临界区是将全局变量进行加一操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.var flag</span><br><span class="line">.var count</span><br><span class="line"></span><br><span class="line">.main</span><br><span class="line">.top</span><br><span class="line"></span><br><span class="line">.acquire</span><br><span class="line">mov  flag, %ax      # 获取锁</span><br><span class="line">test $<span class="number">0</span>, %ax        #如果当前flag==<span class="number">0</span>，则锁未被持有</span><br><span class="line">jne  .acquire       # 重复获取，直至锁可用</span><br><span class="line">mov  $<span class="number">1</span>, flag       # 获取锁，将flag置<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># critical section</span></span><br><span class="line">mov  count, %ax     <span class="meta">#count+1</span></span><br><span class="line">add  $<span class="number">1</span>, %ax</span><br><span class="line">mov  %ax, count</span><br><span class="line"></span><br><span class="line"><span class="meta"># release lock</span></span><br><span class="line">mov  $<span class="number">0</span>, flag       # 释放锁</span><br><span class="line"></span><br><span class="line"><span class="meta"># see <span class="keyword">if</span> we<span class="string">&#x27;re still looping</span></span></span><br><span class="line"><span class="string"><span class="meta">sub  $1, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">test $0, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">jgt .top</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">halt</span></span></span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<p>可以看到，线程 0 先获取锁，执行完成后，count+1，又释放了锁。之后线程 2 再次获取了锁，将 count 再次加一后，释放锁。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">       Thread <span class="number">0</span>                Thread <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="number">1000</span> mov  flag, %ax</span><br><span class="line"><span class="number">1001</span> test $<span class="number">0</span>, %ax</span><br><span class="line"><span class="number">1002</span> jne  .acquire</span><br><span class="line"><span class="number">1003</span> mov  $<span class="number">1</span>, flag</span><br><span class="line"><span class="number">1004</span> mov  count, %ax</span><br><span class="line"><span class="number">1005</span> add  $<span class="number">1</span>, %ax</span><br><span class="line"><span class="number">1006</span> mov  %ax, count</span><br><span class="line"><span class="number">1007</span> mov  $<span class="number">0</span>, flag</span><br><span class="line"><span class="number">1008</span> sub  $<span class="number">1</span>, %bx</span><br><span class="line"><span class="number">1009</span> test $<span class="number">0</span>, %bx</span><br><span class="line"><span class="number">1010</span> jgt .top</span><br><span class="line"><span class="number">1011</span> halt</span><br><span class="line">----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">                         <span class="number">1000</span> mov  flag, %ax</span><br><span class="line">                         <span class="number">1001</span> test $<span class="number">0</span>, %ax</span><br><span class="line">                         <span class="number">1002</span> jne  .acquire</span><br><span class="line">                         <span class="number">1003</span> mov  $<span class="number">1</span>, flag</span><br><span class="line">                         <span class="number">1004</span> mov  count, %ax</span><br><span class="line">                         <span class="number">1005</span> add  $<span class="number">1</span>, %ax</span><br><span class="line">                         <span class="number">1006</span> mov  %ax, count</span><br><span class="line">                         <span class="number">1007</span> mov  $<span class="number">0</span>, flag</span><br><span class="line">                         <span class="number">1008</span> sub  $<span class="number">1</span>, %bx</span><br><span class="line">                         <span class="number">1009</span> test $<span class="number">0</span>, %bx</span><br><span class="line">                         <span class="number">1010</span> jgt .top</span><br><span class="line">                         <span class="number">1011</span> halt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>28.2：使用默认值运行时，flag.s 是否按预期工作？它会产生正确的结果吗？使用-M 和-R 标志跟踪变量和寄存器（并打开-c 查看它们的值）。你能预测代码运行时标志最终会变成什么值吗？</strong></p>
<p>从题 1 的运行结果来看，flag 的最终值为 0，count 的值为 2. 使用标志 -M -R 验证，运行结果如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flag count          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0</span><br><span class="line">    0     0   1000 mov  flag, %ax</span><br><span class="line">    0     0   1001 test $0, %ax</span><br><span class="line">    0     0   1002 jne  .acquire</span><br><span class="line">    1     0   1003 mov  $1, flag</span><br><span class="line">    1     0   1004 mov  count, %ax</span><br><span class="line">    1     0   1005 add  $1, %ax</span><br><span class="line">    1     1   1006 mov  %ax, count</span><br><span class="line">    0     1   1007 mov  $0, flag</span><br><span class="line">    0     1   1008 sub  $1, %bx</span><br><span class="line">    0     1   1009 test $0, %bx</span><br><span class="line">    0     1   1010 jgt .top</span><br><span class="line">    0     1   1011 halt</span><br><span class="line">    0     1   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">    0     1                            1000 mov  flag, %ax</span><br><span class="line">    0     1                            1001 test $0, %ax</span><br><span class="line">    0     1                            1002 jne  .acquire</span><br><span class="line">    1     1                            1003 mov  $1, flag</span><br><span class="line">    1     1                            1004 mov  count, %ax</span><br><span class="line">    1     1                            1005 add  $1, %ax</span><br><span class="line">    1     2                            1006 mov  %ax, count</span><br><span class="line">    0     2                            1007 mov  $0, flag</span><br><span class="line">    0     2                            1008 sub  $1, %bx</span><br><span class="line">    0     2                            1009 test $0, %bx</span><br><span class="line">    0     2                            1010 jgt .top</span><br><span class="line">    0     2                            1011 halt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>28.3：使用-a 标志更改寄存器%bx 的值（例如，如果只运行两个线程，就用-a bx &#x3D; 2，bx &#x3D;2）。代码是做什么的？对这段代码问上面的问题，答案如何？</strong></p>
<p>将寄存器 bx 改为 2 之后，一个线程会两次进入临界区对全局变量 count 进行加 1 操作。从运行结果来看，线程 0 两次获取锁并修改 count 值，同样的，线程 1 也两次获取锁并修改了 count 值，最终 flag 的值为 0，count 等于 4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">1000 mov  flag, %ax</span><br><span class="line">1001 test $0, %ax</span><br><span class="line">1002 jne  .acquire</span><br><span class="line">1003 mov  $1, flag</span><br><span class="line">1004 mov  count, %ax</span><br><span class="line">1005 add  $1, %ax</span><br><span class="line">1006 mov  %ax, count</span><br><span class="line">1007 mov  $0, flag</span><br><span class="line">1008 sub  $1, %bx</span><br><span class="line">1009 test $0, %bx</span><br><span class="line">1010 jgt .top</span><br><span class="line">1000 mov  flag, %ax</span><br><span class="line">1001 test $0, %ax</span><br><span class="line">1002 jne  .acquire</span><br><span class="line">1003 mov  $1, flag</span><br><span class="line">1004 mov  count, %ax</span><br><span class="line">1005 add  $1, %ax</span><br><span class="line">1006 mov  %ax, count</span><br><span class="line">1007 mov  $0, flag</span><br><span class="line">1008 sub  $1, %bx</span><br><span class="line">1009 test $0, %bx</span><br><span class="line">1010 jgt .top</span><br><span class="line">1011 halt</span><br><span class="line">----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">                         1000 mov  flag, %ax</span><br><span class="line">                         1001 test $0, %ax</span><br><span class="line">                         1002 jne  .acquire</span><br><span class="line">                         1003 mov  $1, flag</span><br><span class="line">                         1004 mov  count, %ax</span><br><span class="line">                         1005 add  $1, %ax</span><br><span class="line">                         1006 mov  %ax, count</span><br><span class="line">                         1007 mov  $0, flag</span><br><span class="line">                         1008 sub  $1, %bx</span><br><span class="line">                         1009 test $0, %bx</span><br><span class="line">                         1010 jgt .top</span><br><span class="line">                         1000 mov  flag, %ax</span><br><span class="line">                         1001 test $0, %ax</span><br><span class="line">                         1002 jne  .acquire</span><br><span class="line">                         1003 mov  $1, flag</span><br><span class="line">                         1004 mov  count, %ax</span><br><span class="line">                         1005 add  $1, %ax</span><br><span class="line">                         1006 mov  %ax, count</span><br><span class="line">                         1007 mov  $0, flag</span><br><span class="line">                         1008 sub  $1, %bx</span><br><span class="line">                         1009 test $0, %bx</span><br><span class="line">                         1010 jgt .top</span><br><span class="line">                         1011 halt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>28.4：对每个线程将 bx 设置为高值，然后使用-i 标志生成不同的中断频率。什么值导致产生不好的结果？什么值导致产生良好的结果？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-locks$ python2 ./x86.py -p flag.s -M flag,count  -c -a bx=2,bx=2  -i 2</span><br><span class="line">ARG seed 0</span><br><span class="line">ARG numthreads 2</span><br><span class="line">ARG program flag.s</span><br><span class="line">ARG interrupt frequency 2</span><br><span class="line">ARG interrupt randomness False</span><br><span class="line">ARG procsched</span><br><span class="line">ARG argv bx=2,bx=2</span><br><span class="line">ARG load address 1000</span><br><span class="line">ARG memsize 128</span><br><span class="line">ARG memtrace flag,count</span><br><span class="line">ARG regtrace</span><br><span class="line">ARG cctrace False</span><br><span class="line">ARG printstats False</span><br><span class="line">ARG verbose False</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> flag count          Thread 0                Thread 1</span><br><span class="line"></span><br><span class="line">    0     0</span><br><span class="line">    0     0   1000 mov  flag, %ax</span><br><span class="line">    0     0   1001 test $0, %ax</span><br><span class="line">    0     0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0     0                            1000 mov  flag, %ax</span><br><span class="line">    0     0                            1001 test $0, %ax</span><br><span class="line">    0     0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0     0   1002 jne  .acquire</span><br><span class="line">    1     0   1003 mov  $1, flag</span><br><span class="line">    1     0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     0                            1002 jne  .acquire</span><br><span class="line">    1     0                            1003 mov  $1, flag</span><br><span class="line">    1     0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     0   1004 mov  count, %ax</span><br><span class="line">    1     0   1005 add  $1, %ax</span><br><span class="line">    1     0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     0                            1004 mov  count, %ax</span><br><span class="line">    1     0                            1005 add  $1, %ax</span><br><span class="line">    1     0   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     1   1006 mov  %ax, count</span><br><span class="line">    0     1   1007 mov  $0, flag</span><br><span class="line">    0     1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0     1                            1006 mov  %ax, count</span><br><span class="line">    0     1                            1007 mov  $0, flag</span><br><span class="line">    0     1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0     1   1008 sub  $1, %bx</span><br><span class="line">    0     1   1009 test $0, %bx</span><br><span class="line">    0     1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0     1                            1008 sub  $1, %bx</span><br><span class="line">    0     1                            1009 test $0, %bx</span><br><span class="line">    0     1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0     1   1010 jgt .top</span><br><span class="line">    0     1   1000 mov  flag, %ax</span><br><span class="line">    0     1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0     1                            1010 jgt .top</span><br><span class="line">    0     1                            1000 mov  flag, %ax</span><br><span class="line">    0     1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0     1   1001 test $0, %ax</span><br><span class="line">    0     1   1002 jne  .acquire</span><br><span class="line">    0     1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0     1                            1001 test $0, %ax</span><br><span class="line">    0     1                            1002 jne  .acquire</span><br><span class="line">    0     1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     1   1003 mov  $1, flag</span><br><span class="line">    1     1   1004 mov  count, %ax</span><br><span class="line">    1     1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     1                            1003 mov  $1, flag</span><br><span class="line">    1     1                            1004 mov  count, %ax</span><br><span class="line">    1     1   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     1   1005 add  $1, %ax</span><br><span class="line">    1     2   1006 mov  %ax, count</span><br><span class="line">    1     2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    1     2                            1005 add  $1, %ax</span><br><span class="line">    1     2                            1006 mov  %ax, count</span><br><span class="line">    1     2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0     2   1007 mov  $0, flag</span><br><span class="line">    0     2   1008 sub  $1, %bx</span><br><span class="line">    0     2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0     2                            1007 mov  $0, flag</span><br><span class="line">    0     2                            1008 sub  $1, %bx</span><br><span class="line">    0     2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0     2   1009 test $0, %bx</span><br><span class="line">    0     2   1010 jgt .top</span><br><span class="line">    0     2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0     2                            1009 test $0, %bx</span><br><span class="line">    0     2                            1010 jgt .top</span><br><span class="line">    0     2   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    0     2   1011 halt</span><br><span class="line">    0     2   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">    0     2                            1011 halt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>28.5：现在让我们看看程序 test-and-set.s。首先，尝试理解使用 xchg 指令构建简单锁原语的代码。获取锁怎么写？释放锁如何写？</strong></p>
<p>汇编代码如下，xchg 指令交换 ax（1）和 mutex 的值，如果当前锁未被持有，则 ax 会返回 0，并且 mutex 置 1，成功获取锁。如果当前锁已被持有，则 ax 返回 1，继续尝试获取锁。释放锁即将 mutex 修改为 0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.var mutex</span><br><span class="line">.var count</span><br><span class="line"></span><br><span class="line">.main</span><br><span class="line">.top</span><br><span class="line"></span><br><span class="line">.acquire</span><br><span class="line">mov  $<span class="number">1</span>, %ax</span><br><span class="line">xchg %ax, mutex     #原子地交换ax%和mutex的值</span><br><span class="line">test $<span class="number">0</span>, %ax        #如果返回<span class="number">0</span>，则说明锁还未被持有，获取锁。</span><br><span class="line">jne  .acquire</span><br><span class="line"></span><br><span class="line"><span class="meta"># critical section</span></span><br><span class="line">mov  count, %ax     <span class="meta"># get the value at the address</span></span><br><span class="line">add  $<span class="number">1</span>, %ax        <span class="meta"># increment it</span></span><br><span class="line">mov  %ax, count     <span class="meta"># store it back</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># release lock</span></span><br><span class="line">mov  $<span class="number">0</span>, mutex</span><br><span class="line"></span><br><span class="line"><span class="meta"># see <span class="keyword">if</span> we<span class="string">&#x27;re still looping</span></span></span><br><span class="line"><span class="string"><span class="meta">sub  $1, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">test $0, %bx</span></span></span><br><span class="line"><span class="string"><span class="meta">jgt .top</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">halt</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br></pre></td></tr></table></figure>

<p><strong>28.6：现在运行代码，再次更改中断间隔（-i）的值，并确保循环多次。代码是否总能按预期工作？有时会导致 CPU 使用率不高吗？如何量化呢？</strong></p>
<p>分别运行命令行</p>
<p>python2 x86.py -p test-and-set.s -a bx&#x3D;2,bx&#x3D;2 -M count -c -i 1<br>python2 x86.py -p test-and-set.s -a bx&#x3D;2,bx&#x3D;2 -M count -c -i 2<br>python2 x86.py -p test-and-set.s -a bx&#x3D;2,bx&#x3D;2 -M count -c -i 3</p>
<p>可以得出结论</p>
<p>代码是否总能按预期工作, 单核 cpu 情况下,当一个线程持有锁进入临界区时被抢占,抢占的线程将会自旋一个时间片,导致 cpu 利用率不高,<br>量化:计算 当一个线程持有锁进入临界区时被抢占,抢占线程的自旋时间长与总时间长百分比即可</p>
<p><strong>28.7：使用-P 标志生成锁相关代码的特定测试。例如，执行一个测试计划，在第一个线程中获取锁，但随后尝试在第二个线程中获取锁。正确的事情发生了吗？</strong></p>
<p>执行命令行<code>python2 x86.py -p test-and-set.s -M mutex,count -R ax,ybx -c -a bx=2,bx=2 -P 0011111</code></p>
<p>运行结果如下：</p>
<p>可以看到线程 0 先获取了锁，这时候发生中断，切换到线程 1，尝试获取锁失败。但线程 0 释放锁后，线程 1 才成功获取锁，运行结果正确。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mutex count      ax    bx          Thread <span class="number">0</span>                Thread <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0</span>     <span class="number">0</span>       <span class="number">0</span>     <span class="number">2</span></span><br><span class="line">    <span class="number">0</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>   <span class="number">1000</span> mov  $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">0</span>     <span class="number">2</span>   <span class="number">1001</span> xchg %ax, mutex</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">0</span>     <span class="number">2</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1000</span> mov  $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1001</span> xchg %ax, mutex</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1002</span> test $<span class="number">0</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1003</span> jne  .acquire</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1000</span> mov  $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">0</span>     <span class="number">2</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">0</span>     <span class="number">2</span>   <span class="number">1002</span> test $<span class="number">0</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">0</span>     <span class="number">2</span>   <span class="number">1003</span> jne  .acquire</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1001</span> xchg %ax, mutex</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1002</span> test $<span class="number">0</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1003</span> jne  .acquire</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1000</span> mov  $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1001</span> xchg %ax, mutex</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">0</span>     <span class="number">2</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">0</span>     <span class="number">2</span>   <span class="number">1004</span> mov  count, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>   <span class="number">1005</span> add  $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1002</span> test $<span class="number">0</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1003</span> jne  .acquire</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1000</span> mov  $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1001</span> xchg %ax, mutex</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1002</span> test $<span class="number">0</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">0</span>       <span class="number">1</span>     <span class="number">2</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    <span class="number">1</span>     <span class="number">1</span>       <span class="number">1</span>     <span class="number">2</span>   <span class="number">1006</span> mov  %ax, count</span><br><span class="line">    <span class="number">0</span>     <span class="number">1</span>       <span class="number">1</span>     <span class="number">2</span>   <span class="number">1007</span> mov  $<span class="number">0</span>, mutex</span><br><span class="line">    <span class="number">0</span>     <span class="number">1</span>       <span class="number">1</span>     <span class="number">2</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    <span class="number">0</span>     <span class="number">1</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1003</span> jne  .acquire</span><br><span class="line">    <span class="number">0</span>     <span class="number">1</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1000</span> mov  $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">1</span>       <span class="number">0</span>     <span class="number">2</span>                            <span class="number">1001</span> xchg %ax, mutex</span><br><span class="line">    <span class="number">1</span>     <span class="number">1</span>       <span class="number">0</span>     <span class="number">2</span>                            <span class="number">1002</span> test $<span class="number">0</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">1</span>       <span class="number">0</span>     <span class="number">2</span>                            <span class="number">1003</span> jne  .acquire</span><br><span class="line">    <span class="number">1</span>     <span class="number">1</span>       <span class="number">1</span>     <span class="number">2</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    <span class="number">1</span>     <span class="number">1</span>       <span class="number">1</span>     <span class="number">1</span>   <span class="number">1008</span> sub  $<span class="number">1</span>, %bx</span><br><span class="line">    <span class="number">1</span>     <span class="number">1</span>       <span class="number">1</span>     <span class="number">1</span>   <span class="number">1009</span> test $<span class="number">0</span>, %bx</span><br><span class="line">    <span class="number">1</span>     <span class="number">1</span>       <span class="number">0</span>     <span class="number">2</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    <span class="number">1</span>     <span class="number">1</span>       <span class="number">1</span>     <span class="number">2</span>                            <span class="number">1004</span> mov  count, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">1</span>       <span class="number">2</span>     <span class="number">2</span>                            <span class="number">1005</span> add  $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">2</span>       <span class="number">2</span>     <span class="number">2</span>                            <span class="number">1006</span> mov  %ax, count</span><br><span class="line">    <span class="number">0</span>     <span class="number">2</span>       <span class="number">2</span>     <span class="number">2</span>                            <span class="number">1007</span> mov  $<span class="number">0</span>, mutex</span><br><span class="line">    <span class="number">0</span>     <span class="number">2</span>       <span class="number">2</span>     <span class="number">1</span>                            <span class="number">1008</span> sub  $<span class="number">1</span>, %bx</span><br><span class="line">    <span class="number">0</span>     <span class="number">2</span>       <span class="number">1</span>     <span class="number">1</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    <span class="number">0</span>     <span class="number">2</span>       <span class="number">1</span>     <span class="number">1</span>   <span class="number">1010</span> jgt .top</span><br><span class="line">    <span class="number">0</span>     <span class="number">2</span>       <span class="number">1</span>     <span class="number">1</span>   <span class="number">1000</span> mov  $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">0</span>     <span class="number">2</span>       <span class="number">2</span>     <span class="number">1</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    <span class="number">0</span>     <span class="number">2</span>       <span class="number">2</span>     <span class="number">1</span>                            <span class="number">1009</span> test $<span class="number">0</span>, %bx</span><br><span class="line">    <span class="number">0</span>     <span class="number">2</span>       <span class="number">2</span>     <span class="number">1</span>                            <span class="number">1010</span> jgt .top</span><br><span class="line">    <span class="number">0</span>     <span class="number">2</span>       <span class="number">1</span>     <span class="number">1</span>                            <span class="number">1000</span> mov  $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">2</span>       <span class="number">0</span>     <span class="number">1</span>                            <span class="number">1001</span> xchg %ax, mutex</span><br><span class="line">    <span class="number">1</span>     <span class="number">2</span>       <span class="number">0</span>     <span class="number">1</span>                            <span class="number">1002</span> test $<span class="number">0</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">2</span>       <span class="number">1</span>     <span class="number">1</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    <span class="number">1</span>     <span class="number">2</span>       <span class="number">1</span>     <span class="number">1</span>   <span class="number">1001</span> xchg %ax, mutex</span><br><span class="line">    <span class="number">1</span>     <span class="number">2</span>       <span class="number">1</span>     <span class="number">1</span>   <span class="number">1002</span> test $<span class="number">0</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">2</span>       <span class="number">0</span>     <span class="number">1</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    <span class="number">1</span>     <span class="number">2</span>       <span class="number">0</span>     <span class="number">1</span>                            <span class="number">1003</span> jne  .acquire</span><br><span class="line">    <span class="number">1</span>     <span class="number">2</span>       <span class="number">2</span>     <span class="number">1</span>                            <span class="number">1004</span> mov  count, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">2</span>       <span class="number">3</span>     <span class="number">1</span>                            <span class="number">1005</span> add  $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">3</span>       <span class="number">3</span>     <span class="number">1</span>                            <span class="number">1006</span> mov  %ax, count</span><br><span class="line">    <span class="number">0</span>     <span class="number">3</span>       <span class="number">3</span>     <span class="number">1</span>                            <span class="number">1007</span> mov  $<span class="number">0</span>, mutex</span><br><span class="line">    <span class="number">0</span>     <span class="number">3</span>       <span class="number">1</span>     <span class="number">1</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    <span class="number">0</span>     <span class="number">3</span>       <span class="number">1</span>     <span class="number">1</span>   <span class="number">1003</span> jne  .acquire</span><br><span class="line">    <span class="number">0</span>     <span class="number">3</span>       <span class="number">1</span>     <span class="number">1</span>   <span class="number">1000</span> mov  $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">0</span>     <span class="number">3</span>       <span class="number">3</span>     <span class="number">1</span>   ------ Interrupt ------  ------ Interrupt ------</span><br><span class="line">    <span class="number">0</span>     <span class="number">3</span>       <span class="number">3</span>     <span class="number">0</span>                            <span class="number">1008</span> sub  $<span class="number">1</span>, %bx</span><br><span class="line">    <span class="number">0</span>     <span class="number">3</span>       <span class="number">3</span>     <span class="number">0</span>                            <span class="number">1009</span> test $<span class="number">0</span>, %bx</span><br><span class="line">    <span class="number">0</span>     <span class="number">3</span>       <span class="number">3</span>     <span class="number">0</span>                            <span class="number">1010</span> jgt .top</span><br><span class="line">    <span class="number">0</span>     <span class="number">3</span>       <span class="number">3</span>     <span class="number">0</span>                            <span class="number">1011</span> halt</span><br><span class="line">    <span class="number">0</span>     <span class="number">3</span>       <span class="number">1</span>     <span class="number">1</span>   ----- Halt;Switch -----  ----- Halt;Switch -----</span><br><span class="line">    <span class="number">1</span>     <span class="number">3</span>       <span class="number">0</span>     <span class="number">1</span>   <span class="number">1001</span> xchg %ax, mutex</span><br><span class="line">    <span class="number">1</span>     <span class="number">3</span>       <span class="number">0</span>     <span class="number">1</span>   <span class="number">1002</span> test $<span class="number">0</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">3</span>       <span class="number">0</span>     <span class="number">1</span>   <span class="number">1003</span> jne  .acquire</span><br><span class="line">    <span class="number">1</span>     <span class="number">3</span>       <span class="number">3</span>     <span class="number">1</span>   <span class="number">1004</span> mov  count, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">3</span>       <span class="number">4</span>     <span class="number">1</span>   <span class="number">1005</span> add  $<span class="number">1</span>, %ax</span><br><span class="line">    <span class="number">1</span>     <span class="number">4</span>       <span class="number">4</span>     <span class="number">1</span>   <span class="number">1006</span> mov  %ax, count</span><br><span class="line">    <span class="number">0</span>     <span class="number">4</span>       <span class="number">4</span>     <span class="number">1</span>   <span class="number">1007</span> mov  $<span class="number">0</span>, mutex</span><br><span class="line">    <span class="number">0</span>     <span class="number">4</span>       <span class="number">4</span>     <span class="number">0</span>   <span class="number">1008</span> sub  $<span class="number">1</span>, %bx</span><br><span class="line">    <span class="number">0</span>     <span class="number">4</span>       <span class="number">4</span>     <span class="number">0</span>   <span class="number">1009</span> test $<span class="number">0</span>, %bx</span><br><span class="line">    <span class="number">0</span>     <span class="number">4</span>       <span class="number">4</span>     <span class="number">0</span>   <span class="number">1010</span> jgt .top</span><br><span class="line">    <span class="number">0</span>     <span class="number">4</span>       <span class="number">4</span>     <span class="number">0</span>   <span class="number">1011</span> halt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第-30-章"><a href="#第-30-章" class="headerlink" title="第 30 章"></a>第 30 章</h2><h4 id="30-1"><a href="#30-1" class="headerlink" title="30.1"></a><strong>30.1</strong></h4><p><strong>我们的第一个问题集中在 main-two-cvs-while.c（有效的解决方案）上。 首先，研究代码。 你认为你了解当你运行程序时会发生什么吗？</strong></p>
<p>程序实现了一个典型的单值缓冲区生产者消费者问题，生产者把生成的数据项放入缓冲区；消费者从缓冲区取走数据项。并且保证了临界区的原子操作。</p>
<p>运行<code>./main-two-cvs-while -l 3 -m 2 -p 1 -c 1 -v</code>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  NF             P0 C0</span><br><span class="line">  0 [*---  --- ] p0</span><br><span class="line">  0 [*---  --- ]    c0</span><br><span class="line">  0 [*---  --- ]    c1</span><br><span class="line">  0 [*---  --- ]    c2</span><br><span class="line">  0 [*---  --- ] p1</span><br><span class="line">  1 [u  0 f--- ] p4</span><br><span class="line">  1 [u  0 f--- ] p5</span><br><span class="line">  1 [u  0 f--- ] p6</span><br><span class="line">  1 [u  0 f--- ]    c3</span><br><span class="line">  0 [ --- *--- ]    c4</span><br><span class="line">  0 [ --- *--- ] p0</span><br><span class="line">  0 [ --- *--- ]    c5</span><br><span class="line">  0 [ --- *--- ]    c6</span><br><span class="line">  0 [ --- *--- ] p1</span><br><span class="line">  0 [ --- *--- ]    c0</span><br><span class="line">  1 [f--- u  1 ] p4</span><br><span class="line">  1 [f--- u  1 ] p5</span><br><span class="line">  1 [f--- u  1 ] p6</span><br><span class="line">  1 [f--- u  1 ]    c1</span><br><span class="line">  0 [*---  --- ]    c4</span><br><span class="line">  0 [*---  --- ] p0</span><br><span class="line">  0 [*---  --- ]    c5</span><br><span class="line">  0 [*---  --- ]    c6</span><br><span class="line">  0 [*---  --- ] p1</span><br><span class="line">  0 [*---  --- ]    c0</span><br><span class="line">  1 [u  2 f--- ] p4</span><br><span class="line">  1 [u  2 f--- ] p5</span><br><span class="line">  1 [u  2 f--- ] p6</span><br><span class="line">  1 [u  2 f--- ]    c1</span><br><span class="line">  0 [ --- *--- ]    c4</span><br><span class="line">  0 [ --- *--- ]    c5</span><br><span class="line">  0 [ --- *--- ]    c6</span><br><span class="line">  1 [f--- uEOS ] [main: added end-of-stream marker]</span><br><span class="line">  1 [f--- uEOS ]    c0</span><br><span class="line">  1 [f--- uEOS ]    c1</span><br><span class="line">  0 [*---  --- ]    c4</span><br><span class="line">  0 [*---  --- ]    c5</span><br><span class="line">  0 [*---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-l &lt;number of items each producer produces&gt;</span><br><span class="line">-m &lt;size of the shared producer/consumer buffer&gt;</span><br><span class="line">-p &lt;number of producers&gt;</span><br><span class="line">-c &lt;number of consumers&gt;</span><br><span class="line">-P &lt;sleep string: how each producer should sleep at various points in execution&gt;</span><br><span class="line">-C &lt;sleep string: how each consumer should sleep at various points in execution&gt;</span><br><span class="line">-v [ verbose flag: trace what is happening and print it ]</span><br><span class="line">-t [ timing flag: time entire execution and print total time ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="30-2"><a href="#30-2" class="headerlink" title="30.2"></a><strong>30.2</strong></h4><p><strong>指定一个生产者和一个消费者运行，并让生产者产生一些元素。</strong><br><strong>缓冲区大小从 1 开始，然后增加。随着缓冲区大小增加，程序运行结果如何改变？</strong></p>
<p><strong>当使用不同的缓冲区大小(例如 -m 10)，生产者生产不同的产品数量(例如 -l 100)，</strong><br><strong>修改消费者的睡眠字符串(例如 -C 0,0,0,0,0,0,1)，full_num 的值如何变化？</strong></p>
<p>1.运行</p>
<p><code>./main-two-cvs-while -l 3 -m 1 -p 1 -c 1 -v</code><br><code>./main-two-cvs-while -l 3 -m 2 -p 1 -c 1 -v</code><br><code>./main-two-cvs-while -l 3 -m 3 -p 1 -c 1 -v</code><br><code>./main-two-cvs-while -l 3 -m 4 -p 1 -c 1 -v</code></p>
<p>从运行结果可以看出，每次消费者的消费总量都为 3，full num 都为 0</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -l 3 -m 1 -p 1 -c 1 -v</span><br><span class="line"> NF        P0 C0</span><br><span class="line">  0 [*--- ] p0</span><br><span class="line">  0 [*--- ]    c0</span><br><span class="line">  0 [*--- ]    c1</span><br><span class="line">  0 [*--- ]    c2</span><br><span class="line">  0 [*--- ] p1</span><br><span class="line">  1 [*  0 ] p4</span><br><span class="line">  1 [*  0 ] p5</span><br><span class="line">  1 [*  0 ] p6</span><br><span class="line">  1 [*  0 ]    c3</span><br><span class="line">  1 [*  0 ] p0</span><br><span class="line">  0 [*--- ]    c4</span><br><span class="line">  0 [*--- ]    c5</span><br><span class="line">  0 [*--- ]    c6</span><br><span class="line">  0 [*--- ] p1</span><br><span class="line">  1 [*  1 ] p4</span><br><span class="line">  1 [*  1 ]    c0</span><br><span class="line">  1 [*  1 ] p5</span><br><span class="line">  1 [*  1 ] p6</span><br><span class="line">  1 [*  1 ]    c1</span><br><span class="line">  1 [*  1 ] p0</span><br><span class="line">  0 [*--- ]    c4</span><br><span class="line">  0 [*--- ]    c5</span><br><span class="line">  0 [*--- ]    c6</span><br><span class="line">  0 [*--- ] p1</span><br><span class="line">  0 [*--- ]    c0</span><br><span class="line">  1 [*  2 ] p4</span><br><span class="line">  1 [*  2 ] p5</span><br><span class="line">  1 [*  2 ] p6</span><br><span class="line">  1 [*  2 ]    c1</span><br><span class="line">  0 [*--- ]    c4</span><br><span class="line">  0 [*--- ]    c5</span><br><span class="line">  1 [*EOS ] [main: added end-of-stream marker]</span><br><span class="line">  1 [*EOS ]    c6</span><br><span class="line">  1 [*EOS ]    c0</span><br><span class="line">  1 [*EOS ]    c1</span><br><span class="line">  0 [*--- ]    c4</span><br><span class="line">  0 [*--- ]    c5</span><br><span class="line">  0 [*--- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 3</span><br><span class="line"></span><br><span class="line">nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -l 3 -m 2 -p 1 -c 1 -v</span><br><span class="line"> NF             P0 C0</span><br><span class="line">  0 [*---  --- ] p0</span><br><span class="line">  0 [*---  --- ]    c0</span><br><span class="line">  0 [*---  --- ]    c1</span><br><span class="line">  0 [*---  --- ]    c2</span><br><span class="line">  0 [*---  --- ] p1</span><br><span class="line">  1 [u  0 f--- ] p4</span><br><span class="line">  1 [u  0 f--- ] p5</span><br><span class="line">  1 [u  0 f--- ] p6</span><br><span class="line">  1 [u  0 f--- ] p0</span><br><span class="line">  1 [u  0 f--- ]    c3</span><br><span class="line">  0 [ --- *--- ]    c4</span><br><span class="line">  0 [ --- *--- ]    c5</span><br><span class="line">  0 [ --- *--- ]    c6</span><br><span class="line">  0 [ --- *--- ] p1</span><br><span class="line">  0 [ --- *--- ]    c0</span><br><span class="line">  1 [f--- u  1 ] p4</span><br><span class="line">  1 [f--- u  1 ] p5</span><br><span class="line">  1 [f--- u  1 ] p6</span><br><span class="line">  1 [f--- u  1 ]    c1</span><br><span class="line">  0 [*---  --- ]    c4</span><br><span class="line">  0 [*---  --- ] p0</span><br><span class="line">  0 [*---  --- ]    c5</span><br><span class="line">  0 [*---  --- ]    c6</span><br><span class="line">  0 [*---  --- ] p1</span><br><span class="line">  1 [u  2 f--- ] p4</span><br><span class="line">  1 [u  2 f--- ]    c0</span><br><span class="line">  1 [u  2 f--- ] p5</span><br><span class="line">  1 [u  2 f--- ] p6</span><br><span class="line">  1 [u  2 f--- ]    c1</span><br><span class="line">  0 [ --- *--- ]    c4</span><br><span class="line">  0 [ --- *--- ]    c5</span><br><span class="line">  0 [ --- *--- ]    c6</span><br><span class="line">  1 [f--- uEOS ] [main: added end-of-stream marker]</span><br><span class="line">  1 [f--- uEOS ]    c0</span><br><span class="line">  1 [f--- uEOS ]    c1</span><br><span class="line">  0 [*---  --- ]    c4</span><br><span class="line">  0 [*---  --- ]    c5</span><br><span class="line">  0 [*---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 3</span><br><span class="line"></span><br><span class="line">nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -l 3 -m 3 -p 1 -c 1 -v</span><br><span class="line"> NF                  P0 C0</span><br><span class="line">  0 [*---  ---  --- ] p0</span><br><span class="line">  0 [*---  ---  --- ]    c0</span><br><span class="line">  0 [*---  ---  --- ]    c1</span><br><span class="line">  0 [*---  ---  --- ]    c2</span><br><span class="line">  0 [*---  ---  --- ] p1</span><br><span class="line">  1 [u  0 f---  --- ] p4</span><br><span class="line">  1 [u  0 f---  --- ] p5</span><br><span class="line">  1 [u  0 f---  --- ] p6</span><br><span class="line">  1 [u  0 f---  --- ]    c3</span><br><span class="line">  0 [ --- *---  --- ]    c4</span><br><span class="line">  0 [ --- *---  --- ] p0</span><br><span class="line">  0 [ --- *---  --- ]    c5</span><br><span class="line">  0 [ --- *---  --- ]    c6</span><br><span class="line">  0 [ --- *---  --- ] p1</span><br><span class="line">  0 [ --- *---  --- ]    c0</span><br><span class="line">  1 [ --- u  1 f--- ] p4</span><br><span class="line">  1 [ --- u  1 f--- ] p5</span><br><span class="line">  1 [ --- u  1 f--- ] p6</span><br><span class="line">  1 [ --- u  1 f--- ]    c1</span><br><span class="line">  0 [ ---  --- *--- ]    c4</span><br><span class="line">  0 [ ---  --- *--- ] p0</span><br><span class="line">  0 [ ---  --- *--- ]    c5</span><br><span class="line">  0 [ ---  --- *--- ]    c6</span><br><span class="line">  0 [ ---  --- *--- ] p1</span><br><span class="line">  1 [f---  --- u  2 ] p4</span><br><span class="line">  1 [f---  --- u  2 ]    c0</span><br><span class="line">  1 [f---  --- u  2 ] p5</span><br><span class="line">  1 [f---  --- u  2 ] p6</span><br><span class="line">  1 [f---  --- u  2 ]    c1</span><br><span class="line">  0 [*---  ---  --- ]    c4</span><br><span class="line">  0 [*---  ---  --- ]    c5</span><br><span class="line">  0 [*---  ---  --- ]    c6</span><br><span class="line">  1 [uEOS f---  --- ] [main: added end-of-stream marker]</span><br><span class="line">  1 [uEOS f---  --- ]    c0</span><br><span class="line">  1 [uEOS f---  --- ]    c1</span><br><span class="line">  0 [ --- *---  --- ]    c4</span><br><span class="line">  0 [ --- *---  --- ]    c5</span><br><span class="line">  0 [ --- *---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 3</span><br><span class="line"></span><br><span class="line">nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -l 3 -m 4 -p 1 -c 1 -v</span><br><span class="line"> NF                       P0 C0</span><br><span class="line">  0 [*---  ---  ---  --- ] p0</span><br><span class="line">  0 [*---  ---  ---  --- ]    c0</span><br><span class="line">  0 [*---  ---  ---  --- ]    c1</span><br><span class="line">  0 [*---  ---  ---  --- ]    c2</span><br><span class="line">  0 [*---  ---  ---  --- ] p1</span><br><span class="line">  1 [u  0 f---  ---  --- ] p4</span><br><span class="line">  1 [u  0 f---  ---  --- ] p5</span><br><span class="line">  1 [u  0 f---  ---  --- ] p6</span><br><span class="line">  1 [u  0 f---  ---  --- ] p0</span><br><span class="line">  1 [u  0 f---  ---  --- ]    c3</span><br><span class="line">  0 [ --- *---  ---  --- ]    c4</span><br><span class="line">  0 [ --- *---  ---  --- ]    c5</span><br><span class="line">  0 [ --- *---  ---  --- ]    c6</span><br><span class="line">  0 [ --- *---  ---  --- ] p1</span><br><span class="line">  1 [ --- u  1 f---  --- ] p4</span><br><span class="line">  1 [ --- u  1 f---  --- ]    c0</span><br><span class="line">  1 [ --- u  1 f---  --- ] p5</span><br><span class="line">  1 [ --- u  1 f---  --- ] p6</span><br><span class="line">  1 [ --- u  1 f---  --- ]    c1</span><br><span class="line">  1 [ --- u  1 f---  --- ] p0</span><br><span class="line">  0 [ ---  --- *---  --- ]    c4</span><br><span class="line">  0 [ ---  --- *---  --- ]    c5</span><br><span class="line">  0 [ ---  --- *---  --- ]    c6</span><br><span class="line">  0 [ ---  --- *---  --- ]    c0</span><br><span class="line">  0 [ ---  --- *---  --- ] p1</span><br><span class="line">  1 [ ---  --- u  2 f--- ] p4</span><br><span class="line">  1 [ ---  --- u  2 f--- ] p5</span><br><span class="line">  1 [ ---  --- u  2 f--- ] p6</span><br><span class="line">  1 [ ---  --- u  2 f--- ]    c1</span><br><span class="line">  0 [ ---  ---  --- *--- ]    c4</span><br><span class="line">  0 [ ---  ---  --- *--- ]    c5</span><br><span class="line">  1 [f---  ---  --- uEOS ] [main: added end-of-stream marker]</span><br><span class="line">  1 [f---  ---  --- uEOS ]    c6</span><br><span class="line">  1 [f---  ---  --- uEOS ]    c0</span><br><span class="line">  1 [f---  ---  --- uEOS ]    c1</span><br><span class="line">  0 [*---  ---  ---  --- ]    c4</span><br><span class="line">  0 [*---  ---  ---  --- ]    c5</span><br><span class="line">  0 [*---  ---  ---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行以下命令行</p>
<p><code>./main-two-cvs-while -l 4 -m 10 -p 1 -c 1 -v -C 0,0,0,0,0,0,1</code><br><code>./main-two-cvs-while -l 4 -m 10 -p 1 -c 1 -v -C 1,0,2,0,0,0,1</code><br><code>./main-two-cvs-while -l 4 -m 10 -p 1 -c 1 -v -C 0,1,0,0,0,0,1</code><br><code>./main-two-cvs-while -l 4 -m 10 -p 1 -c 1 -v -C 0,0,2,0,0,0,1</code></p>
<p>从运行结果来看，保证生产者每次的生产数量和缓存区的大小不变，修改消费者的睡眠字符串，最终的 full num 仍然不会发生改变，为 0.消费者的消费总量为 4</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -l 4 -m 10 -p 1 -c 1 -v -C 0,0,0,0,0,0,1</span><br><span class="line"> NF                                                     P0 C0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c2</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c3</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ] [main: added end-of-stream marker]</span><br><span class="line">  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c0</span><br><span class="line">  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c4</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c5</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c6</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c0</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c4</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c5</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c6</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c0</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c4</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c5</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c6</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c0</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 4</span><br><span class="line"></span><br><span class="line">nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -l 4 -m 10 -p 1 -c 1 -v -C 1,0,2,0,0,0,1</span><br><span class="line"> NF                                                     P0 C0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  2 [u  0    1 f---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  2 [u  0    1 f---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  2 [u  0    1 f---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  2 [u  0    1 f---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  2 [u  0    1 f---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  3 [u  0    1    2 f---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  3 [u  0    1    2 f---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  3 [u  0    1    2 f---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  3 [u  0    1    2 f---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  3 [u  0    1    2 f---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  4 [u  0    1    2    3 f---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  4 [u  0    1    2    3 f---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  4 [u  0    1    2    3 f---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  5 [u  0    1    2    3  EOS f---  ---  ---  ---  --- ] [main: added end-of-stream marker]</span><br><span class="line">  5 [u  0    1    2    3  EOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c4</span><br><span class="line">  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c5</span><br><span class="line">  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c6</span><br><span class="line">  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c0</span><br><span class="line">  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c4</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c5</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c6</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c0</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c4</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c5</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c6</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c0</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c4</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c5</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c6</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c0</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 4</span><br><span class="line"></span><br><span class="line">nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -l 4 -m 10 -p 1 -c 1 -v -C 0,1,0,0,0,0,1</span><br><span class="line"> NF                                                     P0 C0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c2</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c3</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ] [main: added end-of-stream marker]</span><br><span class="line">  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c0</span><br><span class="line">  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c4</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c5</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c6</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c0</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c4</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c5</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c6</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c0</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c4</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c5</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c6</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c0</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 4</span><br><span class="line"></span><br><span class="line">nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -l 4 -m 10 -p 1 -c 1 -v -C 0,0,2,0,0,0,1</span><br><span class="line"> NF                                                     P0 C0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ]    c0</span><br><span class="line">  0 [*---  ---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ]    c1</span><br><span class="line">  1 [u  0 f---  ---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ]    c6</span><br><span class="line">  0 [ --- *---  ---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  1 [ --- u  1 f---  ---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p0</span><br><span class="line">  2 [ --- u  1    2 f---  ---  ---  ---  ---  ---  --- ] p1</span><br><span class="line">  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p4</span><br><span class="line">  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p5</span><br><span class="line">  3 [ --- u  1    2    3 f---  ---  ---  ---  ---  --- ] p6</span><br><span class="line">  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ] [main: added end-of-stream marker]</span><br><span class="line">  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c0</span><br><span class="line">  4 [ --- u  1    2    3  EOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c4</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c5</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c6</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c0</span><br><span class="line">  3 [ ---  --- u  2    3  EOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c4</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c5</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c6</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c0</span><br><span class="line">  2 [ ---  ---  --- u  3  EOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c4</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c5</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c6</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c0</span><br><span class="line">  1 [ ---  ---  ---  --- uEOS f---  ---  ---  ---  --- ]    c1</span><br><span class="line">  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c4</span><br><span class="line">  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c5</span><br><span class="line">  0 [ ---  ---  ---  ---  --- *---  ---  ---  ---  --- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="30-4"><a href="#30-4" class="headerlink" title="30.4"></a><strong>30.4</strong></h4><p><strong>我们来看一些 timings。 对于一个生产者，三个消费者，大小为 1 的共享缓冲区以及每个消费者在 c3 点暂停一秒，您认为需要执行多长时间？</strong></p>
<p>指定一个生产者，三个消费者，缓冲区大小为 1 ，消费者睡眠串均为<code>0，0，0，1，0，0</code></p>
<p><code>./main-two-cvs-while -p 1 -c 3 -m 1 -C 0,0,0,1,0,0,0:0,0,0,1,0,0,0:0,0,0,1,0,0,0 -l 10 -v -t</code></p>
<p>运行结果如下：</p>
<p>如果消费者线程先执行，那么执行时间为 13s，</p>
<p>如果生产者者线程先执行，那么执行时间为 12s</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -p 1 -c 3 -m 1 -C 0,0,0,1,0,0,0:0,0,0,1,0,0,0:0,0,0,1,0,0,0 -l 10 -v -t</span><br><span class="line"> NF        P0 C0 C1 C2</span><br><span class="line">  0 [*--- ] p0</span><br><span class="line">  0 [*--- ]    c0</span><br><span class="line">  0 [*--- ]       c0</span><br><span class="line">  0 [*--- ]          c0</span><br><span class="line">  0 [*--- ] p1</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br><span class="line">  1 [*EOS ]       c3</span><br><span class="line">  0 [*--- ]       c4</span><br><span class="line">  0 [*--- ]       c5</span><br><span class="line">  0 [*--- ]       c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 1</span><br><span class="line">  C1 -&gt; 2</span><br><span class="line">  C2 -&gt; 7</span><br><span class="line"></span><br><span class="line">Total time: 12.04 seconds</span><br><span class="line"></span><br><span class="line">nnilk@nnilk-VirtualBox:~/文档/ostep-homework/threads-cv$ ./main-two-cvs-while -p 1 -c 3 -m 1 -C 0,0,0,1,0,0,0:0,0,0,1,0,0,0:0,0,0,1,0,0,0 -l 10 -v -t</span><br><span class="line"> NF        P0 C0 C1 C2</span><br><span class="line">  0 [*--- ] p0</span><br><span class="line">  0 [*--- ]    c0</span><br><span class="line">  0 [*--- ]       c0</span><br><span class="line">  0 [*--- ]          c0</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  1 [*EOS ] [main: added end-of-stream marker]</span><br><span class="line">  1 [*EOS ]       c6</span><br><span class="line">  1 [*EOS ]    c3</span><br><span class="line">  0 [*--- ]    c4</span><br><span class="line">  0 [*--- ]    c5</span><br><span class="line">  0 [*--- ]    c6</span><br><span class="line"></span><br><span class="line">Consumer consumption:</span><br><span class="line">  C0 -&gt; 1</span><br><span class="line">  C1 -&gt; 0</span><br><span class="line">  C2 -&gt; 9</span><br><span class="line"></span><br><span class="line">Total time: 13.07 seconds</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>30.8</strong></p>
<p><strong>现在让我们看一下 main-one-cv-while.c。您是否可以假设只有一个生产者，一个消费者和一个大小为 1 的缓冲区，配置一个睡眠字符串，让代码运行出现问题</strong></p>
<p>main-one-cv-while.c 没有实现一个单值缓冲区的生产消费者方案，只有一个条件变量 cv，可能存在消费者唤醒消费者，生产者唤醒生产者的错误。</p>
<p>但是在只有一个消费者一个生产者的情况下，不会出现这种错误。所以无法配置一个睡眠字符串让代码运行出现问题。</p>
<p><strong>30.9</strong></p>
<p><strong>现在将消费者数量更改为两个。 为生产者消费者配置睡眠字符串，从而使代码运行出现问题</strong></p>
<p>无法配置睡眠字符串，使得代码运行必定出现问题，这取决于操作系统的线程调度</p>
<p>即使不配置睡眠字符串，也可能出现如下情况：生产者生产后，缓冲区满了，唤醒了两个正在睡眠的消费者中的一个，然后进入睡眠（Mutex_lock）消费者消费后，唤醒另一个消费者，进入睡眠（Mutex_lock），新的消费者线程被唤醒，发现缓冲区为空，进入睡眠（Cond_wait）,此时三个线程都进入睡眠</p>
<p><strong>30.10</strong></p>
<p><strong>现在查看 main-two-cvs-if.c。 您是否可以配置一些参数让代码运行出现问题？ 再次考虑只有一个消费者的情况，然后再考虑有一个以上消费者的情况。</strong></p>
<p>main-two-cvs-if.c 使用 if 语句检查条件，存在一个问题 ，一个线程的被唤醒后，在运行之前，条件变量的值可能发生改变，所以 if 语句单次检查并不安全</p>
<p>先考虑一个消费者的情况，一旦消费者被唤醒，所有生产者都会处于睡眠状态，所以消费者被唤醒后会马上运行，所以不会存在代码运行出现问题的情况</p>
<p>考虑多个消费者的情况，当一个消费者 C0 被唤醒，在他运行之前，另一个消费者 C1 也被唤醒并抢先运行，消耗完了缓冲区的内存，此时消费者 C0 再运行便会发生错误</p>
<p><code>./main-two-cvs-if -m 1 -c 2 -p 1 -l 10 -C 2:0,0,0,3 -P 1</code> 会出现错误</p>
<p><strong>30.11</strong></p>
<p><strong>最后查看 main-two-cvs-while-extra-unlock.c。在向缓冲区添加或取出元素时释放锁时会出现什么问题？给定睡眠字符串来引起这类问题的发生？ 会造成什么不好的结果？</strong></p>
<p>程序 <strong>main-two-cvs-while-extra-unlock.c</strong> 将锁放在了 do_fill() 和 do_get()之外，没有临界区操作的原子性</p>
<p>不需要配置睡眠字符串也会出现上述问题，这取决于操作系统的调度</p>
<h2 id="第-31-章"><a href="#第-31-章" class="headerlink" title="第 31 章"></a>第 31 章</h2><h4 id="31-1"><a href="#31-1" class="headerlink" title="31.1"></a><strong>31.1</strong></h4><p><strong>第一个问题是实现和测试 fork&#x2F;join 问题的解决方案，如文中所述。即使在文本中描述了这个解决方案，自己输入它的行为是值得的。详见 fork-join.c。向子进程添加 sleep(1)调用，以确保它正在工作。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">child</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);<span class="comment">//向子进程添加sleep(1)调用</span></span><br><span class="line">    <span class="comment">// use semaphore here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">parent: begin</span><br><span class="line">child</span><br><span class="line">parent: end</span><br></pre></td></tr></table></figure>

<h4 id="31-2"><a href="#31-2" class="headerlink" title="31.2"></a><strong>31.2</strong></h4><p><strong>现在，我们通过研究集合点问题 <a href="https://en.wikipedia.org/wiki/Rendezvous_problem">rendezvous problem</a> 来对此进行概括。</strong><br><strong>问题如下：您有两个线程，每个线程将要在代码中进入集合点。 任何一方都不应在另一方进入之前退出代码的这一部分。该任务使用两个信号量，有关详细信息，请参见 rendezvous.c。</strong></p>
<p>补充程序代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> &lt;semaphor</span></span><br><span class="line">e.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// If done correctly, each child should print their &quot;before&quot; message</span></span><br><span class="line"><span class="comment">// before either prints their &quot;after&quot; message. Test by adding sleep(1)</span></span><br><span class="line"><span class="comment">// calls in various locations.</span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> s1, s2;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">child_1</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child 1: before\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sem_post(&amp;s2); <span class="comment">//增加信号量s2、</span></span><br><span class="line">    sem_wait(&amp;s1); <span class="comment">//等待信号量s1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child 1: after\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">child_2</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child 2: before\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sem_post(&amp;s1);</span><br><span class="line">    sem_wait(&amp;s2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child 2: after\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> p1, p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">    sem_init(&amp;s1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;s2, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    Pthread_create(&amp;p1, <span class="literal">NULL</span>, child_1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_create(&amp;p2, <span class="literal">NULL</span>, child_2, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(p1, <span class="literal">NULL</span>);</span><br><span class="line">    Pthread_join(p2, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>程序运行结果如下：</strong></p>
<p>可以看到，每个 child 都在打印<code>after</code>之前打印了<code>before</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">parent: begin</span><br><span class="line">child <span class="number">1</span>: before</span><br><span class="line">child <span class="number">2</span>: before</span><br><span class="line">child <span class="number">2</span>: after</span><br><span class="line">child <span class="number">1</span>: after</span><br><span class="line">parent: end</span><br></pre></td></tr></table></figure>

<h4 id="31-4"><a href="#31-4" class="headerlink" title="31.4"></a>31.4</h4><p><strong>现在按照文本中所述，解决读者写者问题。 首先，不用考虑进程饥饿。 有关详细信息，请参见 reader-writer.c 中的代码。 将 sleep（）调用添加到您的代码中，以证明它可以按预期工作。 你能证明饥饿问题的存在吗？</strong></p>
<p>代码实现如下：</p>
<p>读者优先的实现方案，可能存在读者长时间占用 CPU，导致写者饿死的情况</p>
<p>但是此代码不会存在写者饿死的情况，因为读者和写者都会通过循环尝试获取锁</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code goes in the structure and functions below</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">rwlock_t</span> &#123;</span></span><br><span class="line">    <span class="type">sem_t</span> lock;</span><br><span class="line">    <span class="type">sem_t</span> write_lock;</span><br><span class="line">    <span class="type">int</span> reader_number;</span><br><span class="line">&#125; <span class="type">rwlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将读者锁和写者锁初始化为1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_init</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    sem_init(&amp;rw-&gt;lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;rw-&gt;write_lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    rw-&gt;reader_number = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sem_wait(&amp;rw-&gt;lock);</span><br><span class="line">    rw-&gt;reader_number++;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;reader_number == <span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;rw-&gt;write_lock);<span class="comment">//第一个读者获取writer_lock</span></span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;lock);</span><br><span class="line">    rw-&gt;reader_number--;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;reader_number == <span class="number">0</span>) &#123;</span><br><span class="line">        sem_post(&amp;rw-&gt;write_lock); <span class="comment">//最后一个读者释放writer_lock</span></span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sem_wait(&amp;rw-&gt;write_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    sem_post(&amp;rw-&gt;write_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Don&#x27;t change the code below (just use it!)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> loops;</span><br><span class="line"><span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">rwlock_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">reader</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        rwlock_acquire_readlock(&amp;lock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read %d\n&quot;</span>, value);</span><br><span class="line">        rwlock_release_readlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">writer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        rwlock_acquire_writelock(&amp;lock);</span><br><span class="line">        value++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write %d\n&quot;</span>, value);</span><br><span class="line">        rwlock_release_writelock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    assert(argc == <span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> num_readers = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> num_writers = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    loops = atoi(argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> pr[num_readers], pw[num_writers];</span><br><span class="line"></span><br><span class="line">    rwlock_init(&amp;lock);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_readers; i++)</span><br><span class="line">        Pthread_create(&amp;pr[i], <span class="literal">NULL</span>, reader, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_writers; i++)</span><br><span class="line">        Pthread_create(&amp;pw[i], <span class="literal">NULL</span>, writer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_readers; i++)</span><br><span class="line">        Pthread_join(pr[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_writers; i++)</span><br><span class="line">        Pthread_join(pw[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end: value %d\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><code>gcc reader-writer.c -Wall -pthread -g</code><br><code>./a.out 2 2 2</code></p>
<p>（两个读者，两个写者，loop&#x3D;2）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">begin</span><br><span class="line">read <span class="number">0</span></span><br><span class="line">read <span class="number">0</span></span><br><span class="line">write <span class="number">1</span></span><br><span class="line">write <span class="number">2</span></span><br><span class="line">write <span class="number">3</span></span><br><span class="line">read <span class="number">3</span></span><br><span class="line">read <span class="number">3</span></span><br><span class="line">write <span class="number">4</span></span><br><span class="line">end: value <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="31-5"><a href="#31-5" class="headerlink" title="31.5"></a>31.5</h4><p>让我们再次看一下读者写者问题，但这一次需要考虑进程饥饿。 您如何确保所有读者和写者运行？ 有关详细信息，请参见 reader-writer-nostarve.c。</p>
<p>代码实现如下 :</p>
<p>增加一把 writing_waiting 锁，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Your code goes in the structure and functions below</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">rwlock_t</span> &#123;</span></span><br><span class="line">    <span class="type">sem_t</span> lock;</span><br><span class="line">    <span class="type">sem_t</span> write_lock;</span><br><span class="line">    <span class="type">sem_t</span> write_waiting;</span><br><span class="line">    <span class="type">int</span> reader_number;</span><br><span class="line">&#125; <span class="type">rwlock_t</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_init</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    sem_init(&amp;rw-&gt;lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;rw-&gt;write_lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;rw-&gt;write_waiting, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    rw-&gt;reader_number = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sem_wait(&amp;rw-&gt;write_waiting);</span><br><span class="line">    sem_wait(&amp;rw-&gt;lock);</span><br><span class="line">    rw-&gt;reader_number++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;reader_number == <span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;rw-&gt;write_lock);</span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;rw-&gt;lock);</span><br><span class="line">    sem_post(&amp;rw-&gt;write_waiting);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    sem_wait(&amp;rw-&gt;lock);</span><br><span class="line">    rw-&gt;reader_number--;</span><br><span class="line">    <span class="keyword">if</span> (rw-&gt;reader_number == <span class="number">0</span>) &#123;</span><br><span class="line">        sem_post(&amp;rw-&gt;write_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sem_post(&amp;rw-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sem_wait(&amp;rw-&gt;write_waiting);</span><br><span class="line">    sem_wait(&amp;rw-&gt;write_lock);</span><br><span class="line">    sem_post(&amp;rw-&gt;write_waiting);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123;</span><br><span class="line">    sem_post(&amp;rw-&gt;write_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Don&#x27;t change the code below (just use it!)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> loops;</span><br><span class="line"><span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">rwlock_t</span> lock;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">reader</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        rwlock_acquire_readlock(&amp;lock);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read %d\n&quot;</span>, value);</span><br><span class="line">        rwlock_release_readlock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">writer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">        rwlock_acquire_writelock(&amp;lock);</span><br><span class="line">        value++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write %d\n&quot;</span>, value);</span><br><span class="line">        rwlock_release_writelock(&amp;lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    assert(argc == <span class="number">4</span>);</span><br><span class="line">    <span class="type">int</span> num_readers = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">int</span> num_writers = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    loops = atoi(argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> pr[num_readers], pw[num_writers];</span><br><span class="line"></span><br><span class="line">    rwlock_init(&amp;lock);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;begin\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_readers; i++)</span><br><span class="line">        Pthread_create(&amp;pr[i], <span class="literal">NULL</span>, reader, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_writers; i++)</span><br><span class="line">        Pthread_create(&amp;pw[i], <span class="literal">NULL</span>, writer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_readers; i++)</span><br><span class="line">        Pthread_join(pr[i], <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num_writers; i++)</span><br><span class="line">        Pthread_join(pw[i], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;end: value %d\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="31-6"><a href="#31-6" class="headerlink" title="31.6"></a>31.6</h4><p><strong>使用信号量构建一个没有饥饿的互斥量，其中任何试图获取该互斥量的线程都将最终获得它。 有关更多信息，请参见 mutex-nostarve.c 中的代码。</strong></p>
<p>代码实现如下</p>
<p>在每次释放锁之后，确认所有线程都执行过临界区后再继续执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common_threads.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;semaphore.h&quot;</span></span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Here, you have to write (almost) ALL the code. Oh no!</span></span><br><span class="line"><span class="comment">// How can you show that a thread does not starve</span></span><br><span class="line"><span class="comment">// when attempting to acquire this mutex you build?</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">ns_mutex_t</span> &#123;</span></span><br><span class="line">    <span class="type">sem_t</span> mutex;</span><br><span class="line">    <span class="type">sem_t</span> barrier;</span><br><span class="line">    <span class="type">sem_t</span> lock;</span><br><span class="line">    <span class="type">int</span> num_threads;</span><br><span class="line">&#125; <span class="type">ns_mutex_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ns_mutex_t</span> m;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ns_mutex_init</span><span class="params">(<span class="type">ns_mutex_t</span> *m, <span class="type">int</span> num_threads)</span> &#123;</span><br><span class="line">    sem_init(&amp;m-&gt;barrier, <span class="number">0</span>, -num_threads + <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;m-&gt;mutex, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//互斥锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ns_mutex_acquire</span><span class="params">(<span class="type">ns_mutex_t</span> *m)</span> &#123;</span><br><span class="line">    sem_wait(&amp;m-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ns_mutex_release</span><span class="params">(<span class="type">ns_mutex_t</span> *m)</span> &#123;</span><br><span class="line">    sem_post(&amp;m-&gt;lock);</span><br><span class="line"></span><br><span class="line">    sem_post(&amp;m-&gt;barrier);</span><br><span class="line">    sem_wait(&amp;m-&gt;barrier);</span><br><span class="line"></span><br><span class="line">    sem_wait(&amp;m-&gt;mutex);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m-&gt;num_threads; i++) &#123;</span><br><span class="line">        sem_post(&amp;m-&gt;barrier);</span><br><span class="line">        <span class="comment">//确认所有线程都执行过临界区后再继续执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    sem_post(&amp;m-&gt;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>The-Operating-System-Notes</category>
      </categories>
      <tags>
        <tag>operating sysytem</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Xgboost模型详解</title>
    <url>/2022/03/15/xgboost%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Xgboost模型详解"><a href="#Xgboost模型详解" class="headerlink" title="Xgboost模型详解"></a>Xgboost模型详解</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul>
<li>GBDT算法</li>
<li>二阶泰勒展开</li>
</ul>
<h2 id="什么是Xgboost算法？"><a href="#什么是Xgboost算法？" class="headerlink" title="什么是Xgboost算法？"></a>什么是Xgboost算法？</h2><p>XGBoost全名叫（eXtreme Gradient Boosting）极端梯度提升。</p>
<p>GBDT它是一种基于boosting增强策略的加法模型，训练的时候采用前向分布算法进行贪婪的学习，每次迭代都学习一棵CART树来拟合之前 t-1 棵树的预测结果与训练样本真实值的残差。</p>
<p>而Xgboost在核心思想不变的情况下，XGBoost对GBDT进行了一系列优化</p>
<p>1、损失函数进行了二阶泰勒展开</p>
<p>2、目标函数加入正则项</p>
<p>3、支持并行和默认缺失值处理等</p>
<p>4、在可扩展性和训练速度上有了巨大的提升。</p>
<p><strong>模型核心思想</strong>是</p>
<ol>
<li>Boosting提升方法</li>
<li>使用二阶泰勒展开来近似拟合残差：相对于GBDT的一阶导数，XGBoost采用二阶泰勒展开，可以更为精准的逼近真实的损失函数</li>
<li>贪婪方法分裂节点</li>
</ol>
<h2 id="核心算法原理"><a href="#核心算法原理" class="headerlink" title="核心算法原理"></a>核心算法原理</h2><h3 id="01单颗决策树模型表示"><a href="#01单颗决策树模型表示" class="headerlink" title="01单颗决策树模型表示"></a>01单颗决策树模型表示</h3><p>假设某棵决策树有T TT个叶子节点，则单棵决策树模型可记为：</p>
<p>f(x)&#x3D;w <del>q(x)</del></p>
<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232448.png" alt="树与权重向量" style="zoom:50%;">

<p>例如实例落在了第j个叶子结点 ，则其输出的值为 Wj </p>
<p>则叶子结点的向量表示为</p>
<p><em>w</em>&#x3D;(<em>w</em>1,⋯,<em>wj</em>,⋯,<em>wT</em>)</p>
<h3 id="02-集成学习模型结构"><a href="#02-集成学习模型结构" class="headerlink" title="02 集成学习模型结构"></a>02 集成学习模型结构</h3><p>使用Boosting思想，对于实例x，总模型的预测输出为</p>
<p>​                                               <img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232449.png" alt="image-20220315212039282" style="zoom: 80%;"></p>
<p>其中，$f<del>k</del>(x)$  为实例x在第k个决策树的输出</p>
<h3 id="03-损失函数"><a href="#03-损失函数" class="headerlink" title="03 损失函数"></a>03 损失函数</h3><p>上面一部分我们知道了集成学习方法的预测模型，因为XGBoost也是集成学习方法的一种。对于XGBoost的预测模型同样可以表示为：</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232450.png" alt="img"></p>
<p>其中<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232451.png" alt="img">为树的总个数，<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232452.png" alt="img">表示第<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232453.png" alt="img">颗树，<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232454.png" alt="img">表示样本<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232455.png" alt="img">的预测结果。</p>
<p>其中损失函数也同样表示为：</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232456.png" alt="img"></p>
<p>其中<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232457.png" alt="img">为样本<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232458.png" alt="img">的训练误差，<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232459.png" alt="img">表示第<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232500.png" alt="img">棵树的正则项。</p>
<p>其中为树的总个数，表示第颗树，表示样本的预测结果。</p>
<p>其中损失函数也同样表示为：</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232501.png" alt="img"></p>
<p>其中<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232457.png" alt="img">为样本<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232458.png" alt="img">的训练误差，<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232459.png" alt="img">表示第<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232502.png" alt="img">棵树的正则项。</p>
<blockquote>
<p>损失函数，代价函数，目标函数的区别？<br>首先给出结论：</p>
<p>损失函数（Loss Function ）是定义在单个样本上的，算的是一个样本的误差。</p>
<p>代价函数（Cost Function ）是定义在整个训练集上的，是所有样本误差的平均，也就是损失函数的平均。</p>
<p>目标函数（Object Function）定义为：最终需要优化的函数。等于经验风险+结构风险（也就是Cost Function + 正则化项）。</p>
<p>关于目标函数和代价函数的区别还有一种通俗的区别：</p>
<p>目标函数是最大化或者最小化，而代价函数是最小化</p>
</blockquote>
<h2 id="决策树生成细节"><a href="#决策树生成细节" class="headerlink" title="决策树生成细节"></a>决策树生成细节</h2><h3 id="01-如何分裂结点"><a href="#01-如何分裂结点" class="headerlink" title="01 如何分裂结点"></a>01 如何分裂结点</h3><p>在实际训练的第 t 轮，模型都使用贪心法进行树节点的分裂：</p>
<p>对树中的每个叶子结点尝试进行分裂；</p>
<p>每次分裂后，原来的一个叶子结点继续分裂为左右两个子叶子结点，原叶子结点中的样本集将根据该结点的判断规则分散到左右两个叶子结点中；</p>
<p>新分裂一个结点后，我们需要检测这次分裂是否会给损失函数带来增益，增益的定义如下：</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232503.png" alt="image-20220315214343506"></p>
<p>如果L <del>split</del> &gt; 0，或者大于设定的阈值，即分裂后目标函数值下降了，那么可以考虑此次分裂的结果。</p>
<h3 id="02-如何寻找最佳分裂点"><a href="#02-如何寻找最佳分裂点" class="headerlink" title="02 如何寻找最佳分裂点"></a>02 如何寻找最佳分裂点</h3><p>一棵决策树有多个候选分割点，寻找最佳分割点的理论最佳步骤如下：</p>
<ol>
<li><p>遍历每个结点的每个特征；</p>
</li>
<li><p>对每个特征，按特征值大小将特征值排序；</p>
</li>
<li><p>线性扫描，找出每个特征的最佳分裂特征值；</p>
</li>
<li><p>在所有特征中找出最好的分裂点，即分裂后增益最大的特征及特征值</p>
</li>
</ol>
<p>以上为全局扫描法，是一种贪心的方法，每次进行分裂尝试都要遍历一遍全部候选分割点，但不适用数据量过大的条件，如内存无法一次载入或者分布式的情况。</p>
<p>基于此，XGBoost提出了一系列加快寻找最佳分裂点的方案：</p>
<ol>
<li>特征预排序+缓存：XGBoost在训练之前，预先对每个特征按照特征值大小进行排序，然后保存为block结构，后面的迭代中会重复地使用这个结构，使计算量大大减小。</li>
<li>分位点近似法：对每个特征按照特征值排序后，采用类似分位点选取的方式，仅仅选出常数个特征值作为该特征的候选分割点，在寻找该特征的最佳分割点时，从候选分割点中选出最优的一个。</li>
<li>并行查找：由于各个特性已预先存储为block结构，XGBoost支持利用多个线程并行地计算每个特征的最佳分割点，这不仅大大提升了结点的分裂速度，也极利于大规模训练集的适应性扩展。</li>
</ol>
<h3 id="03-如何停止生长"><a href="#03-如何停止生长" class="headerlink" title="03 如何停止生长"></a>03 如何停止生长</h3><p>一棵树不会一直生长下去，除了决策树基础的下面是一些常见的限制条件。</p>
<ol>
<li>设定分裂阈值，当新引入的一次分裂所带来的增益 L <del>split</del>小于阈值时，放弃当前的分裂。</li>
<li>当树达到最大深度时，停止建树，因为树的深度太深容易出现过拟合，这里需要设置一个超参数 max_depth。</li>
<li>当引入一次分裂后，重新计算新生成的左、右两个叶子结点的样本权重和。如果存在一个叶子结点的样本权重低于某一个阈值，也会放弃此次分裂。这涉及到一个超参数：最小样本权重和，是指如果一个叶子节点包含的样本数量太少也会放弃分裂，防止树分的太细，这也是过拟合的一种措施。</li>
</ol>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h4 id="01-XGBoost为什么可以并行训练"><a href="#01-XGBoost为什么可以并行训练" class="headerlink" title="01 XGBoost为什么可以并行训练"></a>01 XGBoost为什么可以并行训练</h4><p>​    XGBoost的并行，并不是说每棵树可以并行训练，XGB本质上仍然采用boosting思想，每棵树训练前需要等前面的树训练完成才能开始训练。XGBoost的并行，指的是特征维度的并行：在训练之前，每个特征按特征值对样本进行预排序，并存储为Block结构，在后面查找特征分割点时可以重复使用，而且特征已经被存储为一个个block结构，那么在寻找每个特征的最佳分割点时，可以利用多线程对每个block并行计算。</p>
<h4 id="02-XGBoost为什么快"><a href="#02-XGBoost为什么快" class="headerlink" title="02 XGBoost为什么快"></a>02 XGBoost为什么快</h4><ul>
<li>分块并行：训练前每个特征按特征值进行排序并存储为Block结构，后面查找特征分割点时重复使用，并且支持并行查找每个特征的分割点</li>
<li>候选分位点：每个特征采用常数个分位点作为候选分割点</li>
<li>CPU cache 命中优化： 使用缓存预取的方法，对每个线程分配一个连续的buffer，读取每个block中样本的梯度信息并存入连续的Buffer中。</li>
<li>Block 处理优化：Block预先放入内存；Block按列进行解压缩；将Block划分到不同硬盘来提高吞吐</li>
</ul>
<h4 id="03-XGBoost防止过拟合的方法"><a href="#03-XGBoost防止过拟合的方法" class="headerlink" title="03 XGBoost防止过拟合的方法"></a>03 XGBoost防止过拟合的方法</h4><ul>
<li>目标函数添加正则项：叶子节点个数+叶子节点权重的L2正则化</li>
<li>列抽样：训练的时候只用一部分特征（不考虑剩余的block块即可）</li>
<li>子采样：每轮计算可以不使用全部样本，使算法更加保守</li>
<li>shrinkage: 可以叫学习率或步长，为了给后面的训练留出更多的学习空间</li>
</ul>
<h4 id="04-XGBoost如何处理缺失值"><a href="#04-XGBoost如何处理缺失值" class="headerlink" title="04 XGBoost如何处理缺失值"></a>04 XGBoost如何处理缺失值</h4><ul>
<li>在特征k上寻找最佳 split point 时，不会对该列特征 missing 的样本进行遍历，而只对该列特征值为 non-missing 的样本上对应的特征值进行遍历，通过这个技巧来减少了为稀疏离散特征寻找 split point 的时间开销。</li>
<li>在逻辑实现上，为了保证完备性，会将该特征值missing的样本分别分配到左叶子结点和右叶子结点，两种情形都计算一遍后，选择分裂后增益最大的那个方向（左分支或是右分支），作为预测时特征值缺失样本的默认分支方向。</li>
<li>如果在训练中没有缺失值而在预测中出现缺失，那么会自动将缺失值的划分方向放到右子结点。</li>
</ul>
<h4 id="05-XGBoost如何处理不平衡数据"><a href="#05-XGBoost如何处理不平衡数据" class="headerlink" title="05 XGBoost如何处理不平衡数据"></a>05 XGBoost如何处理不平衡数据</h4><ul>
<li>如果在意AUC，采用AUC来评估模型的性能，可以通过设置scale_pos_weight来增大少数样本的权重以平衡正样本和负样本的分布。例如当正负样本比例为1:10时，scale_pos_weight可以取10；</li>
<li>如果在意概率(预测得分的合理性)，则不能重新平衡数据集，这会破坏数据的真实分布，应该设置max_delta_step为一个有限数字来帮助收敛（在基模型为LR时有效）。</li>
</ul>
]]></content>
      <categories>
        <category>MachineLearning</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>《Linux命令速查手册》</title>
    <url>/2021/02/11/Linux%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<h1 id="《Linux-命令速查手册》"><a href="#《Linux-命令速查手册》" class="headerlink" title="《Linux 命令速查手册》"></a>《Linux 命令速查手册》</h1><hr>
<h2 id="shell-的作业控制"><a href="#shell-的作业控制" class="headerlink" title="shell 的作业控制"></a>shell 的作业控制</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>jobs</td>
<td>列出作业</td>
</tr>
<tr>
<td>&amp;</td>
<td>在后台运行作业</td>
</tr>
<tr>
<td>Ctrl+Z</td>
<td>挂起当前（前台）作业</td>
</tr>
<tr>
<td>suspend</td>
<td>挂起 shell 的执行</td>
</tr>
<tr>
<td>fg [%jobnumber]</td>
<td>撤销作业的挂起操作，让它在前台运行</td>
</tr>
<tr>
<td>bg [%jobnumber]</td>
<td>让挂起的作业在后台运行</td>
</tr>
</tbody></table>
<hr>
<h2 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ls</td>
<td>列出目录中的文件</td>
</tr>
<tr>
<td>cp</td>
<td>复制文件</td>
</tr>
<tr>
<td>mv</td>
<td>重命名（“移动”）文件</td>
</tr>
<tr>
<td>rm</td>
<td>删除（“移除”）文件</td>
</tr>
<tr>
<td>ln</td>
<td>创建文件链接（替代名称）</td>
</tr>
</tbody></table>
<hr>
<h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>格式：<code>ls [option] [files]</code></p>
<p>作用：列出文件和目录的属性</p>
<p>常用选项：</p>
<p>-a 列出所有的文件，包括文件名以句点开头的文件</p>
<p>-l 长列表，包括文件属性。添加-h 选项后，输出文件大小时，将以千字节、兆字节和千兆字节为单位，而不是以字节为单位</p>
<p>-G 在长列表中，不输出文件的组所有权</p>
<p>-F 用意义明确的符号修饰文件名称，从而指示文件的类型。通常，文件名后面附加“&#x2F;”表示“可执行文件”，附加“@”表示符号链接，附加“|”表示命名管道，附加“&#x3D;”表示套接字。这些只是对人类有提示作用的视觉标识，而不是文件名的一部分。</p>
<p>-S 按大小对文件排序</p>
<p>-t 按照最近修改时间对文件进行排序</p>
<p>-r 反序</p>
<p>-R 显示目录时，递归显示其内容</p>
<p>-d 显示目录时，不显示其内容，仅显示目录本身的信息</p>
<hr>
<h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>格式：<code>cp [options] files (file | directory)</code></p>
<p>作用：复制文件</p>
<p>常用选项：</p>
<p>-p 不仅复制文件内容，同时复制文件权限、时间戳，同时如果你具有足够的权限的话，还可以复制其属主和用户组（通常，这些副本将归你所有，以当下时间作为时间戳，相应的权限则是通过将 umask 应用于原始权限来设置的）</p>
<p>-a 递归复制目录的层次结构，保留所有的文件属性和链接</p>
<p>-r 递归复制目录的层次结构。该选项不保留文件的属性，如权限和时间戳，但是会保留符号链接</p>
<p>-i 交互模式。在覆盖目标文件之前会进行询问</p>
<p>-f 强制复制。如果目标文件存在的话，则无条件覆盖</p>
<hr>
<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>格式：<code>mv [options] source target</code></p>
<p>作用：对文件进行重命名，或将文件或目录移动到目标目录中</p>
<p>常用选项：</p>
<p>-i 交互模式。在覆盖目标文件之前进行询问</p>
<p>-f 强制移动。如果目标文件存在的话，则无条件覆盖</p>
<hr>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>格式：<code>rm [options] files | directories</code></p>
<p>作用：删除文件或递归删除目录</p>
<p>常用选项：</p>
<p>-i 交互模式。在删除每个文件之前都会进行询问</p>
<p>-f 强制删除，忽略任何错误或警告</p>
<p>-r 递归删除目录及其内容。该选项请谨慎使用，特别是与-f 选项结合使用时尤其如此，因为这会删除所有的文件</p>
<hr>
<h2 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h2><p>格式：<code>ln [options] source target</code></p>
<p>作用：创建链接</p>
<p>常用选项：</p>
<p>-s 创建一个符号链接而非硬链接</p>
<p>-i 交互模式。在覆盖目标文件之前进行询问</p>
<p>-f 强制链接。如果目标文件存在的话，则无条件覆盖</p>
<p>-d 创建指向目录的硬链接（仅限于超级用户）</p>
<p>注：<code>readlink linkname</code>命令用于查找符号链接指向的位置，而当符号链接指向其他符号链接时，要想找出整个链接最终指向的位置，请使用<code>readlink -f</code>命令</p>
<hr>
<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cd</td>
<td>更改当前目录</td>
</tr>
<tr>
<td>pwd</td>
<td>打印当前目录的名称</td>
</tr>
<tr>
<td>basename</td>
<td>打印文件路径的最后部分</td>
</tr>
<tr>
<td>dirname</td>
<td>打印文件路径，其中不包括最后部分</td>
</tr>
<tr>
<td>mkdir</td>
<td>创建目录</td>
</tr>
<tr>
<td>rmdir</td>
<td>删除空目录</td>
</tr>
<tr>
<td>rm -r</td>
<td>删除非空目录及其内容</td>
</tr>
</tbody></table>
<hr>
<h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><p>格式：<code>cd [directory]</code></p>
<p>作用：设置当前的工作目录</p>
<p>注：如果不提供具体目录的话，默认切换到主目录</p>
<hr>
<h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>格式：<code>pwd</code></p>
<p>作用：输出当前工作目录的绝对路径</p>
<hr>
<h2 id="basename"><a href="#basename" class="headerlink" title="basename"></a>basename</h2><p>格式：<code>basename path [extension]</code></p>
<p>作用：输出文件路径中的最后面部分</p>
<p>注：如果提供了可选的扩展名，那么结果中的扩展名也同时删除</p>
<hr>
<h2 id="dirname"><a href="#dirname" class="headerlink" title="dirname"></a>dirname</h2><p>格式：<code>dirname path</code></p>
<p>作用：输出文件路径（同时删除其最后面的部分）</p>
<p>注：dirname 命令不会改变当前的工作目录。它只是处理并输出一个字符串，与 basename 类似</p>
<hr>
<h2 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h2><p>格式：<code>mkdir [options] directories</code></p>
<p>作用：创建一个或多个目录</p>
<p>常用选项：</p>
<p>-p 给定目录路径（而非简单的目录名），自动创建必需的父目录</p>
<p>-m 创建具有给定权限的目录，如：<code>mkdir -m 0755 publicdir</code>，默认情况下，赋予的权限是由 shell 的 umask 来控制的</p>
<hr>
<h2 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h2><p>格式：<code>rmdir [options] directories</code></p>
<p>作用：删除一个或多个空目录</p>
<p>常用选项：</p>
<p>-p 如果提供了目录路径（而非简单的目录名称），那么不但可以自动删除指定的目录，还可以自动删除指定的父目录</p>
<p>注：要删除非空目录及其内容，请谨慎使用 rm -r 目录。如果使用 rm -ri 命令的话，可以进行交互式删除，如果使用 rm -rf 命令的话，则会直接删除而不提供任何错误信息，同时也不要求进行确认</p>
<hr>
<h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cat</td>
<td>查看完整的文件</td>
</tr>
<tr>
<td>less</td>
<td>逐页查看文本文件</td>
</tr>
<tr>
<td>nl</td>
<td>利用行编号查看文本文件</td>
</tr>
<tr>
<td>head</td>
<td>查看文本文件的第一行</td>
</tr>
<tr>
<td>tail</td>
<td>查看文本文件的最后一行</td>
</tr>
<tr>
<td>strings</td>
<td>显示嵌入二进制文件的文本</td>
</tr>
<tr>
<td>od</td>
<td>以八进制（或其他格式）格式查看数据</td>
</tr>
</tbody></table>
<hr>
<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>格式：<code>cat [options] [files]</code></p>
<p>作用：将文件输出至标准输出，或将一组文件发送到 shell 管道</p>
<p>常用选项：</p>
<p>-T 将制表符输出为 I</p>
<p>-E 将换行符输出为$</p>
<p>-v 以人类可读的格式打印其他非打印字符</p>
<p>-n 为每行添加行号</p>
<p>-b 为非空白行添加行号</p>
<p>-s 将连续的空白压缩为一个空白行</p>
<hr>
<h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><p>格式：<code>less [options] [files]</code></p>
<p>作用：以每次一页的方式查看文本</p>
<p>常用选项：</p>
<p>-c 在显示下一页之前清除屏幕。这样可以避免滚屏，并且看起来更加舒适</p>
<p>-m 输出更详细的提示，并给出显示进度</p>
<p>-N 显示行号</p>
<p>-r 按照字面形式显示控制字符；通常 less 会将控制字符转换为人类可读的格式</p>
<p>-s 将多个相邻的空白行压缩成单个空白行</p>
<p>-S 当某行内容很长时，截短为与屏幕等宽</p>
<hr>
<h2 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h2><p>格式：<code>nl [options] [files]</code></p>
<p>作用：将文件复制到标准输出，并添加行号</p>
<p>常用选项：</p>
<p>-b [a|t|n|p R] 在所有行（a）、非空白行（t）或包含正则表达式 R 的行前面添加行号。而 n 表示不给任何一行编号（默认值&#x3D;a）</p>
<p>-v N 从整数 N 开始编号（默认值&#x3D;1）</p>
<p>-i N 每一行递增 N，例如，你可以仅使用奇数（-i 2）或偶数（-v 2 -i 2）（默认值&#x3D;1）</p>
<p>-n [ln|rn|rz] 将编号格式化为左对齐（ln）、右对齐（rn）或带前导零（rz）的右对齐（默认值&#x3D;ln）</p>
<p>-w N 将数字的宽度强制为 N 列（缺省值&#x3D;6）</p>
<p>-s S 在行号和文本之间插入字符串 S（默认值&#x3D;Tab）</p>
<hr>
<h2 id="head"><a href="#head" class="headerlink" title="head"></a>head</h2><p>格式：<code>head [options] [files]</code></p>
<p>作用：输出文件前 10 行，或预览命令管道输出的前几行内容</p>
<p>常用选项：</p>
<p>-n N 打印前 N 行，而不是前 10 行</p>
<p>-N 作用与-n N 相同</p>
<p>-c N 输出文件的前 N 个字节</p>
<p>-q 安静模式，当处理一个以上的文件时，不在每一个文件之上打印一个横幅。通常，head 命令会输出包含文件名的横幅</p>
<hr>
<h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>格式：<code>tail [options] [files]</code></p>
<p>作用：输出文件的最后 10 行，并执行其他操作</p>
<p>常用选项：</p>
<p>-n N 输出最后 N 行，而不是最后 10 行</p>
<p>-N 作用与-n N 相同</p>
<p>-n +N 输出除了第 N 行之外的所有行</p>
<p>-c N 输出文件的最后 N 个字节</p>
<p>-f 打开文件，每当文件附加新的行时，输出它们。这个功能是非常有用的。如果文件不存在，但你想等到它出现的话，可以添加–retry 选项</p>
<p>-q 安静模式，当处理的文件多于一个的时候，不给每个文件都输出一个横幅。通常情况下，tail 都会输出一个包含文件名的横幅</p>
<hr>
<h2 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h2><p>格式：<code>strings [options] [files]</code></p>
<p>作用：提取二进制文件中的可读文本，并将其显示在标准输出中</p>
<p>常用选项：</p>
<p>-n length 仅显示长度大于 length（默认值为 4）的字符串</p>
<hr>
<h2 id="od"><a href="#od" class="headerlink" title="od"></a>od</h2><p>格式：<code>od [options] [files]</code></p>
<p>作用：查看二进制文件</p>
<p>常用选项：</p>
<p>-N B 仅显示每个文件的前 B 字节，可以用十进制、十六进制（通过前缀 0x 或 0X）、512 字节块（通过附加 b）、千字节（通过附加 k）或兆字节（通过附加 m）来指定（默认情况下会显示整个文件）</p>
<p>-j B 从每个文件的第 B+1 字节处开始输出，可接受的格式与-N 选项相同（缺省值&#x3D;0）</p>
<p>-w [B] 每行显示 B 字节，可接受的格式与-N 选项相同。如果只是使用-w 本身的话，就等同于-w 32（默认值&#x3D;16）</p>
<p>-s [B] 将每行字节分为 B 字节为单位的序列，由空格分隔；可接受的格式与-N 选项相同。如果只是使用-s 本身的话，就等同于-s 3（默认值&#x3D;2）</p>
<p>-A(d|o|x|n) 显示最左列，可以以十进制（d）、八进制（o）、十六进制（x）或全部（n）为单位（默认值&#x3D;o）</p>
<p>-t(a|c)[z] 以字符格式显示输出，非字母数字字符输出为转义序列（c）或名称（a）</p>
<p>-t(d|o|u|x)[z] 以整数格式显示输出，可以使用八进制（o）、有符号十进制（d）、无符号十进制（u）、十六进制（x）</p>
<p>注：将 z 附加到-t 选项的话，会在输出的右侧输出一个新列，用来显示每行中的可打印字符</p>
<hr>
<h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>stat</td>
<td>显示文件和目录的属性</td>
</tr>
<tr>
<td>wc</td>
<td>统计字节数、字数和行数</td>
</tr>
<tr>
<td>du</td>
<td>显示文件和目录的磁盘使用情况</td>
</tr>
<tr>
<td>file</td>
<td>识别（猜测）文件的类型</td>
</tr>
<tr>
<td>touch</td>
<td>更改文件和目录的时间戳</td>
</tr>
<tr>
<td>chown</td>
<td>更改文件和目录的属主</td>
</tr>
<tr>
<td>chgrp</td>
<td>更改文件和目录所属的用户组</td>
</tr>
<tr>
<td>chmod</td>
<td>更改文件和目录的保护模式</td>
</tr>
<tr>
<td>umask</td>
<td>为新的文件和目录设置默认模式</td>
</tr>
<tr>
<td>chattr</td>
<td>更改文件和目录的扩展属性</td>
</tr>
<tr>
<td>lsattr</td>
<td>列出文件或目录的扩展属性</td>
</tr>
</tbody></table>
<hr>
<h2 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h2><p>格式：<code>stat [options] files</code></p>
<p>作用：显示文件（默认情况下）或文件系统（-f 选项）的重要属性</p>
<p>常用选项：</p>
<p>-L 跟踪符号链接，并报告它们指向的文件</p>
<p>-f 显示文件所在文件系统的信息，而不是文件本身的信息</p>
<p>-t 简洁模式，单行输出所有信息</p>
<hr>
<h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><p>格式：<code>wc [options] [files]</code></p>
<p>作用：输出文本文件中的字节数、字数和行数</p>
<p>常用选项：</p>
<p>-l 仅输出行数</p>
<p>-w 仅输出字数</p>
<p>-c 仅输出字节数</p>
<p>-L 找出每个文件中最长的行，并以字节为单位输出该行的长度</p>
<hr>
<h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p>格式：<code>du [options] [files | directories]</code></p>
<p>作用：输出文件或目录所占用的磁盘空间（以块为单位）</p>
<p>常用选项：</p>
<p>-b 输出以字节为单位的大小</p>
<p>-k 输出以千字节为单位的大小</p>
<p>-m 输出以兆字节为单位的大小</p>
<p>-B N 根据所定义块为单位来显示大小，其中 1 个块&#x3D;N 字节（默认值&#x3D;1024）</p>
<p>-h -H 以人类可读的单位进行输出。-h 选项使用 1024 的幂，而-H 则使用 1000 的幂</p>
<p>-c 在最后一行输出总数。这是输出目录大小时的默认设置，但是用于特定文件的时候，如果需要统计总大小的话，请使用-c 选项</p>
<p>-L 跟踪符号链接并显示它指向的文件的大小</p>
<p>-s 仅输出总大小</p>
<p>-a 递归显示</p>
<hr>
<h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><p>格式：<code>file [options] files</code></p>
<p>作用：输出文件的类型</p>
<p>常用选项：</p>
<p>-b 输出时忽略左边部分的文件名</p>
<p>-i 输出文件的 MIME 类型，而不是常规的文件信息</p>
<p>-f name_file 从给定的 name_file 文件中读取文件名，逐行读取，每行一个文件名，并报告其类型。之后，以常规命令行的方式处理文件名</p>
<p>-L 跟踪符号链接，然后报告目标文件的类型，而不是显示链接的类型</p>
<p>-z 如果文件被压缩，则检查未压缩的内容以确定文件类型，而非显示“压缩数据”</p>
<hr>
<h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p>格式：<code>touch [options] files</code></p>
<p>作用：修改文件的两个时间戳（修改时间、访问时间）；创建空文件</p>
<p>常用选项：</p>
<p>-a 仅修改访问时间</p>
<p>-m 仅更改修改时间</p>
<p>-c 如果文件不存在，不要创建它</p>
<p>-d timestamp 设置文件的时间戳</p>
<p>-t timestamp 一种设置时间戳的高级方式，格式为[[CC]YY] MMDDhhmm [.ss]</p>
<hr>
<h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><p>格式：<code>chown [options] user_spec files</code></p>
<p>作用：设置文件和目录的所有权</p>
<p><strong>user_spec</strong>参数可以是：</p>
<ul>
<li>现有用户名（或任何数字形式的用户 ID），以便设置属主</li>
<li>现有用户名（或任何数字形式的用户 ID），作为可选项可以跟冒号和现有用户组名（或任何数字形式的用户组 ID），以便设置属主和用户组</li>
<li>现有的用户名（或任何数字形式的用户 ID）后面跟冒号，来设置属主，并将用户组设置为调用用户的登录组</li>
<li>位于冒号之后的现有用户组名（或任何数字形式的组 ID），仅设置用户组</li>
<li>–reference&#x3D;file，将属主和用户组设置为给定的另一个文件的属主和用户组</li>
</ul>
<p>常用选项：</p>
<p>–dereference 跟踪符号链接并对其指向的文件进行操作</p>
<p>-R 递归更改目录层次结构中的相应权限</p>
<hr>
<h2 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h2><p>格式：<code>chgrp [options] group_spec files</code></p>
<p>作用：设置文件和目录的属组</p>
<p><strong>group_spec</strong>参数可以是以下任何一种：</p>
<ul>
<li>用户组名或数字形式的用户组 ID</li>
<li>–reference&#x3D;file，将属组设置为另一给定文件的属组</li>
</ul>
<p>常用选项：</p>
<p>–dereference 跟踪符号链接，并对其指向的文件进行操作</p>
<p>-R 递归更改目录层次结构中的所有权</p>
<hr>
<h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>格式：<code>chmod [options] permissions files</code></p>
<p>作用：设置文件和目录的访问权限</p>
<p><strong>permissions</strong>参数可以采用三种不同的形式：</p>
<ul>
<li>–reference&#x3D;file，设置与其他给定文件相同的权限</li>
<li>最多四位数字的八进制数，用于指定文件的绝对权限</li>
<li>一个或多个字符串，指定绝对权限或相对权限（即相对于该文件的现有权限）</li>
</ul>
<p>常用选项：</p>
<p>-R 递归更改目录层次结构中的所有权</p>
<hr>
<h2 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h2><p>格式：<code>umask [options] [mask]</code></p>
<p>作用：设置或显示创建文件和目录时的默认模式，赋予自己、用户组和所有人相应的读、写和&#x2F;或执行权限</p>
<p>常用选项：</p>
<p>-S 以更直观的形式显示默认模式</p>
<hr>
<h2 id="chattr"><a href="#chattr" class="headerlink" title="chattr"></a>chattr</h2><p>格式：<code>chattr [options] [+ - =] attributes [files]</code></p>
<p>作用：设置或更改扩展属性（仅限 ext 文件系统）</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>只能进行追加：只能向文件中添加数据，而不能编辑数据，只有 root 才能设定这个属性</td>
</tr>
<tr>
<td>A</td>
<td>不访问时间戳：对这个文件进行访问时不会更新其访问时间戳（atime）</td>
</tr>
<tr>
<td>c</td>
<td>压缩：数据在写入时自动压缩，在读取时自动解压缩</td>
</tr>
<tr>
<td>d</td>
<td>不转储：在进行备份时，告诉转储程序忽略此项</td>
</tr>
<tr>
<td>i</td>
<td>不可变：不允许对该文件进行更改或删除（仅限 root 使用该属性）</td>
</tr>
<tr>
<td>j</td>
<td>文件在写入时会先被记录在 journal 中（仅限 ext3 系统）</td>
</tr>
<tr>
<td>s</td>
<td>安全删除：删除时，用零覆盖文件中的所有数据</td>
</tr>
<tr>
<td>S</td>
<td>同步更新：更改将立即写入磁盘</td>
</tr>
<tr>
<td>u</td>
<td>不可删除：该文件不允许执行删除操作</td>
</tr>
</tbody></table>
<p>常用选项：</p>
<p>-R 递归处理目录</p>
<hr>
<h2 id="lsattr"><a href="#lsattr" class="headerlink" title="lsattr"></a>lsattr</h2><p>格式：<code>lsattr [options] files</code></p>
<p>作用：显示扩展属性</p>
<p>注：如果没有指定文件的话，lsattr 会输出当前目录中所有文件的属性</p>
<p>常用选项：</p>
<p>-R 递归处理目录</p>
<p>-a 列出所有的文件，包括以点号开头的文件</p>
<p>-d 如果显示目录的话，不显示其内容，仅显示目录本身</p>
<hr>
<h2 id="文件的定位"><a href="#文件的定位" class="headerlink" title="文件的定位"></a>文件的定位</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>find</td>
<td>在目录层次结构中查找文件</td>
</tr>
<tr>
<td>xargs</td>
<td>处理找到的文件列表（以及其他功能）</td>
</tr>
<tr>
<td>locate</td>
<td>创建一个文件索引，然后通过索引搜索字符串</td>
</tr>
<tr>
<td>which</td>
<td>在搜索路径中查找可执行文件（命令）</td>
</tr>
<tr>
<td>type</td>
<td>查找搜索路径中的可执行文件（bash 内置命令）</td>
</tr>
<tr>
<td>whereis</td>
<td>查找可执行文件、文档和源文件</td>
</tr>
</tbody></table>
<hr>
<h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>格式：<code>find [directories] [expression]</code></p>
<p>作用：在一个或多个目录（及其递归子目录）中搜索符合特定条件的文件</p>
<p>常用选项：</p>
<p>-name|-path|-lname pattern 查找对象的文件名称（-name）、路径名（-path）或符号链接目标文件（-lname）必须匹配这里给出的 shell 模式，其中可以含有 shell 通配符*，?和[]（必须对通配符进行转义处理，以便让 shell 忽略这些通配符本身，而按照通配符所指代的内容进行查找）。注意，这里的路径是相对于正在搜索的目录树的相对路径</p>
<p>-iname|-ipath|-ilname pattern 分别对应于前面三个，不区分大小写</p>
<p>-regex regexp 路径（相对于正在搜索的目录树）必须与给定的正则表达式相匹配</p>
<p>-type t 仅查找类型为 t 的文件。这些类型包括普通文件（f）、目录（d）、符号链接（l）、块设备（b）、字符设备（c）、命名管道（p）和套接字（s）</p>
<p>-atime|-ctime|-mtime N 以 N*24 小时为参考，最后一次访问（-atime）、最后一次修改（-mtime）或发生状态变化（-ctime）的文件。此外，+N 表示“大于 N”，而-N 表示“小于 N”</p>
<p>-amin|-cmin|-mmin N 以 N 分钟为参考，最后一次访问（-amin）、最后一次修改（-mmin）或发生状态变化（-cmin）的文件。此外，+N 表示“大于 N”，而-N 表示“小于 N”</p>
<p>-anewer|-cnewer|-newer other_file 访问时间（-anewer）、修改时间（-newer）或者状态变化时间（-cnewer）晚于 other_file 的相应时间的那些文件</p>
<p>-maxdepth|-mindepth N 在正在搜索的目录树中查找文件时，最少（-mindepth）或最多（-maxdepth）搜索 N 层</p>
<p>-follow 如果遇到符号链接，就跟踪链接所指的文件</p>
<p>-depth 继续使用深度优先搜索：在对目录本身进行操作之前，首先通过递归方式彻底搜索目录中的内容</p>
<p>-xdev 将搜索范围限制为单个文件系统（即不允许跨越设备边界）</p>
<p>-size N[bckw] 查找大小为 N 的文件，其单位可以是块（b），单字节字符（c），千字节（k）或双字节的字（w）。+N 表示“大于 N”，-N 表示“小于 N”</p>
<p>-empty 查找大小为零的普通文件或目录</p>
<p>-user name 查找属主为给定用户的文件</p>
<p>-group name 查找属组为给定用户组的文件</p>
<p>-perm mode 查找权限与给定模式相同的文件。可以使用-mode 来检查所有给定的位是否被设置，或者使用+mode 来检查给定的位是否被设置</p>
<p><em>此外，可以使用<strong>运算符</strong>对表达式的组成部分进行分组和求反：</em></p>
<p>expression1 -a expression2：与运算，该选项为默认值</p>
<p>expression1 -o expression2：或运算</p>
<p>! expression 或-not expression：对表达式的值进行求反</p>
<p>(expression)：优先级标记</p>
<p>expression1,expression2：计算两个表达式的值，然后返回第二个表达式的值</p>
<p>指定搜索条件后，就可以让 find 命令在符合条件的文件上执行以下操作。</p>
<p>常用选项：</p>
<p>-print 只需输出相对于搜索目录的相对路径</p>
<p>-printf string 输出给定的字符串，可以用 C 库函数 printf()的方式对其进行替换</p>
<p>-printO 类似于-print，区别在于不是使用换行符分隔每行输出，而使用 null（ASCII 0）字符。通常在将搜索结果以管道方式传递给另一个程序，并且文件名列表可能含有空格时使用。当然，这要求接收程序必须能够读取并解析这些以 null 字符分隔的行</p>
<p>-exec cmd; 调用给定的 shell 命令 cmd。需要注意的是，一定要对 shell 元字符转义处理，包括最后面的分号，因此它们不会在命令行中立即进行计算。此外，符号“{}”（务必加上引号或进行转义处理）代表所找的文件的路径，如：<code>find . -exec ls &#39;&#123;&#125;&#39; \;</code></p>
<p>-ok cmd 与-exec 选项的作用类似，区别是将在调用每个命令之前提示用户</p>
<p>-ls 对文件执行 ls -dils 命令</p>
<hr>
<h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>格式：<code>xargs [options] [command]</code></p>
<p>作用：从标准输出读取文本行，将其转换为命令，并执行</p>
<p>常用选项：</p>
<p>-n K 对于每个命令来说，只使用输入中的 K 行内容。而-n 1 的作用是确保每个命令只处理一行输入。否则，xargs 可以将多行输入传递给单个命令</p>
<p>-O 将输入的行尾字符设置为 ASCII 的零字符，而非空格符，并且按照字面含义来处理所有字符。当输入来自 find -printO 时，可以使用该选项</p>
<hr>
<h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>格式：<code>locate [options]</code></p>
<p>作用：在一个不太发生变化的目录层次结构中搜索文件</p>
<p>注：将 locate 命令与 updatedb 命令搭配使用的话，可以创建一个搜索速度极快的文件位置的索引（数据库）</p>
<p>updatedb 命令的索引选项：</p>
<p>-u 从根目录向下创建索引</p>
<p>-U directory 从 directory 向下创建索引</p>
<p>-l(0|1) 安全功能开关，0 表示关闭，1 表示打开。默认值为 1</p>
<p>-e directories 从索引中排除一个或多个目录，这里使用的路径分隔符为逗号</p>
<p>-o outfile 将索引写入 outfile 文件中</p>
<p>locate 命令的搜索选项：</p>
<p>-d index 指出要使用的索引</p>
<p>-i 搜索时不区分大小写</p>
<p>-r regexp 搜索与给定正则表达式匹配的文件</p>
<hr>
<h2 id="which"><a href="#which" class="headerlink" title="which"></a>which</h2><p>格式：<code>which file</code></p>
<p>作用：在 shell 的搜索路径中查找可执行文件</p>
<p>注：如果搜索路径中有重名的程序，只会显示首先找到的那个程序</p>
<hr>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>格式：<code>type [options] commands</code></p>
<p>作用：在 shell 的搜索路径中查找可执行文件</p>
<p>注：type 是内置在 bash shell 中的，而 which 则是位于硬盘上的外部程序。作为一个内置的 shell 命令，在速度方面 type 要比 which 更快一些，但它的不足之处在于只能在某些 shell（如 bash）中使用</p>
<hr>
<h2 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h2><p>格式：<code>whereis [options] files</code></p>
<p>作用：通过搜索硬编码的目录列表来查找给定的文件，可以查找可执行文件、文档和源代码</p>
<p>常用选项：</p>
<p>-b|-m|-s 仅列出可执行文件（-b）、联机帮助页（-m）或源代码文件（-s）</p>
<p>-B|-M|-S dirs… -f 仅在给定的目录中搜索可执行文件（-B）、联机帮助页（-M）或源代码文件（-S）。在列出所查找的文件之前，你必须使用-f 选项来跟踪目录列表</p>
<hr>
<h2 id="文件的正文处理"><a href="#文件的正文处理" class="headerlink" title="文件的正文处理"></a>文件的正文处理</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>grep</td>
<td>在文件中查找与正则表达式匹配的行</td>
</tr>
<tr>
<td>cut</td>
<td>从文件中提取列</td>
</tr>
<tr>
<td>paste</td>
<td>附加列</td>
</tr>
<tr>
<td>tr</td>
<td>将字符转换为其他字符</td>
</tr>
<tr>
<td>expand&#x2F;unexpand</td>
<td>在制表符和空格符之间进行转换</td>
</tr>
<tr>
<td>sort</td>
<td>按各种标准对文本行进行排序</td>
</tr>
<tr>
<td>uniq</td>
<td>在文件中查找相同的行</td>
</tr>
<tr>
<td>tee</td>
<td>复制文件，同时将其输出到标准输出上</td>
</tr>
</tbody></table>
<hr>
<h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>格式：<code>grep [options] pattern [files]</code></p>
<p>作用：给定一个或多个文件，输出其中与特定正则表达式模式匹配的所有行</p>
<p>注：grep 命令可以使用两种不同类型的正则表达式，它们分别称之为基本类型和扩展类型</p>
<p>常用选项：</p>
<p>-v 只输出与正则表达式不匹配的行</p>
<p>-l 仅输出包含匹配行的文件的名称，而不是输出匹配的行</p>
<p>-L 仅输出不包含匹配行的文件的名称</p>
<p>-c 仅输出匹配的行数</p>
<p>-n 在输出匹配结果的时候，每行的前面给出其原始行号</p>
<p>-b 在输出匹配结果的时候，每行的前面给出其在文件中的偏移字节</p>
<p>-i 匹配时不区分大小写</p>
<p>-w 只匹配完整的单词（即匹配整个正则表达式的单词）</p>
<p>-x 仅匹配完整的行（即与整个正则表达式匹配的行），优先级高于-w 选项</p>
<p>-A N 输出匹配行，以及位于匹配行之后的 N 行</p>
<p>-B N 输出匹配行，以及位于匹配行之前的 N 行</p>
<p>-C N 输出匹配行，以及原文件中位于匹配行前后的 N 行内容</p>
<p>–color&#x3D;always 突出显示匹配文本的颜色，以提高可读性</p>
<p>-r 递归搜索目录及其子目录中的所有文件</p>
<p>-E 使用扩展正则表达式。见 egrep 命令</p>
<p>-F 使用固定的字符串列表，而不是正则表达式。见 fgrep 命令</p>
<hr>
<h2 id="egrep"><a href="#egrep" class="headerlink" title="egrep"></a>egrep</h2><p>格式：<code>egrep [options] pattern [files]</code></p>
<p>作用：类似与 grep，只不过在正则表达式方面，它使用了一种不同的（“扩展性”）语言。它等价于 grep -E</p>
<hr>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>扩展类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td></td>
<td>任何单个字符</td>
</tr>
<tr>
<td>[…]</td>
<td></td>
<td>匹配该列表中的任何单个字符</td>
</tr>
<tr>
<td>[^…]</td>
<td></td>
<td>匹配不属于该列表的任何单个字符</td>
</tr>
<tr>
<td>(…)</td>
<td></td>
<td>分组</td>
</tr>
<tr>
<td><code>|</code></td>
<td>|</td>
<td>或操作符</td>
</tr>
<tr>
<td>^</td>
<td></td>
<td>行首</td>
</tr>
<tr>
<td>$</td>
<td></td>
<td>行尾</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>词首</td>
</tr>
<tr>
<td><code>\&gt;</code></td>
<td></td>
<td>结束一个字</td>
</tr>
<tr>
<td>[: alnum: ]</td>
<td></td>
<td>任何字母数字字符</td>
</tr>
<tr>
<td>[: alpha: ]</td>
<td></td>
<td>任何字母字符</td>
</tr>
<tr>
<td>[: cntrl: ]</td>
<td></td>
<td>任何控制字符</td>
</tr>
<tr>
<td>[: digit: ]</td>
<td></td>
<td>任意数字</td>
</tr>
<tr>
<td>[: graph: ]</td>
<td></td>
<td>任何图形字符</td>
</tr>
<tr>
<td>[: lower: ]</td>
<td></td>
<td>任何小写字母</td>
</tr>
<tr>
<td>[: print: ]</td>
<td></td>
<td>任何可打印字符</td>
</tr>
<tr>
<td>[: punct: ]</td>
<td></td>
<td>任何标点符号</td>
</tr>
<tr>
<td>[: space: ]</td>
<td></td>
<td>任何空格字符</td>
</tr>
<tr>
<td>[: upper: ]</td>
<td></td>
<td>任何大写字母</td>
</tr>
<tr>
<td>[: xdigit: ]</td>
<td></td>
<td>任何十六进制数字</td>
</tr>
<tr>
<td>*</td>
<td></td>
<td>正则表达式出现零次或多次</td>
</tr>
<tr>
<td><code>\ +</code></td>
<td>+</td>
<td>正则表达式出现一次或多次</td>
</tr>
<tr>
<td><code>\ ?</code></td>
<td>?</td>
<td>正则表达式出现零次或一次</td>
</tr>
<tr>
<td><code>\&#123;n \&#125;</code></td>
<td>{n}</td>
<td>正则表达式恰好出现 n 次</td>
</tr>
<tr>
<td><code>\&#123;n,\&#125;</code></td>
<td>{n,}</td>
<td>正则表达式恰好出现 n 次或 n 次以上</td>
</tr>
<tr>
<td><code>\&#123;n,m\&#125;</code></td>
<td>{n,m}</td>
<td>正则表达式出现次数介于 n 和 m（含 m）之间，n&lt;m</td>
</tr>
<tr>
<td><code>\c</code></td>
<td></td>
<td>取文字 c 的字面意义，即使 c 是一个特殊的正则表达式字符</td>
</tr>
</tbody></table>
<hr>
<h2 id="fgrep"><a href="#fgrep" class="headerlink" title="fgrep"></a>fgrep</h2><p>格式：<code>fgrep [options] [fixed_strings] [files]</code></p>
<p>作用：类似于 grep，但是它无法接收正则表达式，只能支持用换行符分隔的固定字符串的列表。该命令等价于 grep -F。通常，可以使用小写形式的-f 选项让 fgrep 命令从一个文件中读取固定的字符串。此外，还可以使用引号从命令行中读取固定的字符串。搜索非数字字符如*和{时，fgrep 命令用起来会非常方便，因为它们是按照字母的字面意义来对待的，而不是作为正则表达式字符来对待</p>
<hr>
<h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p>格式：<code>cut -(b|c|f)range [options] [files]</code></p>
<p>作用：从文件中提取文本列，这里的“列”是由字符偏移（c）或字节偏移（b）或分隔字段（f）来定义的</p>
<p>常用选项：</p>
<p>-d C 使用字符 C 作为-f 选项的字段之间的输入分隔符。默认使用制表符</p>
<p>–output-delimiter&#x3D;C 使用字符 C 作为-f 选项的字段之间的输出分隔符。默认使用制表符</p>
<p>-s 排除（不输出）不包含分隔符的行</p>
<hr>
<h2 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h2><p>格式：<code>paste [options] [files]</code></p>
<p>作用：将多个文件视为垂直列，并将它们合并到标准输出上</p>
<p>常用选项：</p>
<p>-d delimiters 使用给定分隔符来分隔各列；默认使用制表符。可以提供一个单个字符（如-d:）并自始至终使用该字符，或提供一个字符列表(如-dxyz)将其依次用于各行</p>
<p>-s 将输出的行和列进行转置</p>
<hr>
<h2 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h2><p>格式：<code>tr [options] charset1 [charset2]</code></p>
<p>作用：将一组字符转换为另一组字符</p>
<p>字符集 charset 可以采用以下格式：</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ABDG</td>
<td>由字符 A、B、D、G 组成的序列</td>
</tr>
<tr>
<td>A-Z</td>
<td>从 A-Z 之间的字符</td>
</tr>
<tr>
<td>[x*y]</td>
<td>字符 x 重复 y 次</td>
</tr>
<tr>
<td>[ :class: ]</td>
<td>见 grep 命令支持的字符类</td>
</tr>
</tbody></table>
<p>常用选项：</p>
<p>-d 从输入中删除包含在 charset1 中的字符</p>
<p>-s 从输入中删除（位于 charset1 中的）那些连续重复字符</p>
<p>-c 只对 charset1 之外的字符进行操作</p>
<p>-t 如果 charset1 长于 charset2，则通过截断 charset1 使其长度相同。如果没有提供-t 的话，则不断复制 charset2 的最后一个字符，直到 charset2 与 charset1 的长度相同为止</p>
<hr>
<h2 id="expand-x2F-unexpand"><a href="#expand-x2F-unexpand" class="headerlink" title="expand &#x2F; unexpand"></a>expand &#x2F; unexpand</h2><p>格式：<code>expand [options] [files]</code>，<code>unexpand [options] [files]</code></p>
<p>作用：expand 命令用来将制表符转换为特定数量的空白字符，使其看起来长度不变，而 unexpand 命令的作用则刚好相反。默认情况下，每八个空格“兑换”一个制表符。</p>
<p>常用选项：</p>
<p>-t N 规定用 N 个空格替换一个制表符</p>
<hr>
<h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>格式：<code>sort [options] [files]</code></p>
<p>作用：以字母顺序输出文本行，或按照你指定的其他规则来进行排序。该命令首先会将提供的所有文件连接起来，然后对结果排序输出</p>
<p>常用选项：</p>
<p>-f 排序时区分大小写</p>
<p>-n 按照字母顺序进行排序，而不是按照字母顺序</p>
<p>-g 另一种具有不同算法的数字排序方法，该算法能够识别不同的计数法</p>
<p>-u 排序时忽略重复行（当通过-c 检查排序文件的时候，如果任意的连续两行相同的话，则返回失败）</p>
<p>-c 不进行排序，只检查输入是否已经过排序处理。如果是的话，不输出任何内容；否则，输出错误信息</p>
<p>-b 忽略各行的前导空格</p>
<p>-r 对输出进行反转：按照从最大到最小的顺序来排序</p>
<p>-t X 使用 X 作为-k 选项的字段分隔符</p>
<p>-k key 选择用于排序的键（组合-t 选项后，可以指定各个键之间的分隔符）</p>
<hr>
<h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><p>格式：<code>uniq [options] [files]</code></p>
<p>作用：处理文本中连续的重复行</p>
<p>常用选项：</p>
<p>-c 计算相邻的重复行的数量</p>
<p>-i 操作时不区分大小写</p>
<p>-u 仅输出唯一的行</p>
<p>-d 仅输出重复行</p>
<p>-s N 检测重复行时，忽略每行中前面 N 个字符</p>
<p>-f N 当检测重复行时，忽略每行中前面 N 个由空白符分隔的第一个字段</p>
<p>-w N 当检测重复行时，仅考察每行的前 N 个字符。当与-s 或-f 选项结合使用的时候，sort 将忽略每行前面指定数量的字符或字段，然后考察接下来的 N 个字符</p>
<hr>
<h2 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h2><p>格式：<code>tee [options] files</code></p>
<p>作用：将标准输入原封不动地复制到标准输出，同时将相同的标准输入复制到一个或多个文件中</p>
<p>注：tee 命令最常用于命名管道中，它不仅可以把中间数据写入文件，同时还将其传递给管道中的下一个命令</p>
<p>常用选项：</p>
<p>-a 附加至文件末尾，而非覆盖文件</p>
<p>-i 忽略中断信号</p>
<hr>
<h2 id="文件的压缩与打包"><a href="#文件的压缩与打包" class="headerlink" title="文件的压缩与打包"></a>文件的压缩与打包</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>tar</td>
<td>将多个文件打包成单个文件</td>
</tr>
<tr>
<td>gzip</td>
<td>使用 GNU Zip 压缩文件</td>
</tr>
<tr>
<td>gunzip</td>
<td>使用 GNU Zip 解压缩</td>
</tr>
<tr>
<td>bzip2</td>
<td>以 BZIP 格式压缩文件</td>
</tr>
<tr>
<td>bunzip2</td>
<td>解压 BZip 文件</td>
</tr>
<tr>
<td>bzcat</td>
<td>通过标准输入&#x2F;输出压缩&#x2F;解压 BZip 文件</td>
</tr>
<tr>
<td>compress</td>
<td>使用 UNIX 传统的压缩命令来压缩文件</td>
</tr>
<tr>
<td>uncompress</td>
<td>使用 UNIX 传统的解压命令来解压文件</td>
</tr>
<tr>
<td>zcat</td>
<td>通过标准输入&#x2F;输出来压缩&#x2F;解压缩文件（gzip 或 compress）</td>
</tr>
<tr>
<td>zip</td>
<td>用 Windows Zip 格式压缩文件</td>
</tr>
<tr>
<td>unzip</td>
<td>解压 Windows Zip 文件</td>
</tr>
<tr>
<td>munpack</td>
<td>将 MIME 数据提取到文件中</td>
</tr>
<tr>
<td>mpack</td>
<td>将一个文件转换成 MIME 格式</td>
</tr>
</tbody></table>
<hr>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>格式：<code>tar [options] [files]</code></p>
<p>作用：将多个文件和目录打包为单个文件，以便于传输，同时还可以进行压缩处理，该压缩功能是可选的</p>
<p>常用选项：</p>
<p>-c 创建归档。必须在命令行中列出输入文件和目录</p>
<p>-r 将文件附加到现有归档</p>
<p>-u 将新建的&#x2F;修改的文件附加至现有归档</p>
<p>-A 将一个归档附加到另一个归档，该选项不适用于压缩归档</p>
<p>-t 列出（测试）归档</p>
<p>-x 从归档中提取文件</p>
<p>-f file 从给定的文件中读取归档，或将归档写入给定的文件中。该选项通常用于磁盘上的 tar 文件，但也可以用于磁带驱动器</p>
<p>-d 对归档与文件系统进行比较</p>
<p>-z 使用 gzip 压缩</p>
<p>-j 使用 bzip2 压缩</p>
<p>-Z 使用 UNIX 压缩</p>
<p>-v 冗长模式：输出详细信息</p>
<p>-h 跟踪符号链接，而不仅仅是复制它们</p>
<p>-p 提取文件时，恢复原来的权限和所有权</p>
<hr>
<h2 id="gzip"><a href="#gzip" class="headerlink" title="gzip"></a>gzip</h2><p>格式：<code>gzip|gunzip|zcat [options] [files]</code></p>
<p>作用：gzip 命令和 gunzip 命令可利用 GNU Zip 格式来压缩和解压文件。在某些情况下，原始文件可能会被删除。使用这些命令的时候，压缩文件的扩展名为.gz</p>
<p>示例命令：</p>
<p>gzip file 压缩文件，生成 file.gz。同时，原始文件会被删除</p>
<p>gzip -c file 生成压缩数据，并输出至标准输出</p>
<p>cat file | gzip 从命令管道生成压缩数据</p>
<p>gunzip file.gz 解压 file.gz，并创建 file 文件。原始文件 file.gz 将被删除</p>
<p>gunzip -c file.gz 将数据解压至标准输出</p>
<p>cat file.gz | gunzip 解压来自命令管道的数据</p>
<p>zcat file.gz 解压数据，并输出至标准输出</p>
<p>tar -czf tarfile dir 通过 gzip 将目录 dir 打包成 tar 文件。使用-cvzf 选项时，会在处理它们时输出其文件名</p>
<hr>
<h2 id="bzip2"><a href="#bzip2" class="headerlink" title="bzip2"></a>bzip2</h2><p>格式：<code>bzip2|bunzip2|bzcat [options] [files]</code></p>
<p>作用：bzip2 命令和 bunzip2 命令可利用 Burrows-Wheeler 格式压缩和解压文件。在某些情况下，原始文件可能会被删除。使用这些命令的时候，压缩文件的扩展名为.bz2</p>
<p>示例命令：</p>
<p>bzip2 file 压缩 file，从而生成 file.bz2。原始文件会被删除</p>
<p>bzip2 -c file 压缩数据，并将结果写至标准输出</p>
<p>cat file | bzip2 压缩数据，并将结果写至标准输出</p>
<p>bunzip2 file.bz2 解压 file.bz2，从而生成 file。原始文件 file.bz2 将被删除</p>
<p>bunzip2 -c file.bz2 解压缩数据，并将结果写至标准输出</p>
<p>cat file.bz2 | bunzip2 解压缩数据，并将结果写至标准输出</p>
<p>bzcat file.bz2 解压缩数据，并将结果写至标准输出</p>
<p>tar -cjf tarfile dir 将目录 dir 打包成 bzip 压缩格式的 tar 文件。使用-cvjf 可以在处理过程中显示相应的文件名</p>
<hr>
<h2 id="compress"><a href="#compress" class="headerlink" title="compress"></a>compress</h2><p>格式：<code>compress|uncompress|zcat [options] [files]</code></p>
<p>作用：compress 命令和 uncompress 命令可利用标准的 UNIX 压缩格式（Lempel Ziv）来压缩和解压文件。在某些情况下，原始文件可能会被删除。使用这些命令的时候，生成的压缩文件的扩展名为.Z</p>
<p>示例命令：</p>
<p>compress file 压缩 file，从而生成 file.Z 文件。原始文件会被删除</p>
<p>compress -c file 压缩数据，并将结果写至标准输出</p>
<p>cat file | compress 压缩来自命令管道的数据</p>
<p>uncompress file.Z 解压 file.Z，从而生成 file。原始文件 file.Z 将被删除</p>
<p>uncompress -c file.Z 解压缩数据，并将结果写至标准输出</p>
<p>cat file.Z | uncompress 解压来自命令管道中的数据</p>
<p>zcat file.Z 解压缩数据，并将结果写至标准输出</p>
<p>tar -cZf tarfile dir 将目录 dir 打包成 compress 命令格式的 tar 文件。使用-cvZf 选项时，可以在处理过程中显示相应的文件名</p>
<hr>
<h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><p>格式：<code>zip|unzip [options] [files]</code></p>
<p>作用：命令 zip 和 unzip 能够以 Windows Zip 格式来压缩和解压文件。它们生成的压缩文件的扩展名为.zip。与大多数其他 Linux 压缩命令不同，zip 不会删除原始文件</p>
<p>示例命令：</p>
<p>zip myfile.zip file1 file2 file3 … 文件打包</p>
<p>zip -r myfile.zip dirname 递归打包</p>
<p>unzip -l myfile.zip 列出内容</p>
<p>unzip myzip 解包</p>
<hr>
<h2 id="munpack"><a href="#munpack" class="headerlink" title="munpack"></a>munpack</h2><p>格式：<code>munpack [options] mail_file</code>，<code>mpack [options] files</code></p>
<p>作用：munpack 可以将邮件的附件解压为文件，mpack 则是将一个或多个文件作为附件插入到 MIME 格式的文件中</p>
<hr>
<h2 id="文件的比较"><a href="#文件的比较" class="headerlink" title="文件的比较"></a>文件的比较</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>diff</td>
<td>对两个文件或目录逐行比较</td>
</tr>
<tr>
<td>comm</td>
<td>对两个排序后的文件逐行比较</td>
</tr>
<tr>
<td>cmp</td>
<td>对两个文件逐字节比较</td>
</tr>
<tr>
<td>md5sum</td>
<td>计算给定文件的校验和（MD5）</td>
</tr>
</tbody></table>
<hr>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>格式：<code>diff [options] file1 file2</code></p>
<p>作用：diff 命令可用来对两个文件（或两个目录）进行逐行比较。在比较文本文件时，diff 可以提供详细的差异报告。对于二进制文件，diff 仅能指出是否存在差异。对于所有文件来说，如果没有差异的话，diff 都不会生成任何输出</p>
<p>常用选项：</p>
<p>-n 使用 rcsdiff 命令的 RCS 版本控制格式</p>
<p>-c 使用上下文输出格式，供 patch 命令使用</p>
<p>-D macro C 预处理器格式，即#ifdef macro … #else … #endif 格式</p>
<p>-u 一体化输出格式，它会对文件进行合并处理，其中“-”表示删除，“+”表示添加</p>
<p>-y 并排格式；使用-W 来调整输出的宽度</p>
<p>-e 创建一个 ed 脚本，如果运行该脚本的话，将会把 fileA 变为 fileB</p>
<p>-q 不报告发生的哪些变化，仅指出是否存在差异</p>
<p>-b 不考虑空格</p>
<p>-B 不考虑空白行</p>
<p>-i 忽略大小写</p>
<p>-r 当比较目录时，递归考察子目录</p>
<hr>
<h2 id="comm"><a href="#comm" class="headerlink" title="comm"></a>comm</h2><p>格式：<code>comm [options] file1 file2</code></p>
<p>作用：比较两个已排序的文件，并生成由三列组成的输出，各列之间以制表符分隔</p>
<p>第 1 列：所有出现在 file1 中但不在 file2 中的行</p>
<p>第 2 列：所有出现在 file2 中但不在 file1 中的行</p>
<p>第 3 列：所有同时出现在两个文件中的行</p>
<p>常用选项：</p>
<p>-1 不显示第 1 列</p>
<p>-2 不显示第 2 列</p>
<p>-3 不显示第 3 列</p>
<p>-23 显示仅在第一个文件中出现的行</p>
<p>-13 显示仅在第二个文件中出现的行</p>
<p>-12 显示同时出现在第一个和第二个文件中的行</p>
<hr>
<h2 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h2><p>格式：<code>cmp [options] file1 file2 [offset1 [offset2]]</code></p>
<p>作用：比较两个文件，如果它们的内容是一样的，则不会输出任何内容；否则给出第一处差异所在的位置。通常情况下，cmp 命令都是从每个文件的开头处开始比较，但如果提供了偏移量的话，则将从指定的地方开始比较</p>
<p>常用选项：</p>
<p>-l 长输出：逐字节输出所有差异</p>
<p>-s 静默输出：不打印任何东西，只在退出程序时返回相应的状态码；如果文件匹配，返回 0，如果不匹配返回 1（如果比较失败的话，则返回其他代码）</p>
<hr>
<h2 id="md5sum"><a href="#md5sum" class="headerlink" title="md5sum"></a>md5sum</h2><p>格式：<code>md5sum files | --check file</code></p>
<p>作用：md5sum 命令与校验和一起使用的时候，可以用来验证文件是否未经改动。该命令的第一种使用方式是通过 MD5 算法为指定文件生成 32 字节校验和；第二种使用方式则是测试校验和是否与相应的文件相匹配，这时需要使用–check 选项</p>
<p>注：shasum 是一个更为强大程序，但是（到目前为止）还不太流行，它可以使用不同的算法来生成更长的哈希值。因此，它要比 md5sum 更加可靠一些</p>
<hr>
<h2 id="处理-PDF-文件和-PostScript-文件"><a href="#处理-PDF-文件和-PostScript-文件" class="headerlink" title="处理 PDF 文件和 PostScript 文件"></a>处理 PDF 文件和 PostScript 文件</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>pdftotext</td>
<td>从 PDF 文件中提取文本</td>
</tr>
<tr>
<td>ps2ascii</td>
<td>从 PostScript 或 PDF 文件中提取文本</td>
</tr>
<tr>
<td>pdfseparate</td>
<td>从 PDF 中提取单页</td>
</tr>
<tr>
<td>pdftk</td>
<td>通过拆分、连接、旋转或以其他方式来操作 PDF 文件</td>
</tr>
<tr>
<td>pdf2ps，ps2pdf</td>
<td>实现 PDF 和 PostScript 之间的格式转换</td>
</tr>
</tbody></table>
<hr>
<h2 id="pdftotext"><a href="#pdftotext" class="headerlink" title="pdftotext"></a>pdftotext</h2><p>格式：<code>pdftotext [options] [file.pdf [outfile.txt]]</code></p>
<p>作用：从 PDF 文件中提取文本数据，并将其写入指定的文件中。只有当 PDF 包含实际文本，而非文本的图像时，该命令才能生效</p>
<p>常用选项：</p>
<p>-f N 从 PDF 的第 N 页开始。注意，必须在选项和数字之间留出空格</p>
<p>-l N 在 PDF 文件的第 N 页结束。同样，必须在选项和数字之间留出空格</p>
<p>-htmlmeta 生成 HTML，而非纯文本</p>
<p>-eol(dos|mac|unix) 在文本中使用给定操作系统的行尾字符</p>
<hr>
<h2 id="ps2ascii"><a href="#ps2ascii" class="headerlink" title="ps2ascii"></a>ps2ascii</h2><p>格式：<code>ps2ascii [file.(ps|pdf)] [outfile.txt]</code></p>
<p>作用：从 PostScript 或 PDF 文件中提取文本</p>
<hr>
<h2 id="pdfseparate"><a href="#pdfseparate" class="headerlink" title="pdfseparate"></a>pdfseparate</h2><p>格式：<code>pdfseparate [options] [file.pdf] [pattern.txt]</code></p>
<p>作用：将一个 PDF 文件分割成多个独立的 PDF 文件，每页对应一个文件。最后一个参数是单页文件名称的组成方式，其中的%d 表示提取的页码</p>
<p>常用选项：</p>
<p>-f N 从 PDF 的第 N 页开始。必须在选项和数字之间留出空格</p>
<p>-l N 至 PDF 文件的第 N 页结束。必须在选项和数字之间留出空格</p>
<hr>
<h2 id="pdftk"><a href="#pdftk" class="headerlink" title="pdftk"></a>pdftk</h2><p>格式：<code>pdftk [arguments]</code></p>
<p>作用：从 PDF 文件中提取页面，或将多个 PDF 文件合并成一个、旋转页面、添加水印、加密和解密等</p>
<hr>
<h2 id="pdf2ps"><a href="#pdf2ps" class="headerlink" title="pdf2ps"></a>pdf2ps</h2><p>格式：<code>pdf2ps [options] file.pdf [file.ps]</code>，<code>ps2pdf [options] file.ps [file.pdf]</code></p>
<p>作用：pdf2ps 命令可以将 Adobe PDF 文件转换为 PostScript 文件（如果不提供输出文件名，则默认使用输入文件名，只是将.pdf 替换为.ps 而已，其他部分不变）；相反，ps2pdf 命令则可以将 PostScript 文件转换为 PDF 格式</p>
<hr>
<h2 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>lpr</td>
<td>打印文件</td>
</tr>
<tr>
<td>lpq</td>
<td>查看打印队列</td>
</tr>
<tr>
<td>lprm</td>
<td>从队列中删除打印作业</td>
</tr>
</tbody></table>
<hr>
<h2 id="lpr"><a href="#lpr" class="headerlink" title="lpr"></a>lpr</h2><p>格式：<code>lpr [options] [files]</code></p>
<p>作用：向打印机发送文件</p>
<p>常用选项：</p>
<p>-P printername 将文件发送给之前设置的打印机 printername</p>
<p><code>- #N</code> 打印 N 份副本</p>
<p>-J name 设置封面打印作业 name（如果系统已经设置为打印封面的话）</p>
<hr>
<h2 id="lpq"><a href="#lpq" class="headerlink" title="lpq"></a>lpq</h2><p>格式：<code>lpq [options]</code></p>
<p>作用：显示处于等待状态的所有打印任务</p>
<p>常用选项：</p>
<p>-P printername 显示打印机 printername 的队列</p>
<p>-a 显示所有打印机的队列</p>
<p>-l 冗长模式：使用长格式显示信息</p>
<hr>
<h2 id="lprm"><a href="#lprm" class="headerlink" title="lprm"></a>lprm</h2><p>格式：<code>lprm [options] [job_IDs]</code></p>
<p>作用：取消一个或多个打印作业。如果不提供任何作业 ID 的话，当前的打印作业将被取消（注意，只有超级用户才能够取消其他用户的作业）。-P 选项用来指出作业所在的打印队列</p>
<hr>
<h2 id="拼写检查"><a href="#拼写检查" class="headerlink" title="拼写检查"></a>拼写检查</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>look</td>
<td>快速检查单词的拼写是否出错</td>
</tr>
<tr>
<td>aspell</td>
<td>交互式的拼写检查程序</td>
</tr>
<tr>
<td>spell</td>
<td>批处理式的拼写检查程序</td>
</tr>
</tbody></table>
<hr>
<h2 id="look"><a href="#look" class="headerlink" title="look"></a>look</h2><p>格式：<code>look [options] prefix [dictionary_file]</code></p>
<p>作用：打印以给定字符串 prefix 开头的单词，这些单词通常位于一个字典文件中（默认为&#x2F;usr&#x2F;share&#x2F;dict&#x2F;words）。当你提供自己的字典文件（可以是任何文本文件，只要各行按字母顺序排序即可）时，look 命令将打印以给定字符串 prefix 开头的所有行</p>
<p>常用选项：</p>
<p>-f 忽略大小写</p>
<p>-t X 设置终止字符 X，即将该字符之前（包括该字符）的内容作为匹配字</p>
<hr>
<h2 id="aspell"><a href="#aspell" class="headerlink" title="aspell"></a>aspell</h2><p>格式：<code>aspell [options] file | command</code></p>
<p>作用：找出无法识别的单词，并给出相应的替代词</p>
<p>常用命令：</p>
<p>aspell -c file 通过交互方式对文件中的所有单词的拼写进行检查和纠正</p>
<p>aspell dump master 在标准输出上显示 aspell 的主字典</p>
<p>aspell help 打印一个简明的帮助信息</p>
<hr>
<h2 id="spell"><a href="#spell" class="headerlink" title="spell"></a>spell</h2><p>格式：<code>spell [files]</code></p>
<p>作用：输出给定文件中与其字典相比存在拼写错误的所有单词</p>
<hr>
<h2 id="磁盘和文件系统"><a href="#磁盘和文件系统" class="headerlink" title="磁盘和文件系统"></a>磁盘和文件系统</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>df</td>
<td>显示已挂载文件系统上的可用空间</td>
</tr>
<tr>
<td>mount</td>
<td>使磁盘分区可以访问</td>
</tr>
<tr>
<td>umount</td>
<td>卸载磁盘分区（使其无法访问）</td>
</tr>
<tr>
<td>fsck</td>
<td>检查磁盘分区是否出错</td>
</tr>
<tr>
<td>eject</td>
<td>弹出 CD、DVD 或其他可移动磁盘</td>
</tr>
</tbody></table>
<hr>
<h2 id="df"><a href="#df" class="headerlink" title="df"></a>df</h2><p>格式：<code>df [options] [disk devices | files | directories]</code></p>
<p>作用：显示给定磁盘分区的大小，以及其中已用空间和可用空间的大小。如果指定了文件或目录的话，df 将提供该文件或目录所在的磁盘设备的相关数据。如果不提供参数的话，df 将会显示已挂载的所有文件系统的使用情况</p>
<p>常用选项：</p>
<p>-k 以千字节为单位显示大小（默认值）</p>
<p>-m 以兆字节为单位显示大小</p>
<p>-B N 显示区块数目，并将区块大小指定为 N 个字节（默认值&#x3D;1024）</p>
<p>-h|-H 为了以可读性较高的方式来显示信息，为每个空间大小选择最合适的单位。使用-h 选项时，1K&#x3D;1000；使用-H 选项时，1K&#x3D;1024</p>
<p>-l 仅显示本地文件系统，而不显示网络文件系统</p>
<p>-T 在输出中提供文件系统类型</p>
<p>-t type 仅显示给定类型的文件系统</p>
<p>-x type 不显示给定类型的文件系统</p>
<p>-i Inode 模式。显示每个文件系统的 inode 总量以及已经使用和空闲的 inode 数量，而不是磁盘块的相应数量</p>
<hr>
<h2 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h2><p>格式：<code>mount [options] device | directory</code></p>
<p>作用：挂载分区，使其处于可用状态</p>
<p>常用选项：</p>
<p>-t type 指定文件系统的类型</p>
<p>-l 显示所有已挂载的文件系统，也可以与-t 组合使用</p>
<p>-a 挂载&#x2F;etc&#x2F;fstab 中列出的所有文件系统。忽略包含 noauto 选项的条目，也可以与-t 组合使用</p>
<p>-r 挂载只读文件系统</p>
<hr>
<h2 id="umount"><a href="#umount" class="headerlink" title="umount"></a>umount</h2><p>格式：<code>umount [options] [device | directory]</code></p>
<p>作用：卸载磁盘分区，使其无法通过文件系统访问</p>
<p>注：sudo umount -a 可卸载所有已挂载设备，但请不要这么操作</p>
<hr>
<h2 id="fsck"><a href="#fsck" class="headerlink" title="fsck"></a>fsck</h2><p>格式：<code>fsck [options] [devices]</code></p>
<p>作用：验证 Linux 磁盘分区并按需修复发现的错误</p>
<p>注：一般来说，在检查设备之前需要先将其卸载，以便保证没有其他程序同时对其进行操作。fsck 命令实际上是位于&#x2F;sbin 目录中的一组文件系统检查程序的前端程序，这些程序的名称都是以“fsck”开头。该命令只支持某些类型的文件系统，可以使用以下命令将其列出：<code>ls /sbin/fsck.* | cut -d. -f2</code></p>
<p>常用选项：</p>
<p>-A 按顺序检查&#x2F;etc&#x2F;fstab 中列出的所有磁盘</p>
<p>-N 输出检测报告，但是不进行修复</p>
<p>-r 通过交互方式修复错误，执行每项修复任务之前都会进行提示</p>
<p>-a 自动修复错误（只有当你真正了解所执行的这些任务时，才可以使用这个选项；否则，将会带来严重的后果）</p>
<hr>
<h2 id="eject"><a href="#eject" class="headerlink" title="eject"></a>eject</h2><p>格式：<code>eject [options] [device_name]</code></p>
<p>作用：弹出可移动设备</p>
<p>注：使用该命令时，其中的可移动介质必须处于可以弹出的状态</p>
<p>常用选项：</p>
<p>-h 显示帮助信息</p>
<p>-n 显示选定的设备，但是不执行任何动作。可以结合-v 显示选定设备的详细描述</p>
<p>-v 产生详细输出</p>
<p>-d 显示要弹出的默认设备的名称，然后退出</p>
<p>-c N 从光驱柜中选择光驱 N</p>
<hr>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>rsync</td>
<td>即使在跨网络环境下，也可以高效地复制一个文件集合</td>
</tr>
<tr>
<td>dd</td>
<td>完成数据的低级复制</td>
</tr>
<tr>
<td>growisofs</td>
<td>刻录 DVD 或蓝光光盘</td>
</tr>
</tbody></table>
<hr>
<h2 id="rsync"><a href="#rsync" class="headerlink" title="rsync"></a>rsync</h2><p>格式：<code>rsync [options] source destination</code></p>
<p>作用：复制一组文件，既可以进行精确复制，包括文件权限和其他属性（这种方式称为镜像），也可以只复制数据。此外，它不仅可以通过网络运行，也可以在单机上运行</p>
<p>常用选项：</p>
<p>-o 复制文件的所有权（可能需要远程主机的超级用户权限）</p>
<p>-g 复制文件属组信息（可能需要远程主机的超级用户权限）</p>
<p>-p 复制文件权限</p>
<p>-t 复制时间戳</p>
<p>-r 递归复制目录（即包括其内容）</p>
<p>-l 允许复制符号链接（而不是指向它们的文件）</p>
<p>-D 允许复制设备（仅限超级用户）</p>
<p>-a 镜像：复制原始文件的所有属性。这意味着使用选项-ogptrlD</p>
<p>-x 当复制文件树时，在当前的文件系统中进行，不要涉及已挂载的其他文件系统</p>
<p>-n Dry 运行模式：实际上不进行任何复制，只是显示哪些文件将被传输</p>
<p>-v 详细模式：输出复制期间发生的情况的详细信息。添加–progress 后，在复制文件时会以数字方式显示进度</p>
<hr>
<h2 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h2><p>格式：<code>dd [options]</code></p>
<p>作用：完成二进制位和字节低层操作的复制，它可以将数据从一个文件复制到另一个文件，也可以在复制时进行数据转换，设置可以通过设备复制的方式来克隆磁盘（警告：该操作会彻底摧毁目标设备上的所有数据）</p>
<p>常用选项：</p>
<p>if&#x3D;file 指定输入文件或设备</p>
<p>of&#x3D;file 指定输出文件或设备</p>
<p>bs&#x3D;N 一次复制 N 个字节，称为“块大小”（要设置输入和输出的块大小，请分别使用 ibs 和 obs）</p>
<p>skip&#x3D;N 在开始复制之前跳过 N 个输入块</p>
<p>seek&#x3D;N 在开始复制之前丢弃 N 个输出块</p>
<p>conv&#x3D;spec 对复制的数据进行转换。spec 可以是 ucase（转换为大写字母）、lcase（转换为小写）、ascii（从 EBCDIC 转换为 ASCII）</p>
<hr>
<h2 id="growisofs"><a href="#growisofs" class="headerlink" title="growisofs"></a>growisofs</h2><p>格式：<code>growisofs [options] tracks</code></p>
<p>作用：刻录可写的 CD、DVD 或 Blu-ray 光盘</p>
<p>步骤：</p>
<ul>
<li><p>通过以下命令找到光盘刻录机设备：<code>more /proc/sys/dev/cdrom/info</code></p>
</li>
<li><p>将要刻录的文件放到相应的目录中，比如 dir。根据需要，进行相应的组织安排。需要注意的是，目录 dir 本身不会被复制到光盘，仅复制其内容</p>
</li>
<li><p>使用 mkisofs 命令创建 ISO（光盘）映像文件，并使用 growisofs 将其刻录到光盘上，假设你的设备是&#x2F;dev&#x2F;sr1，具体命令如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mkisofs -R -l -o <span class="variable">$HOME</span>/mydisk.iso <span class="built_in">dir</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">growisofs -dvd-compat -Z /dev/sr1=<span class="variable">$HOME</span>/mydisk.iso</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">rm</span> <span class="variable">$HOME</span>/mydisk.iso</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>注：如果要刻录音频 CD，请使用更加友好的图形工具，例如 k3b</p>
<hr>
<h2 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ps</td>
<td>显示进程</td>
</tr>
<tr>
<td>uptime</td>
<td>查看系统负载</td>
</tr>
<tr>
<td>w</td>
<td>列出所有用户的活动进程</td>
</tr>
<tr>
<td>top</td>
<td>以交互方式查看资源密集型进程</td>
</tr>
<tr>
<td>free</td>
<td>显示可用内存</td>
</tr>
</tbody></table>
<hr>
<h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p>格式：<code>ps [options]</code></p>
<p>作用：显示用户正在运行的进程的相关信息，也可以显示其他用户的进程信息，为可选项</p>
<p>示例命令：</p>
<p>查看自己当前运行的进程：<code>ps -ux</code></p>
<p>查看用户 wayne 的所有进程：<code>ps -U wayne</code></p>
<p>一个程序的所有进程：<code>ps -C program_name</code></p>
<p>在终端 N 上的各个进程：<code>ps -tN</code></p>
<p>显示特定的进程，比如进程 1、2 和 3505：<code>ps -p1,2,3505</code></p>
<p>输出所有进程的信息，但是输出信息的宽度会根据屏幕宽度截取：<code>ps -ef</code></p>
<p>输出所有进程的完整信息，避免详细参数被截断：<code>ps -efww</code></p>
<p>输出所有进程的信息，并根据线程的角度，对隶属于同一个父进程之下的子进程进行缩进处理：<code>ps -efH</code></p>
<p>注：可以借助 grep 和其他过滤程序，以更精细的方式从 ps 的输出中提取信息</p>
<hr>
<h2 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h2><p>格式：<code>uptime</code></p>
<p>作用：指出从上次启动以来系统已经运行了多长时间</p>
<hr>
<h2 id="w"><a href="#w" class="headerlink" title="w"></a>w</h2><p>格式：<code>w [username]</code></p>
<p>作用：显示所有登录用户在每个 shell 中运行的当前进程，如果提供了用户名的话，就只输出该用户的有关信息</p>
<p>常用选项：</p>
<p>-h 不显示标题行</p>
<p>-f 不显示 FROM 列</p>
<p>-s 不显示 JCPU 和 PCPU 列</p>
<hr>
<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>格式：<code>top [options]</code></p>
<p>作用：监视最活跃的进程，并能够定期更新信息。它是一个基于屏幕的程序，以交互方式更新显示内容。top 运行过程中，可以通过按键来改变其行为，例如设置更新速度（s）、隐藏空闲进程（i）或杀死进程（k）。输入 h 则可以查看完整的列表，输入 q 退出。此外，还有一些类似的程序可以用来监控系统的 I&#x2F;O 和网络带宽，如 iotop 和 iftop</p>
<p>常用选项：</p>
<p>-nN 执行 N 次更新，然后退出</p>
<p>-dN 每 N 秒更新一次显示内容</p>
<p>-pN-pM… 仅显示 PID 为 N，M，…的进程的信息，最多显示 20 个进程的信息</p>
<p>-c 显示进程的命令行参数</p>
<p>-b 将信息以非交互式显示到标准输出，所以无需使用与屏幕显示方面的交互技巧。<code>top -b -n1&gt; outfile</code>将快照保存到文件中</p>
<hr>
<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><p>格式：<code>free [options]</code></p>
<p>作用：显示内存的使用情况（以千字节为单位）</p>
<p>常用选项：</p>
<p>-s N 连续运行，每 N 秒更新一次显示内容</p>
<p>-b 显示字节数</p>
<p>-m 显示数量（兆字节）</p>
<p>-t 在底部添加总行数</p>
<p>-o 不显示“buffers&#x2F;cache”行</p>
<hr>
<h2 id="控制进程"><a href="#控制进程" class="headerlink" title="控制进程"></a>控制进程</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>kill</td>
<td>终止进程（或向其发送信号）</td>
</tr>
<tr>
<td>timeout</td>
<td>终止运行时间太长的命令</td>
</tr>
<tr>
<td>nice</td>
<td>调用特定优先级的程序</td>
</tr>
<tr>
<td>renice</td>
<td>在运行时更改进程的优先级</td>
</tr>
<tr>
<td>flock</td>
<td>确保同一时刻只有一个进程副本在运行，这要用到锁</td>
</tr>
</tbody></table>
<hr>
<h2 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h2><p>格式：<code>kill [options] [process_ids]</code></p>
<p>作用：向进程发送信号，从而达到终止进程（默认动作）、中断进程、挂起进程、使其崩溃等目的，但是前提条件是，你必须是这个进程的属主，或者是超级用户，这样才有权限执行这些操作</p>
<p>操作示例：</p>
<p>例如，要终止进程 13243，可以运行如下所示的命令：</p>
<p><code>kill 13243</code></p>
<p>如果该命令没有作用的话（一些程序会捕获该信号，但是并不终止运行），可以添加-KILL 或-9 选项，这两个选项是等价的：</p>
<p><code>kill -9 13243</code></p>
<p>这样一来，就肯定能终止进程了。但是，这样无法让程序“干净利索”地退出，从而导致进程死亡后，无法全部释放所占用的资源（或导致其他的问题）</p>
<p>如果你不知道进程的 PID，可以运行 ps，然后从输出结果中找到（以 emacs 为例）：</p>
<p><code>ps -aux | grep emacs</code></p>
<p>当然，最好还是使用 pidof 命令，利用它可以通过进程名称来查找进程，并输出其 PID：</p>
<p><code>pidof emacs</code></p>
<p>现在，可以通过使用 shell 的反引号来执行 pidof，终止已知其程序名称的进程了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill `pidof emacs`</span><br></pre></td></tr></table></figure>

<p>或者使用 killall 命令终止给定程序的所有进程：</p>
<p><code>killall emacs</code></p>
<p>除了位于文件系统中的 kill 程序（通常位于&#x2F;bin&#x2F;kill）之外，大多数 shell 都提供了内置的 kill 命令，不过两者在语法和行为方面有所差异。但是，它们都支持以下用法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill -N PID</span><br><span class="line">kill -NAME PID</span><br></pre></td></tr></table></figure>

<p>其中 N 是信号编号，NAME 是信号字符串“SIG”开头的信号名称（例如，使用-HUP 发送 SIGHUP 信号）。使用<code>kill -l</code>命令查看 kill 传输的所有信号</p>
<hr>
<h2 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a>timeout</h2><p>格式：<code>timeout [options] seconds command...</code></p>
<p>作用：限制另一个程序的运行时间（以秒为单位），如果程序运行时间超过规定的范围，timeout 将会终止其运行</p>
<p>常用选项：</p>
<p>-s signal 发送默认值（TERM）之外的信号</p>
<p>-k seconds 如果程序在第一个信号之后没有终止，那么在等待规定的秒数之后，发送致命的 KILL 信号</p>
<hr>
<h2 id="nice"><a href="#nice" class="headerlink" title="nice"></a>nice</h2><p>格式：<code>nice [-n level] command_line</code></p>
<p>作用：在调用占用大量系统资源的程序时，可以通过降低其优先级，从而让它谦让一下其他进程（和用户）。它为一个进程设置了一个优先级数值（一个谦让度值），从而降低 Linux 进程调度程序对它的关注程度，即调整进程的优先级</p>
<p>操作示例：</p>
<p>将一个大型任务的优先级数值设置为 7：</p>
<p><code>nice -n 7 sort hugefile &gt; outfile</code></p>
<p>在运行 nice 的时候，如果不指定优先级的话，则使用 10。正常进程（运行时没有指定优先级）运行在零级，为了查看进程的优先级，可以直接运行 nice，不要加任何参数，具体如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">nice</span></span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>超级用户也可以降低进程的优先程度，为此，只需指定更大的优先级数值即可：</p>
<p><code>sudo nice -n -10 myprogram</code></p>
<p>为了了解自己的任务的优先级数值，可以借助 ps 于命令，只要看看该命令输出中的“NI”列就知道了：</p>
<p><code>ps -o pid,user,args,nice</code></p>
<hr>
<h2 id="renice"><a href="#renice" class="headerlink" title="renice"></a>renice</h2><p>格式：<code>renice [-n N] [options] PID</code></p>
<p>作用：修改已运行的进程的优先级级别</p>
<p>注：普通用户可以增加自己进程的优先级数值，而超级用户还可以降低该数值（提高优先程度），并且可以对任何进程进行该操作。优先级的取值范围为-20~+20，但是，我们要尽量避免使用绝对值较大的负数，否则可能会干扰重要的系统进程</p>
<p>常用选项：</p>
<p>-p pid 影响给定的进程 ID。这里可以省略-p，直接提供 PID</p>
<p>-u username 影响给定用户拥有的所有进程</p>
<hr>
<h2 id="flock"><a href="#flock" class="headerlink" title="flock"></a>flock</h2><p>格式：<code>flock [options] lockfile command...</code></p>
<p>作用：通过为多个命令指定同一个锁定文件，起到防止备份脚本之类的命令同时运行多个副本的作用</p>
<p>常用选项：</p>
<p>-n 如果另一个命令已经运行，则立即失败</p>
<p>-w N 如果另一个命令已经在运行，则等待 N 秒后失败</p>
<p>-s 使用<strong>共享锁</strong>而不是<strong>排他锁</strong>。你可以使用该选项同时运行多个命令，但如果省略该选项，则 flock 将失败。这个选项对于允许有限数量的命令同时运行是非常有用的</p>
<hr>
<h2 id="作业调度"><a href="#作业调度" class="headerlink" title="作业调度"></a>作业调度</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>sleep</td>
<td>暂停指定的秒数，除了等待什么也不做</td>
</tr>
<tr>
<td>watch</td>
<td>以指定的时间间隔重复运行程序</td>
</tr>
<tr>
<td>at</td>
<td>在将来某个时间执行一次任务</td>
</tr>
<tr>
<td>crontab</td>
<td>为将来某些时间点安排任务</td>
</tr>
</tbody></table>
<hr>
<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>格式：<code>sleep time_specification</code></p>
<p>作用：等待一定的时间。在指定时间的时候，可以使用一个整数（单位是秒），或一个整数，后跟字母 s（也就是秒），m（分钟），h（小时）或 d（天）</p>
<hr>
<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>格式：<code>watch [options] command</code></p>
<p>作用：定期重复执行指定的命令；默认的时间间隔是两秒。该命令将被传递给 shell（所以一定要对特殊字符使用引号或进行转义处理）执行，并且运行结果将以全屏模式显示，以便于观察输出结果，看看发生了什么变化。退出时，按 Ctrl+C</p>
<p>常用选项：</p>
<p>-n seconds 设置两次执行之间的时间间隔（以秒为单位）</p>
<p>-d 高亮显示输出，强调两次执行之间发生的变化</p>
<p>-g 当命令的运行结果与上一次的不同时，退出</p>
<hr>
<h2 id="at"><a href="#at" class="headerlink" title="at"></a>at</h2><p>格式：<code>at [options] time_specification</code></p>
<p>作用：在规定的时间运行一次 shell 命令</p>
<p>注：可以通过&#x2F;usr&#x2F;share&#x2F;doc&#x2F;at&#x2F;time-spec 了解其详细语法</p>
<p>常用选项：</p>
<p>-f filename 从给定文件读取命令，而不是标准输入</p>
<p>-c job_number 将作业命令显示到标准输出</p>
<hr>
<h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><p>格式：<code>crontab [options] [file]</code></p>
<p>作用：在特定的时间调度作业，适用于重复性的工作。为了使此类工作顺利进行，可以编辑并保存一个名为 crontab 的文件，通常该文件自动安装在系统目录（&#x2F;var&#x2F;spool&#x2F;cron）中的。每过一分钟，一个名为 cron 的 Linux 进程就会被唤醒，并检查你的 crontab 文件，执行所有到期的作业</p>
<p>常用命令：</p>
<p><code>crontab -e</code> 使用默认编辑器（$VISUAL）编辑 crontab 文件</p>
<p><code>crontab -l</code> 在标准输出上显示 crontab 文件</p>
<p><code>crontab -r</code> 删除 crontab 文件</p>
<p><code>crontab myfile</code> 将文件 myfile 安装为 crontab 文件</p>
<p>注：超级用户可以添加选项-u username，来处理其他用户的 crontab 文件</p>
<hr>
<h2 id="登录、注销与关机"><a href="#登录、注销与关机" class="headerlink" title="登录、注销与关机"></a>登录、注销与关机</h2><hr>
<h2 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h2><p>格式：<code>shutdown [options] time [message]</code></p>
<p>作用：停止或重新启动 Linux 系统。只有超级用户才有权运行该命令</p>
<p>注：对于 time 参数，可以用加号后跟分钟数表示的相对时间，或用小时和分钟表示的绝对时间，或用 now 这个词表示立即。如果不使用选项的话，shutdown 会让系统进入单用户模式，这是一个特殊的维护模式，只允许一个人（从系统控制台）登录系统，同时，所有非必需的服务都将被关闭。要想退出单用户模式，可以再次执行 shutdown 命令来停止或重新启动系统，或输入 Ctrl+D 以使系统进入正常的多用户模式</p>
<p>常用选项：</p>
<p>-r 重启系统</p>
<p>-h 关闭系统</p>
<p>-k 模拟关机，并非真的关机，只是向所有用户发送警告消息，就像系统正在关闭一样</p>
<p>-c 取消已经在执行的 shutdown 指令（省略 time 参数）</p>
<p>-f 重新启动时，跳过 fsck 程序所执行的常规系统检查</p>
<p>-F 在重新启动时，进行常规的系统检查</p>
<hr>
<h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><p>格式：<code>systemctl [options] command [arguments]</code></p>
<p>作用及说明：在一些 Linux 发行版中，shutdown 命令实际上是 systemctl 命令的一个符号链接；而 systemctl 则是一个用于启动和停止各种服务的多用途命令。实际上，systemctl 只是名为 systemd 的服务管理器的一部分</p>
<p>常用命令：</p>
<p><code>sudo systemctl poweroff</code> 关闭系统</p>
<p><code>sudo systemctl reboot</code> 重启系统</p>
<p><code>sudo systemctl suspend</code> 挂起系统</p>
<hr>
<h2 id="用户及环境变量"><a href="#用户及环境变量" class="headerlink" title="用户及环境变量"></a>用户及环境变量</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>logname</td>
<td>显示登录名</td>
</tr>
<tr>
<td>whoami</td>
<td>显示当前的有效用户名</td>
</tr>
<tr>
<td>id</td>
<td>显示用户的用户 ID 和组 ID</td>
</tr>
<tr>
<td>who</td>
<td>显示目前登录系统的用户，给出详细信息</td>
</tr>
<tr>
<td>users</td>
<td>显示目前登录系统的用户，给出简要信息</td>
</tr>
<tr>
<td>finger</td>
<td>显示用户的相关信息</td>
</tr>
<tr>
<td>last</td>
<td>显示用户最近登录时间</td>
</tr>
<tr>
<td>printenv</td>
<td>显示环境变量的值</td>
</tr>
</tbody></table>
<hr>
<h2 id="logname"><a href="#logname" class="headerlink" title="logname"></a>logname</h2><p>格式：<code>logname</code></p>
<p>作用：显示用户的登录名</p>
<p>注：如果在你的系统上无法使用此命令，请尝试<code>echo $LOGNAME</code></p>
<hr>
<h2 id="whoami"><a href="#whoami" class="headerlink" title="whoami"></a>whoami</h2><p>格式：<code>whoami</code></p>
<p>作用：显示当前有效的用户名称。如果你用过 sudo 命令的话，该名称可能与（logname 命令输出的）登录名不同</p>
<hr>
<h2 id="id"><a href="#id" class="headerlink" title="id"></a>id</h2><p>格式：<code>id [options] [username]</code></p>
<p>作用：显示用户 ID、用户组 ID 及其关联的用户名称和组名称</p>
<p>常用选项：</p>
<p>-u 显示有效用户 ID 并退出</p>
<p>-g 显示有效组 ID 并退出</p>
<p>-G 显示用户所属的所有其他组的 ID</p>
<p>-n 显示（用户和用户组的）名称，而不是数字 ID。必须与-u、-g 或-G 选项组合使用</p>
<p>-r 显示登录 ID 而不是有效 ID，必须与-u、-g 或-G 选项组合使用</p>
<hr>
<h2 id="who"><a href="#who" class="headerlink" title="who"></a>who</h2><p>格式：<code>who [options] [filename]</code></p>
<p>作用：列出所有登录用户，每行一个用户 shell</p>
<p>注：通常，who 将从&#x2F;var&#x2F;run&#x2F;utmp 文件获取相应的数据，filename 参数可以用于指定不同的数据文件，例如用&#x2F;var&#x2F;log&#x2F;wtmp 记录过去的登录情况，或用&#x2F;var&#x2F;log&#x2F;btmp 记录失败的登录</p>
<p>常用选项：</p>
<p>-H 将第一行作为标题显示</p>
<p>–lookup 对于远程登录的用户，显示原始主机名</p>
<p>-u 在用户的终端上显示其空闲时间</p>
<p>-T 指出每个用户的终端是否可写。加号表示“是”，减号表示“否”，问号表示“未知”</p>
<p>-m 仅显示当前用户的信息（即与当前终端相关联的用户）</p>
<p>-q 仅显示用户名和用户数，该命令与 users 命令非常类似，只是增加了一个用户数</p>
<hr>
<h2 id="users"><a href="#users" class="headerlink" title="users"></a>users</h2><p>格式：<code>users [filename]</code></p>
<p>作用：显示已经登陆的用户的快速列表（如果用户正在运行多个 shell，则会在表中出现多次）</p>
<p>注：像 who 命令一样，默认情况下 users 命令将读取&#x2F;var&#x2F;log&#x2F;utmp 文件，但是也可以通过设置让它从另一个文件读取相关信息</p>
<hr>
<h2 id="finger"><a href="#finger" class="headerlink" title="finger"></a>finger</h2><p>格式：<code>finger [options] [user[@host]]</code></p>
<p>作用：显示已经登录的用户的简要或详细信息</p>
<p>注：参数 user 可以是本地用户名或远程用户，该参数的具体形式为 user@host。当然，远程主机只有做了相应配置时才会响应该 finger 命令的请求</p>
<p>常用选项：</p>
<p>-l 显示详细信息</p>
<p>-s 显示简要信息</p>
<p>-p 不显示 Project 和 Plan 部分，这两部分通常分别从用户的<del>&#x2F;.project 和</del>&#x2F;.plan 文件中读取</p>
<hr>
<h2 id="last"><a href="#last" class="headerlink" title="last"></a>last</h2><p>格式：<code>last [options] [users] [ttys]</code></p>
<p>作用：显示历史登录信息，按时间逆序排列；可以提供用户名或 tty 名称来限定输出的内容</p>
<p>常用选项：</p>
<p>-N 仅显示最近期的 N 行输出，其中 N 为正整数</p>
<p>-i 显示 IP 地址而不是主机名</p>
<p>-R 不显示主机名</p>
<p>-x 显示系统关闭和系统运行级别的变化情况（例如，从单用户模式到多用户模式）</p>
<p>-f filename 从&#x2F;var&#x2F;run&#x2F;wtmp 之外的其他文件中读取数据</p>
<hr>
<h2 id="printenv"><a href="#printenv" class="headerlink" title="printenv"></a>printenv</h2><p>格式：<code>printenv [environment_variables]</code></p>
<p>作用：输出 shell 所知的所有环境变量及其值，或只显示指定的变量</p>
<hr>
<h2 id="用户帐户管理"><a href="#用户帐户管理" class="headerlink" title="用户帐户管理"></a>用户帐户管理</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>useradd</td>
<td>创建一个帐户</td>
</tr>
<tr>
<td>userdel</td>
<td>删除一个帐户</td>
</tr>
<tr>
<td>usermod</td>
<td>修改帐户</td>
</tr>
<tr>
<td>passwd</td>
<td>修改密码</td>
</tr>
<tr>
<td>chfn</td>
<td>修改用户的个人信息</td>
</tr>
<tr>
<td>chsh</td>
<td>修改用户的 shell</td>
</tr>
</tbody></table>
<hr>
<h2 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h2><p>格式：<code>useradd [options] username</code></p>
<p>作用：超级用户可以通过此命令来创建用户帐户</p>
<p>注：由于该命令的默认选项不是非常有用（运行 useradd -D 可以查看默认选项），因此，请确保提供所需的全部选项</p>
<p>常用选项：</p>
<p>-d dir 将用户的主目录设置为 dir</p>
<p>-s shell 将用户的登录 shell 设置为 shell</p>
<p>-u uid 将用户的 ID 设置为 uid。除非你自己十分有把握，否则请忽略该选项并接受默认值</p>
<p>-c string 设置用户的 comment 字段（历史上称为 GECOS 字段）。通常情况下，该字段被设为用户的全名，但实际上可以是任何字符串。chfn 命令还可以用来设置该信息</p>
<p>-g group 将用户的初始（默认）组设置为 group，它可以是数字形式的组 ID 或组名称，但是，这些组必须是已经存在的</p>
<p>-G group1,group2,… 让用户加入现有的其他组，即 group1，group2 等</p>
<p>-m 将系统基干目录&#x2F;etc&#x2F;skel 中的所有文件复制到新创建的主目录中。基干目录通常用来存放初始化文件的最小（基干）版本，如~&#x2F;.bash_profile，以供新用户使用。如果你希望从不同的目录复制这些文件，请添加-k 选项（-k dirname）</p>
<hr>
<h2 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h2><p>格式：<code>userdel [-r] username</code></p>
<p>作用：删除现有帐户</p>
<p>注：除非提供-r 选项，否则它不会删除用户主目录中的文件。删除用户之前，请务必仔细斟酌；如无必要，请首先考虑停用帐户（使用 usermod -L）。在删除帐户之前，请确保已备份该用户的所有文件，因为有时候你可能会需要用到它们</p>
<hr>
<h2 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h2><p>格式：<code>usermod [options] username</code></p>
<p>作用：以各种方式修改给定用户的帐户</p>
<p>常用选项：</p>
<p>-d dir 将用户的主目录改为 dir</p>
<p>-l username 将用户的登录名改为 username。在修改登录名之前，请三思而后行，一定要避免系统上还有某些内容依赖于原始名称的情况的发生。同时，一般不要更改系统帐户（root，daemon 等），除非你真的清楚自己在做什么！</p>
<p>-s shell 将用户的登录 shell 改为 shell</p>
<p>-g group 将用户的初始（默认）组改为 group，它可以是数字形式的组 ID 或组名称，但是这些组必须是已经存在的</p>
<p>-G group1,group2,… 修改用户所属的附加群组，即 group1，group2 等现有的组。如果用户在此之前已经加入其他组，但是这里没有给出这些组的话，则用户将退出这些组</p>
<p>-L 禁用（锁定）帐户，以使用户无法登录</p>
<p>-U 在执行锁定（-L）操作后，为帐户解锁</p>
<hr>
<h2 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h2><p>格式：<code>passwd [options] [username]</code></p>
<p>作用：更改登录密码，或以超级用户身份来修改其他用户密码</p>
<hr>
<h2 id="chfn"><a href="#chfn" class="headerlink" title="chfn"></a>chfn</h2><p>格式：<code>chfn [options] [username]</code></p>
<p>作用：更新系统维护的个人信息：真实姓名、家庭电话、办公室电话和办公室位置。如果调用该命令的时候没有指定用户名的话，chfn 命令就是针对你的帐户；如果（以 root 身份）调用该命令时提供了用户名，那么它就会更新该用户的相关信息。如果不提供任何选项的话，chfn 将提示你输入所需的信息</p>
<p>常用选项：</p>
<p>-f name 将全名改为 name</p>
<p>-h phone 将家庭电话号码改为 phone</p>
<p>-p phone 将办公室电话号码改为 phone</p>
<p>-o office 将办公室地址改为 office</p>
<hr>
<h2 id="chsh"><a href="#chsh" class="headerlink" title="chsh"></a>chsh</h2><p>格式：<code>chsh [options] [username]</code></p>
<p>作用：设置登录 shell 程序。如果调用时没有指定用户名的话，chsh 默认会修改用户自己的登录 shell；如果（以 root 身份）调用该命令时指定了用户名的话，它会修改指定用户的登录 shell。如果没有给出任何选项的话，chsh 将提示你输入所需信息。当然，新的 shell 必须是存在于文件&#x2F;etc&#x2F;shells 中的</p>
<p>常用选项：</p>
<p>-s shell 指定新的 shell</p>
<p>-l 列出所有可用的 shell</p>
<hr>
<h2 id="用户组的管理"><a href="#用户组的管理" class="headerlink" title="用户组的管理"></a>用户组的管理</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>groups</td>
<td>显示用户所在组</td>
</tr>
<tr>
<td>groupadd</td>
<td>创建用户组</td>
</tr>
<tr>
<td>groupdel</td>
<td>删除用户组</td>
</tr>
<tr>
<td>groupmod</td>
<td>修改用户组</td>
</tr>
</tbody></table>
<hr>
<h2 id="groups"><a href="#groups" class="headerlink" title="groups"></a>groups</h2><p>格式：<code>groups [usernames]</code></p>
<p>作用：显示你所属的或其他用户所属的 LInux 组</p>
<hr>
<h2 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h2><p>格式：<code>groupadd [options] group</code></p>
<p>作用：创建组。在大多数情况下，应该使用-f 选项来防止创建重名的组</p>
<p>常用选项：</p>
<p>-g gid 自己指定数字组 ID，而不是让 groupadd 选择一个</p>
<p>-f 如果指定的组已经存在，给出提示并退出</p>
<hr>
<h2 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h2><p>格式：<code>groupdel group</code></p>
<p>作用：删除现有的组</p>
<p>注：在进行该项操作之前，最好找出所有组 ID 被设置为给定组的文件，以便稍后处理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo find / -group &lt;group&gt; -<span class="built_in">print</span></span></span><br></pre></td></tr></table></figure>

<p>因为 groupdel 不会改变文件所属的组。它只是从系统中删除相应的组的名称。如果你显示这些文件的话，你会看到数字组 ID，而不是组名</p>
<hr>
<h2 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h2><p>格式：<code>groupmod [options] group</code></p>
<p>作用：修改给定组，改变其名称或组 ID</p>
<p>注：groupmod 命令不影响属于该组的任何文件：它只是修改系统记录中的 ID 或名称。但是，更改 ID 时要小心，否则会导致这些文件归属于不存在的组</p>
<p>常用选项：</p>
<p>-n name 将组的名称更改为 name（安全）</p>
<p>-g gid 将组 ID 更改为 gid（危险）</p>
<hr>
<h2 id="主机信息"><a href="#主机信息" class="headerlink" title="主机信息"></a>主机信息</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>uname</td>
<td>显示系统基本信息</td>
</tr>
<tr>
<td>hostname</td>
<td>显示系统的主机名</td>
</tr>
<tr>
<td>domainname</td>
<td>相当于 hostname -y</td>
</tr>
<tr>
<td>ip</td>
<td>设置和显示网络接口信息</td>
</tr>
<tr>
<td>ifconfig</td>
<td>设置和显示网络接口信息</td>
</tr>
</tbody></table>
<hr>
<h2 id="uname"><a href="#uname" class="headerlink" title="uname"></a>uname</h2><p>格式：<code>uname [options]</code></p>
<p>作用：显示计算机的基本信息</p>
<p>常用选项：</p>
<p>-a 所有信息</p>
<p>-s 只显示内核名称（默认）</p>
<p>-n 只显示主机名，与 hostname 命令一样</p>
<p>-r 只显示内核发行版</p>
<p>-v 只显示内核版本</p>
<p>-m 只显示硬件名称</p>
<p>-p 只显示处理器类型</p>
<p>-i 只显示硬件平台</p>
<p>-o 只显示操作系统名称</p>
<hr>
<h2 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a>hostname</h2><p>格式：<code>hostname [options] [name]</code></p>
<p>作用：显示计算机的名称。根据你的设置情况，该命令可能会显示完整或简略的主机名；也可以以 root 身份设置你的主机名</p>
<p>常用选项：</p>
<p>-i 显示主机的 IP 地址</p>
<p>-a 显示主机的别名</p>
<p>-s 显示短主机名称</p>
<p>-f 显示你的主机的全域名</p>
<p>-d 显示主机的 DNS 域名</p>
<p>-y 显示主机的 NIS 或 YP 域名</p>
<p>-F hostfile 设置你的主机名，并且该名称是从 hostfile 文件中读取的</p>
<hr>
<h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h2><p>格式：<code>ip [options] object command ...</code></p>
<p>作用：显示和设置计算机网络接口的相关参数</p>
<p>常用命令：</p>
<p>获取默认网络接口（通常称为 eth0）的有关信息：</p>
<p><code>ip addr show eth0</code></p>
<p>查看所有已经加载的网络接口：</p>
<p><code>ip addr show</code></p>
<p>查看帮助信息：</p>
<p><code>ip help</code></p>
<p>显示网络设备的 IP 地址：</p>
<p><code>ip addr</code></p>
<p>显示网络设备的组播地址：</p>
<p><code>ip maddr</code></p>
<p>显示网络设备的属性：</p>
<p><code>ip link</code></p>
<p>显示路由表：</p>
<p><code>ip route</code></p>
<p>开始监控网络设备，输入 Ctrl+C 停止监控：</p>
<p><code>ip monitor</code></p>
<p>注：这些命令都有多个选项，在相应的命令后面添加 help，可以查看相应的用法。此外，ip 可以在超级用户权限下面修改网络：配置网络设备、管理路由表和规则、创建隧道等。实际上，它是名为 iproute2 的工具集的一部分</p>
<hr>
<h2 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h2><p>格式：<code>ifconfig [options] interface</code></p>
<p>作用：设置和显示网络接口的信息</p>
<p>常用命令：</p>
<p><code>ifconfig eth0</code> 显示默认网络接口（通常为 eth0）的信息</p>
<p><code>ifconfig -a</code> 查看所有已经加载的网络接口</p>
<hr>
<h2 id="主机位置"><a href="#主机位置" class="headerlink" title="主机位置"></a>主机位置</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>host</td>
<td>查找主机名、IP 地址和 DNS 信息</td>
</tr>
<tr>
<td>whois</td>
<td>查找互联网域名注册者</td>
</tr>
<tr>
<td>ping</td>
<td>检查远程主机是否可达</td>
</tr>
<tr>
<td>traceroute</td>
<td>查看到远程主机的网络路径</td>
</tr>
</tbody></table>
<hr>
<h2 id="host"><a href="#host" class="headerlink" title="host"></a>host</h2><p>格式：<code>host [options] name [server]</code></p>
<p>作用：通过查询 DNS 来查找远程机器的主机名或 IP 地址</p>
<p>常用选项：</p>
<p>-a 显示所有可用信息</p>
<p>-t 选择名称服务器查询的类型：A、AXFR、CNAME、HINFO、KEY、MX、NS、PTR、SIG、SOA 等</p>
<hr>
<h2 id="whois"><a href="#whois" class="headerlink" title="whois"></a>whois</h2><p>格式：<code>whois [options] domain_name</code></p>
<p>作用：查找 Internet 域名的注册信息</p>
<p>常用选项：</p>
<p>-h registrar 在给定的注册商服务器上进行查找</p>
<p>-p port 查询给定的 TCP 端口而非默认端口 43（whois 服务）</p>
<hr>
<h2 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h2><p>格式：<code>ping [options] host</code></p>
<p>作用：确认远程主机是否处于可访问状态。它会向远程主机发送一些小数据包（即 ICMP 数据包），并等待响应</p>
<p>常用选项：</p>
<p>-c N 最多 ping N 次</p>
<p>-i N 每隔 N 秒 ping 一次（默认为 1）</p>
<p>-n 在输出中显示 IP 地址，而非主机名</p>
<hr>
<h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h2><p>格式：<code>traceroute [options] host [packet_length]</code></p>
<p>作用：输出从本地主机到远程主机的网络路径，以及数据包通过该路径所需的时间</p>
<p>注：该命令会向路径中的每个主机发送三个探测数据包，并报告返回时间。如果五秒内没有收到对方的响应，traceroute 会显示一个星号。此外，traceroute 可能被防火墙阻止或由于其他原因而无法进行，在这种情况下，它会显示相应的符号：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>!F</td>
<td>需要分片</td>
</tr>
<tr>
<td>!H</td>
<td>主机不可达</td>
</tr>
<tr>
<td>!N</td>
<td>网络不可达</td>
</tr>
<tr>
<td>!P</td>
<td>协议不可达</td>
</tr>
<tr>
<td>!S</td>
<td>源路由失败</td>
</tr>
<tr>
<td>!X</td>
<td>通信出于管理的需要而被禁止</td>
</tr>
<tr>
<td>!N</td>
<td>ICMP 不可达代码 N</td>
</tr>
</tbody></table>
<p>默认数据包大小为 40 字节，但你可以通过可选参数 packet_length 来进行修改</p>
<p>常用选项：</p>
<p>-n 数字模式：显示 IP 地址而不是主机名</p>
<p>-w N 将超时从 5 秒改为 N 秒</p>
<hr>
<h2 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ssh</td>
<td>安全地登录到远程主机，或在其上运行命令</td>
</tr>
<tr>
<td>scp</td>
<td>安全地将文件复制到远程主机中（批处理方式）</td>
</tr>
<tr>
<td>sftp</td>
<td>安全地将文件复制到远程主机，或者从远程主机安全地复制文件到本地主机（交互方式）</td>
</tr>
<tr>
<td>ftp</td>
<td>将文件复制到远程主机，或者从远程主机安全地复制文件到本地主机（交互式，不安全）</td>
</tr>
<tr>
<td>netcat</td>
<td>创建任意网络连接</td>
</tr>
</tbody></table>
<hr>
<h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>格式：<code>ssh [options] host [command]</code></p>
<p>作用：如果你在某远程机器上面拥有相应的帐户的话，可以通过 ssh 程序来进行安全的远程登录，或是调用远程机器上的程序而无需登录。ssh 会加密通过其连接进行传输的所有数据，包括你的用户名和密码（这是你需要访问远程计算机所需的）。SSH 协议还支持其他方式进行身份验证，例如公钥和主机 ID</p>
<p>常用选项：</p>
<p>-l user 指定你的远程用户名，否则，ssh 将默认使用你的本地用户名。你还可以使用 username@host 语法：<code>ssh wayne@server.example.com</code></p>
<p>-p port 使用非默认端口号（默认端口号为 22）</p>
<p>-t 在远程系统上分配 tty，这在尝试使用交互式用户界面（如文本编辑器）运行远程命令时很有用</p>
<p>-v 产生详细的输出，这就调试很有用</p>
<hr>
<h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><p>格式：<code>scp local_spec remote_spec</code></p>
<p>作用：将文件和目录从一台计算机批量复制到另一台计算机，它会对两台机器之间的所有通信进行加密处理</p>
<p>命令示例：</p>
<p>将本地文件复制到远程机器：</p>
<p><code>scp myfile remote.example.com:newfile</code></p>
<p>将目录复制到远程机器：</p>
<p><code>scp -r mydir remote.example.com:</code></p>
<p>将远程文件复制到本地计算机：</p>
<p><code>scp remote.example.com:myfile .</code></p>
<p>将远程目录复制到本地计算机：</p>
<p><code>scp -r remote.example.com:mydir .</code></p>
<p>要指定远程系统上的用户名，请使用 username@host 语法：</p>
<p><code>scp myfile wayne@remote.example.com:</code></p>
<p>常用选项：</p>
<p>-p 复制所有的文件属性（权限、时间戳）</p>
<p>-r 递归复制目录及其内容</p>
<p>-v 产生详细的输出，该选项对调试非常有用</p>
<hr>
<h2 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h2><p>格式：<code>sftp (host username@host)</code></p>
<p>作用：在两台计算机之间以交互方式安全地通过批量方式复制文件</p>
<p>注：如果你在远程系统上的用户名与本地用户名不同的话，则需要使用 username@host 参数</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>help</td>
<td>查看可用的命令</td>
</tr>
<tr>
<td>ls</td>
<td>列出当前远程目录中的文件</td>
</tr>
<tr>
<td>lls</td>
<td>列出当前本地目录中的文件</td>
</tr>
<tr>
<td>pwd</td>
<td>显示远程工作目录</td>
</tr>
<tr>
<td>lpwd</td>
<td>显示本地工作目录</td>
</tr>
<tr>
<td>cd dir</td>
<td>将远程目录更改为 dir</td>
</tr>
<tr>
<td>lcd dir</td>
<td>将本地目录更改为 dir</td>
</tr>
<tr>
<td>get file1 [file2]</td>
<td>将远程 file1 复制到本地机器，并将重新命名为 file2（可选）</td>
</tr>
<tr>
<td>put file1 [file2]</td>
<td>将本地 file1 复制到远程机器，并将重新命名为 file2（可选）</td>
</tr>
<tr>
<td>mget file *</td>
<td>使用通配符*和?将多个远程文件复制到本地计算机</td>
</tr>
<tr>
<td>mput file *</td>
<td>使用通配符*和?将多个本地文件复制到远程计算机</td>
</tr>
<tr>
<td>quit</td>
<td>退出 sftp</td>
</tr>
</tbody></table>
<hr>
<h2 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h2><p>格式：<code>ftp [options] host</code></p>
<p>作用：在计算机之间复制文件，无法以安全的方式复制文件，用户名和密码是以纯文本形式在网络中传播的</p>
<hr>
<h2 id="netcat"><a href="#netcat" class="headerlink" title="netcat"></a>netcat</h2><p>格式：<code>netcat [options] [destination] [port]</code>，<code>nc [options] [destination] [port]</code></p>
<p>作用：netcat 或 nc 都是用于进行网络连接的通用工具，该工具不仅可以用来调试、了解网络，同时还有许多其他用途</p>
<p>常用选项：</p>
<p>-u 建立 UDP 连接而不是 TCP 连接</p>
<p>-l 侦听给定端口上的连接</p>
<p>-p N 使用端口 N 作为源端口</p>
<p>-w N N 秒后超时</p>
<p>-h 获取帮助信息</p>
<hr>
<h2 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>mutt</td>
<td>基于文本的邮件客户端</td>
</tr>
<tr>
<td>mail</td>
<td>基于文本的迷你邮件客户端</td>
</tr>
<tr>
<td>mailq</td>
<td>查看系统上的外发邮件队列</td>
</tr>
</tbody></table>
<hr>
<h2 id="mutt"><a href="#mutt" class="headerlink" title="mutt"></a>mutt</h2><p>格式：<code>mutt [options]</code></p>
<p>作用：mutt 是一个基于文本的邮件程序，能够在普通终端（或终端窗口）中运行，因此可以在本地（例如，X 终端窗口）中使用或通过 SSH 连接远程使用</p>
<hr>
<h2 id="mail"><a href="#mail" class="headerlink" title="mail"></a>mail</h2><p>格式：<code>mail [options] recipient</code></p>
<p>作用：mail 程序是一个快速、简单的电子邮件客户端，利用命令行或脚本来快速处理邮件</p>
<p>常用选项：</p>
<p>-s subject 设置邮件的主题行</p>
<p>-v 冗长模式，显示邮件传递的相关信息</p>
<p>-c address 指定邮件副本的收信人地址（以逗号分隔的列表）</p>
<p>-b address 指定密件副本的收信人地址（以逗号分隔的列表）</p>
<hr>
<h2 id="mailq"><a href="#mailq" class="headerlink" title="mailq"></a>mailq</h2><p>格式：<code>mailq</code></p>
<p>作用：列出所有等待发送的外发电子邮件，发送的邮件将记录在日志文件中</p>
<hr>
<h2 id="网页浏览"><a href="#网页浏览" class="headerlink" title="网页浏览"></a>网页浏览</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>lynx</td>
<td>纯文本的网页浏览器</td>
</tr>
<tr>
<td>wget</td>
<td>下载网页和文件</td>
</tr>
</tbody></table>
<hr>
<h2 id="lynx"><a href="#lynx" class="headerlink" title="lynx"></a>lynx</h2><p>格式：<code>lynx [options] [URL]</code></p>
<p>作用：lynx 是一个精简的纯文本网页浏览器，由于太过精简，因此无法显示图片、播放音频或视频，甚至无法响应鼠标。但是，当你只需要快速浏览页面，或网络速度慢或下载网站的 HTML 时，这种精简特性却是非常有用的。此外，它特别适合检测可疑网址，因为 lynx 不运行 JavaScript，甚至在未经允许的情况下都不会接受 cookie。所有浏览活动都是通过键盘完成的。有时候，浏览的效果不太完美，特别是浏览大量使用表格或框架的页面的时候，不过，浏览网站的概貌还是没问题的</p>
<p>常用选项：</p>
<p>-dump 将渲染的页面打印到标准输出并退出（类似于-source 选项）</p>
<p>-source 将 HTML 源代码打印到标准输出并退出（类似于 wget 命令）</p>
<p>-emacskeys 让 lynx 使用 emacs 编辑器的按键指令</p>
<p>-vikeys 让 lynx 使用 vim（或 vi）编辑器的按键指令</p>
<p>-homepage&#x3D;URL 将你的主页网址设置为 URL</p>
<p>-color 打开彩色文字模式</p>
<p>-nocolor 关闭彩色文字模式</p>
<hr>
<h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p>格式：<code>wget [options] URL</code></p>
<p>作用：打开 URL 并将数据下载到文件或标准输出</p>
<p>注：与之类似的一个命令是 curl，它默认情况下会将相应内容写入标准输出，这与 wget 不同，wget 默认情况下会复制原始页面和文件名</p>
<p>常用选项：</p>
<p>-i filename 从指定的文件读取 URL 并依次检索它们</p>
<p>-O filename 将所有捕捉到的 HTML 写入给定的文件夹，逐页追加</p>
<p>-c 续传模式：如果之前的下载被中断，只剩下部分内容，那么 wget 将从上次中断的地方开始下载。也就是说，如果内容 150K，上次已经下载了 100K，那么使用-c 选项后，就只下载剩下的 50K，然后把它添加到已经下载的内容后面即可。不过，有时候 wget 可能会“被耍”，例如从上次进行了（部分）下载之后，文件已经发生变化，所以，只有确保远程文件没有发生变化时，才能使用这个选项</p>
<p>-t N 尝试 N 次，然后放弃。N&#x3D;0 表示不停尝试下去</p>
<p>–progress&#x3D;dot 通过点号来显示下载进度</p>
<p>–progress&#x3D;bar 通过条型来显示下载进度</p>
<p>–spider 不下载，只是检查远程页面是否存在</p>
<p>-nd 将所有的文件下载到当前目录中，即使它们原先位于一个非常复杂的目录树中（默认情况下，wget 会按照原样来复制远程目录的层次结构）</p>
<p>-r 递归下载页面层次结构，包括子目录</p>
<p>-l N 在最多下载 N 层内的文件（默认为 5）</p>
<p>-k 内部检索的文件，修改 URL，以便可以在网络浏览器中查看文件</p>
<p>-p 下载完整显示页面所需的所有文件，如样式表和图像文件等</p>
<p>-L 下载（页面内的）相对链接，但不下载绝对链接</p>
<p>-A pattern 接受模式：仅下载名称与给定模式匹配的文件。模式可以使用 shell 通配符</p>
<p>-R pattern 拒绝模式：仅下载名称与给定模式不匹配的文件</p>
<p>-I pattern 目录包含：仅从匹配给定模式的目录中下载文件</p>
<p>-X pattern 目录排除：仅从不符合给定模式的目录中下载文件</p>
<hr>
<h2 id="即时通信"><a href="#即时通信" class="headerlink" title="即时通信"></a>即时通信</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>write</td>
<td>向终端发送消息</td>
</tr>
<tr>
<td>mesg</td>
<td>设置当前终端的写权限，即是否让其他用户向本终端发消息</td>
</tr>
<tr>
<td>tty</td>
<td>显示终端设备名称</td>
</tr>
<tr>
<td>sendxmpp</td>
<td>通过 XMPP（Jabber）发送即时消息</td>
</tr>
<tr>
<td>profanity</td>
<td>基于文本的 XMPP 客户端</td>
</tr>
<tr>
<td>irssi</td>
<td>基于文本的 IRC 客户端</td>
</tr>
</tbody></table>
<hr>
<h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><p>格式：<code>write user [tty]</code></p>
<p>作用：向同一台机器上的其他用户发送多行文本，Ctrl+D 组合键用于结束连接。也可以在管道中发送一次性消息</p>
<p>注：与 write 命令功能比较接近的一个命令是 wall，它能同时向所有登录用户发送消息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wall The system will reboot in 1 hour</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="mesg"><a href="#mesg" class="headerlink" title="mesg"></a>mesg</h2><p>格式：<code>mesg [y|n]</code></p>
<p>作用：决定是否可以向终端写入内容。mesg y 表示允许写入，mesg n 表示拒绝写入，而 mesg 则会显示当前状态（y 或 n），其中 y 是默认值。mesg 对现代即时通信程序无效</p>
<hr>
<h2 id="tty"><a href="#tty" class="headerlink" title="tty"></a>tty</h2><p>格式：<code>tty</code></p>
<p>作用：显示与当前 shell 相关联的终端设备名称（如果收件人多次登录，write 命令可能需要这些信息）</p>
<hr>
<h2 id="sendxmpp"><a href="#sendxmpp" class="headerlink" title="sendxmpp"></a>sendxmpp</h2><p>格式：<code>sendxmpp [options] recipients</code></p>
<p>作用：通过 XMPP 协议（Jabber）发送即时消息的快速方式。当你只想发送单个消息或文本文件的内容，而无需接收消息的时候，这个程序是非常方便的</p>
<p>常用选项：</p>
<p>-t 使用 TLS 来保护连接</p>
<p>-e 使用 SSL 来保护连接</p>
<p>-s text 随消息一起发送主题行</p>
<p>-v 冗长模式：显示调试信息。如果当连接失败的时候，该选项将非常有用</p>
<hr>
<h2 id="profanity"><a href="#profanity" class="headerlink" title="profanity"></a>profanity</h2><p>格式：<code>profanity [options]</code></p>
<p>作用：用于 XMPP 协议（Jabber）的一款全功能即时通信客户端。与图形客户端不同，profanity 是在 shell 窗口中运行的，因此你可以通过 SSH 来使用该客户端</p>
<hr>
<h2 id="irssi"><a href="#irssi" class="headerlink" title="irssi"></a>irssi</h2><p>格式：<code>irssi [options]</code></p>
<p>作用：功能齐全的基于文本的 IRC 客户端</p>
<hr>
<h2 id="屏幕输出"><a href="#屏幕输出" class="headerlink" title="屏幕输出"></a>屏幕输出</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>echo</td>
<td>在标准输出上显示简单文本</td>
</tr>
<tr>
<td>printf</td>
<td>在标准输出上显示格式化文本</td>
</tr>
<tr>
<td>yes</td>
<td>在标准输出上显示重复文字</td>
</tr>
<tr>
<td>seq</td>
<td>在标准输出上显示一个数字序列</td>
</tr>
<tr>
<td>clear</td>
<td>清除屏幕或窗口</td>
</tr>
</tbody></table>
<hr>
<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>格式：<code>echo [options] strings</code></p>
<p>作用：显示其参数</p>
<p>常用选项：</p>
<p>-n 不要打印最后面的换行符</p>
<p>-e 识别并解释转义字符</p>
<p>-E 不解释转义字符：与-e 选项的作用相反</p>
<p>可用的转义字符包括：</p>
<p>\a 警报（发出哔声）</p>
<p>\b 退格</p>
<p>\c 不打印最后面的换行符（与-n 选项的作用相同）</p>
<p>\f 换页</p>
<p>\n 换行</p>
<p>\r 回车</p>
<p>\t 水平制表符</p>
<p>\v 垂直制表符</p>
<p><code>\\</code> 反斜杠</p>
<p><code>\&#39;</code> 单引号</p>
<p><code>\&quot;</code> 双引号</p>
<p>\nnn 插入 nnn（八进制）所代表的 ASCII 字符</p>
<hr>
<h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><p>格式：<code>printf format_string [arguments]</code></p>
<p>作用：增强版的 echo 命令，能够在标准输出上显示格式化的字符串，类似于 C 语言的 printf()函数，将一个格式字符串应用于参数序列以创建指定的输出</p>
<hr>
<h2 id="yes"><a href="#yes" class="headerlink" title="yes"></a>yes</h2><p>格式：<code>yes [string]</code></p>
<p>作用：重复打印指定的字符串（或默认为“y”），并且每个字符串占一行</p>
<hr>
<h2 id="seq"><a href="#seq" class="headerlink" title="seq"></a>seq</h2><p>格式：<code>seq [options] specification</code></p>
<p>作用：输出一系列整数或实数，适用于其他程序的管道。它有三种规格参数：一个数字：上限，两个数字：下限和上限，三个数字：下限，增量和上限</p>
<p>常用选项：</p>
<p>-w 根据需要打印前导零，以使所有行的宽度相同</p>
<p>-f format 使用类似 printf 的格式字符串来格式化输出行，该字符串必须包含%g（默认值）、%e 或%f</p>
<p>-s string 使用给定的字符串作为数字之间的分隔符。在默认情况下，会打印换行符（即每行一个数字）</p>
<hr>
<h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>格式：<code>clear</code></p>
<p>作用：清除显示器或 shell 窗口中的内容</p>
<hr>
<h2 id="复制和粘贴"><a href="#复制和粘贴" class="headerlink" title="复制和粘贴"></a>复制和粘贴</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>xclip</td>
<td>在 shell 和剪切板之间进行复制并粘贴操作</td>
</tr>
<tr>
<td>xsel</td>
<td>通过 shell 来操作剪切板</td>
</tr>
</tbody></table>
<hr>
<h2 id="xclip"><a href="#xclip" class="headerlink" title="xclip"></a>xclip</h2><p>格式：<code>xclip [options]</code></p>
<p>作用：可以对三个 Linux 选择（剪切板）命令进行读取和写入操作，从而实现在 shell 和图形应用程序之间复制和粘贴文本</p>
<p>常用选项：</p>
<p>-selection name 通过名称，从 primary、secondary 或 clipboard 中指定一个选择命令。默认情况下，将会选取 primary 命令</p>
<p>-i 从标准输入中读取选择命令中的内容，该选项可省略</p>
<p>-o 将选择命令中的内容写入标准输出</p>
<hr>
<h2 id="xsel"><a href="#xsel" class="headerlink" title="xsel"></a>xsel</h2><p>格式：<code>xsel [options]</code></p>
<p>作用：xsel 是 xclip 的增强版本，它除了能够读写三个选择（剪切板）命令中的内容之外，还支持附加、交换和清除操作</p>
<p>常用选项：</p>
<p>-p 使用 primary 命令（默认）</p>
<p>-s 使用 secondary 命令</p>
<p>-b 使用 clipboard 命令</p>
<p>-i 选择命令从标准输入读取相应的内容，这是默认的行为</p>
<p>-a 附加到选择命令中</p>
<p>-o 将选择命令的内容写入标准输出</p>
<p>-c 清除选择命令中的内容</p>
<p>-x 交换 primary 和 secondary 命令中的内容</p>
<hr>
<h2 id="数学和计算"><a href="#数学和计算" class="headerlink" title="数学和计算"></a>数学和计算</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>expr</td>
<td>在命令行进行简单的数学运算</td>
</tr>
<tr>
<td>bc</td>
<td>基于文本的计算器</td>
</tr>
<tr>
<td>dc</td>
<td>基于文本的 RPN 计算器</td>
</tr>
</tbody></table>
<hr>
<h2 id="expr"><a href="#expr" class="headerlink" title="expr"></a>expr</h2><p>格式：<code>expr expression</code></p>
<p>作用：在命令行中执行简单的数学（和其他表达式求值）运算</p>
<hr>
<h2 id="bc"><a href="#bc" class="headerlink" title="bc"></a>bc</h2><p>格式：<code>bc [options] [files]</code></p>
<p>作用：读取算术表达式，每行一个，并显示结果</p>
<hr>
<h2 id="dc"><a href="#dc" class="headerlink" title="dc"></a>dc</h2><p>格式：<code>dc [options] [files]</code></p>
<p>作用：从标准输入读取表达式，并将结果写入标准输出，它是一个使用逆波兰表示法（RPN）、基于堆栈的计算器</p>
<hr>
<h2 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cal</td>
<td>显示当前日历</td>
</tr>
<tr>
<td>date</td>
<td>显示或设置日期和时间</td>
</tr>
<tr>
<td>ntpdate</td>
<td>使用远程时间服务器设置系统时间</td>
</tr>
</tbody></table>
<hr>
<h2 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h2><p>格式：<code>cal [options][month [year]]</code></p>
<p>作用：显示日历。默认情况下，它会显示当前月份的日历；要想显示当前月份之外的日历的话，请提供相应的月份和年份（用四位数字表示）。如果省略具体的月份，那么该命令就会显示整年的日历</p>
<p>常用选项：</p>
<p>-y 显示当前年份的日历</p>
<p>-3 显示三个月的日历：包括前一个月和下一个月的日历</p>
<p>-j 显示某一日位于当年中的第几天</p>
<hr>
<h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><p>格式：<code>date [options] [format]</code></p>
<p>作用：显示日期和时间，该命令的输出结果将取决于系统的区域设置，在默认情况下，date 将显示本地时区的系统日期和时间。可以通过提供以加号开头的格式字符串来格式化输出内容</p>
<p>常用选项：</p>
<p>-d string 显示给定的日期或时间 string，并按照你的要求进行格式化</p>
<p>-r filename 显示给定图像的最后修改时间戳，并按照你的要求进行格式化</p>
<p>-s string 将系统日期和&#x2F;或时间设置为 string，只有超级用户才能执行该操作</p>
<hr>
<h2 id="ntpdate"><a href="#ntpdate" class="headerlink" title="ntpdate"></a>ntpdate</h2><p>格式：<code>ntpdate timeserver</code></p>
<p>作用：通过访问网络上的时间服务器来设置当前系统时间，需要 root 权限</p>
<hr>
<h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>display</td>
<td>显示图像文件</td>
</tr>
<tr>
<td>convert</td>
<td>将文件从一种图形格式转换为另一种格式</td>
</tr>
<tr>
<td>mogrify</td>
<td>修改图形文件</td>
</tr>
<tr>
<td>montage</td>
<td>将多个图形文件组合成一个文件</td>
</tr>
</tbody></table>
<hr>
<h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><p>格式：<code>display [options] files</code></p>
<p>作用：显示多种格式的图像文件</p>
<p>常用选项：</p>
<p>-resize size 调整图像的大小。size 的设置方式非常灵活，包括设置宽度（800），高度（x600），高度乘以宽度（800x600），缩放百分比（50%），像素面积（480000@）等</p>
<p>-flip 垂直反转图像</p>
<p>-flop 水平反转图像</p>
<p>-rotate N 将图像旋转 N 度</p>
<p>-backdrop 在纯色背景（该颜色将铺满图像之外的整个屏幕）下显示图像</p>
<p>-fill 设置-backdrop 选项使用的纯色</p>
<p>-delay N 显示图像 N 秒，然后退出。如果列出多幅图像的话，以幻灯片形式播放，延迟时间为 N 秒</p>
<p>-identify 将图像的格式、大小和其他统计信息打印到标准输出</p>
<hr>
<h2 id="convert"><a href="#convert" class="headerlink" title="convert"></a>convert</h2><p>格式：<code>convert [input_options] infile [output_options] outfile</code></p>
<p>作用：复制图像，同时将其转换为不同的图形格式。同时，可以对图像的副本进行修改</p>
<p>注：该命令的选项与 display 命令大部分保持一致</p>
<hr>
<h2 id="mogrify"><a href="#mogrify" class="headerlink" title="mogrify"></a>mogrify</h2><p>格式：<code>mogrify [options] file</code></p>
<p>作用：像 convert 命令那样对图像进行转换，不过该命令的转换操作是直接针对原图像文件，而不是通过副本来完成的（所以 convert 是一个更加安全的命令）。该命令能支持 convert 命令的大部分选项</p>
<hr>
<h2 id="montage"><a href="#montage" class="headerlink" title="montage"></a>montage</h2><p>格式：<code>montage infiles [options] outfile</code></p>
<p>作用：将一组输入文件组合到单个图像文件中，该命令在图像的显示方式方面具有非常强大的控制能力</p>
<p>常用选项：</p>
<p>-geometry widthxheight[+-]x[+-]y 设置图像的高度宽度和偏移（x，y）</p>
<p>-frame N 在每个图像周围绘制宽度为 N 个像素的框</p>
<p>-label string 使用字符串来标注各个图像，其中可以包括以百分号开头的特殊转义字符：%f 表示原始文件名，%h 和%w 表示高度和宽度，%m 表示文件格式等</p>
<hr>
<h2 id="音频和视频"><a href="#音频和视频" class="headerlink" title="音频和视频"></a>音频和视频</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cdparanoia</td>
<td>将 CD 音轨转换（也就是”提取“）成 WAV 文件</td>
</tr>
<tr>
<td>lame</td>
<td>将 WAV 文件转换为 MP3 文件</td>
</tr>
<tr>
<td>id3info</td>
<td>查看 MP3 文件中的 ID3 标签</td>
</tr>
<tr>
<td>id3tag</td>
<td>编辑 MP3 文件中的 ID3 标签</td>
</tr>
<tr>
<td>ogginfo</td>
<td>查看 OGG 的信息</td>
</tr>
<tr>
<td>metaflac</td>
<td>查看和编辑 FLAC 文件的信息</td>
</tr>
<tr>
<td>sox</td>
<td>在各种音频流格式之间进行转换</td>
</tr>
<tr>
<td>mplayer</td>
<td>播放视频或音频</td>
</tr>
</tbody></table>
<hr>
<h2 id="cdparanoia"><a href="#cdparanoia" class="headerlink" title="cdparanoia"></a>cdparanoia</h2><p>格式：<code>cdparanoia [options] span [outfile]</code></p>
<p>作用：从 CD 读取（提取）音频数据，并将其存储到 WAV 文件（或其他格式）</p>
<p>常见用法：</p>
<p><code>cdparanoia N</code> 将 N 音轨转换为一个文件</p>
<p><code>cdparanoia -B</code> 将 CD 上的所有音轨都转换为单独的文件</p>
<p><code>cdparanoia -B 2-4</code> 将 2、3 和 4 音轨转换为单独的文件</p>
<p><code>cdparanoia 2-4</code> 将 2、3 和 4 音轨转换为单个文件</p>
<p>注：如果访问驱动器遇到困难，可以尝试运行<code>cdparanoia -Qvs</code>命令来查找相关线索</p>
<hr>
<h2 id="lame"><a href="#lame" class="headerlink" title="lame"></a>lame</h2><p>格式：<code>lame [options] file.wav</code></p>
<p>作用：将 WAV 音频文件转换为 MP3 文件</p>
<hr>
<h2 id="id3info"><a href="#id3info" class="headerlink" title="id3info"></a>id3info</h2><p>格式：<code>id3info [options] [files]</code></p>
<p>作用：显示 MP3 音频文件的相关信息，前提是文件中含有 ID3 标签</p>
<hr>
<h2 id="id3tag"><a href="#id3tag" class="headerlink" title="id3tag"></a>id3tag</h2><p>格式：<code>id3tag [options] files</code></p>
<p>作用：添加或修改 MP3 文件中的 ID3 标签</p>
<p>常用选项：</p>
<p>-A name 设置艺术家的名字</p>
<p>-a title 设置专辑标题</p>
<p>-s title 设置歌曲标题</p>
<p>-y year 设置年份</p>
<p>-t number 设置音轨数</p>
<p>-g number 设置流派码</p>
<hr>
<h2 id="ogginfo"><a href="#ogginfo" class="headerlink" title="ogginfo"></a>ogginfo</h2><p>格式：<code>ogginfo [options] [files]</code></p>
<p>作用：显示 OGG Vorbis 音频文件的各种信息，添加-h 选项可以获取更详细的用法说明信息</p>
<hr>
<h2 id="metaflac"><a href="#metaflac" class="headerlink" title="metaflac"></a>metaflac</h2><p>格式：<code>metaflac [options] [files]</code></p>
<p>作用：显示或更改 FLAC 音频文件的信息</p>
<p>常用选项：</p>
<p>–show-tag name 显示给定标签的值</p>
<p>–remove-tag name 从 FLAC 文件中删除所有给定的标签</p>
<hr>
<h2 id="sox"><a href="#sox" class="headerlink" title="sox"></a>sox</h2><p>格式：<code>sox [options] infile outfile</code></p>
<p>作用：音频文件格式转换</p>
<p>常用选项：</p>
<p>-S 显示进度表，适用于长时间的格式转换情形</p>
<p>–no-clobber 如果输出的文件已经存在，则不覆盖原来的文件</p>
<p>-t type 指定输入的类型，如果 sox 无法识别的话</p>
<hr>
<h2 id="mplayer"><a href="#mplayer" class="headerlink" title="mplayer"></a>mplayer</h2><p>格式：<code>mplayer [options] video_files ... </code></p>
<p>作用：播放视频或音频文件</p>
<hr>
<p><em>Wayne.Chen</em></p>
<p><em>整理于 2018 年 11 月 8 日下午</em></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程基础 1 —字节序转换/IP地址转换</title>
    <url>/2022/02/11/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h1 id="网络编程基础—字节序转换-x2F-IP地址转换"><a href="#网络编程基础—字节序转换-x2F-IP地址转换" class="headerlink" title="网络编程基础—字节序转换&#x2F;IP地址转换"></a>网络编程基础—字节序转换&#x2F;IP地址转换</h1><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><blockquote>
<p>现代 CPU 的累加器一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。那么这 4字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。在各种计算机体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。</p>
</blockquote>
<p><strong>字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)。字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。</strong></p>
<p><strong>大端字节序</strong>是指一个整数的最高位字节（23 ~ 31 bit）存储在内存的低地址处，低位字节（0 ~ 7 bit）存储在内存的高地址处；</p>
<p><strong>小端字节序</strong>则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。</p>
<h3 id="字节序举例"><a href="#字节序举例" class="headerlink" title="字节序举例"></a>字节序举例</h3><h4 id="小端字节序"><a href="#小端字节序" class="headerlink" title="小端字节序"></a>小端字节序</h4><p>0x 01 02 03 04 - ff &#x3D; 255<br>内存的方向 —–&gt;<br>内存的低位 —–&gt; 内存的高位<br>04 03 02 01<br>0x 11 22 33 44 12 34 56 78</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232425.png" alt="image-20220315222426814"></p>
<h4 id="大端字节序"><a href="#大端字节序" class="headerlink" title="大端字节序"></a>大端字节序</h4><p>0x 01 02 03 04<br>内存的方向 —–&gt;<br>内存的低位 —–&gt; 内存的高位<br>01 02 03 04<br>0x 12 34 56 78 11 22 33 44</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220315232426.png" alt="image-20220315222517483"></p>
<h2 id="字节序转换函数"><a href="#字节序转换函数" class="headerlink" title="字节序转换函数"></a>字节序转换函数</h2><p>当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的方法是：发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。</p>
<p>网络字节顺序是 TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释，<strong>网络字节顺序采用大端排序方式</strong>。BSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数：htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">h - host 主机，主机字节序</span><br><span class="line">to - 转换成什么</span><br><span class="line">n - network 网络字节序</span><br><span class="line">    </span><br><span class="line">s - <span class="type">short</span> <span class="type">unsigned</span> <span class="type">short</span>（端口号占<span class="number">16b</span>its，<span class="number">2</span>字节）</span><br><span class="line">l - <span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span>（ip地址占<span class="number">32b</span>its，<span class="number">4</span>字节）</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 转换端口</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="comment">// 转IP</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br></pre></td></tr></table></figure>



<p>1.hotns</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// htons 转换端口</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> a = <span class="number">0x0102</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;a : %x\n&quot;</span>, a);  </span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> b = htons(a);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;b : %x\n&quot;</span>, b);</span><br><span class="line"><span class="comment">//输出：a : 102</span></span><br><span class="line"><span class="comment">//     b : 201</span></span><br></pre></td></tr></table></figure>



<p>2、ntohs</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ntohs</span></span><br><span class="line"><span class="type">uint16_t</span> port1 = <span class="number">0x1234</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;port1 = %x \n&quot;</span> , port1);</span><br><span class="line"><span class="type">uint16_t</span> trans_port = ntohs(port1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;trans_port1 = %x \n&quot;</span> , trans_port);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=======================\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：3412</span></span><br></pre></td></tr></table></figure>



<p>3、htonl</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// htonl  转换IP</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">4</span>] = &#123;<span class="number">192</span>, <span class="number">168</span>, <span class="number">1</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num = *(<span class="type">int</span> *)buf;</span><br><span class="line">    <span class="type">int</span> sum = htonl(num);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p = (<span class="type">char</span> *)&amp;sum;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p, *(p+<span class="number">1</span>), *(p+<span class="number">2</span>), *(p+<span class="number">3</span>));</span><br><span class="line"><span class="comment">//输出 100 1 168 192</span></span><br></pre></td></tr></table></figure>



<p>4、ntohl</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// ntohl</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf1[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">168</span>, <span class="number">192</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num1 = *(<span class="type">int</span> *)buf1;</span><br><span class="line">    <span class="type">int</span> sum1 = ntohl(num1);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> *p1 = (<span class="type">unsigned</span> <span class="type">char</span> *)&amp;sum1;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, *p1, *(p1+<span class="number">1</span>), *(p1+<span class="number">2</span>), *(p1+<span class="number">3</span>));</span><br><span class="line"><span class="comment">//输出 192 168 1 1</span></span><br></pre></td></tr></table></figure>



<h2 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line">  <span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line">  <span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line">      af:地址族： AF_INET（TCP/IPv4协议族）  AF_INET6（TCP/IPv6议族）</span><br><span class="line">      src:需要转换的点分十进制的IP字符串</span><br><span class="line">      dst:转换后的结果保存在这个里面</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line">      af:地址族： AF_INET（TCP/IPv4协议族）  AF_INET6（TCP/IPv6议族）</span><br><span class="line">      src: 要转换的ip的整数的地址</span><br><span class="line">      dst: 转换成IP地址字符串保存的地方</span><br><span class="line">      size：第三个参数的大小（数组的大小）</span><br><span class="line">      返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>  1、 创建一个ip字符串,点分十进制的IP地址字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char *buf = &quot;192.168.1.4&quot;;</span><br><span class="line">unsigned int num = 0;</span><br></pre></td></tr></table></figure>

<p>2、将点分十进制的IP字符串转换成网络字节序的整数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inet_pton(AF_INET, buf, &amp;num);</span><br><span class="line">unsigned char * p = (unsigned char *)&amp;num;</span><br><span class="line">printf(&quot;%d %d %d %d\n&quot;, *p, *(p+1), *(p+2), *(p+3));</span><br></pre></td></tr></table></figure>

<p>3、将网络字节序的IP整数转换成点分十进制的IP字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char ip[16] = &quot;&quot;;</span><br><span class="line">const char * str =  inet_ntop(AF_INET, &amp;num, ip, 16);</span><br><span class="line">printf(&quot;str : %s\n&quot;, str);</span><br><span class="line">printf(&quot;ip : %s\n&quot;, str);</span><br><span class="line">printf(&quot;%d\n&quot;, ip == str);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>WebServer</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>computer network</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程基础 2 —socket地址</title>
    <url>/2022/02/15/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E2%80%94socket%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h1 id="网络编程基础—socket地址"><a href="#网络编程基础—socket地址" class="headerlink" title="网络编程基础—socket地址"></a>网络编程基础—socket地址</h1><p>socket地址其实是一个结构体，封装端口号和IP等信息。后面的socket相关的api中需要使用到这个socket地址。</p>
<h2 id="通用-socket-地址"><a href="#通用-socket-地址" class="headerlink" title="通用 socket 地址"></a>通用 socket 地址</h2><p>socket 网络编程接口中表示 socket 地址的是结构体 sockaddr，其定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sa_family;</span><br><span class="line"><span class="type">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure>

<p>sa_family 成员是地址族类型（sa_family_t）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称domain）和对应的地址族入下所示：</p>
<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220316212302.png" alt="image-20220316191720230" style="zoom:80%;">



<p><em>宏 PF_ * 和 AF_ * 都定义在 bits&#x2F;socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混用。</em></p>
<p>sa_data 成员用于存放 socket 地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下所示：</p>
<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220316212303.png" alt="image-20220316192107656" style="zoom:80%;">

<p>由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sa_family;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ss_align;</span><br><span class="line"><span class="type">char</span> __ss_padding[ <span class="number">128</span> - <span class="keyword">sizeof</span>(__ss_align) ];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></figure>

<h2 id="专用-socket-地址"><a href="#专用-socket-地址" class="headerlink" title="专用 socket 地址"></a>专用 socket 地址</h2><p>很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现在sockaddr 退化成了（void *）的作用，传递一个地址给函数，至于这个函数是 sockaddr_in 还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。</p>
<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220316212304.png" alt="image-20220316193534854" style="zoom:80%;">

<p>UNIX 本地域协议族使用如下专用的 socket 地址结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sin_family;</span><br><span class="line"><span class="type">char</span> sun_path[<span class="number">108</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>TCP&#x2F;IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和IPv6：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sin_family; <span class="comment">/* __SOCKADDR_COMMON(sin_) */</span></span><br><span class="line"><span class="type">in_port_t</span> sin_port; <span class="comment">/* Port number. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="keyword">sizeof</span> (<span class="keyword">struct</span> sockaddr) - __SOCKADDR_COMMON_SIZE -</span><br><span class="line"><span class="keyword">sizeof</span> (<span class="type">in_port_t</span>) - <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">in_addr_t</span> s_addr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">sa_family_t</span> sin6_family;</span><br><span class="line"><span class="type">in_port_t</span> sin6_port; <span class="comment">/* Transport layer port # */</span></span><br><span class="line"><span class="type">uint32_t</span> sin6_flowinfo; <span class="comment">/* IPv6 flow information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span> <span class="comment">/* IPv6 address */</span></span><br><span class="line"><span class="type">uint32_t</span> sin6_scope_id; <span class="comment">/* IPv6 scope-id */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">uint16_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint16_t</span> <span class="type">in_port_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">in_addr_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int)</span></span><br></pre></td></tr></table></figure>

<p>所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。</p>
]]></content>
      <categories>
        <category>WebServer</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>computer network</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程基础 3 —socket通信函数</title>
    <url>/2022/02/16/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80-%E2%80%94socket%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="socket通信函数"><a href="#socket通信函数" class="headerlink" title="socket通信函数"></a>socket通信函数</h1><h2 id="TCP通信流程"><a href="#TCP通信流程" class="headerlink" title="TCP通信流程"></a>TCP通信流程</h2><p>TCP 和 UDP 都是传输层的协议<br>UDP:用户数据报协议，面向无连接，可以单播，多播，广播， 面向数据报，不可靠<br>TCP:传输控制协议，面向连接的，可靠的，基于字节流，仅支持单播传输</p>
<p>两者主要区别如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否创建连接</td>
<td>无连接</td>
<td>无连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠</td>
<td>可靠</td>
</tr>
<tr>
<td>连接的对象个数</td>
<td>一对一、一对多、多对一、多对多</td>
<td>支持一对一</td>
</tr>
<tr>
<td>传输的方式</td>
<td>面向数据报</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>8个字节</td>
<td>最少20个字节</td>
</tr>
<tr>
<td>适用场景</td>
<td>实时应用（视频会议，直播）</td>
<td>可靠性高的应用（文件传输）</td>
</tr>
</tbody></table>
<p><strong>通信流程图</strong></p>
<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220316212318.png" alt="image-20220316202702180" style="zoom:80%;">

<h2 id="socket通信函数介绍"><a href="#socket通信函数介绍" class="headerlink" title="socket通信函数介绍"></a>socket通信函数介绍</h2><p>1.头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 包含了这个头文件，上面两个就可以省略</span></span></span><br></pre></td></tr></table></figure>

<p>2.socket()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line">- 功能：创建一个套接字</span><br><span class="line">- 参数：</span><br><span class="line">- domain: 协议族</span><br><span class="line">AF_INET : ipv4</span><br><span class="line">AF_INET6 : ipv6</span><br><span class="line">AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="line">- type: 通信过程中使用的协议类型</span><br><span class="line">SOCK_STREAM : 流式协议</span><br><span class="line">SOCK_DGRAM : 报式协议</span><br><span class="line">- protocol : 具体的一个协议。一般写<span class="number">0</span></span><br><span class="line">- SOCK_STREAM : 流式协议默认使用 TCP</span><br><span class="line">- SOCK_DGRAM : 报式协议默认使用 UDP</span><br><span class="line">- 返回值：</span><br><span class="line">- 成功：返回文件描述符，操作的就是内核缓冲区。</span><br><span class="line">- 失败：<span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>2.bind()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // socket命</span><br><span class="line">名</span><br><span class="line">- 功能：绑定，将fd 和本地的IP + 端口进行绑定</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 通过socket函数得到的文件描述符</span><br><span class="line">- addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息</span><br><span class="line">- addrlen : 第二个参数结构体占的内存大小</span><br></pre></td></tr></table></figure>

<p>3.listen()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int listen(int sockfd, int backlog); // /proc/sys/net/core/somaxconn</span><br><span class="line">- 功能：监听这个socket上的连接</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 通过socket()函数得到的文件描述符</span><br><span class="line">- backlog : 未连接的和已经连接的和的最大值， 5</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>accept()</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</span><br><span class="line">- 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 用于监听的文件描述符</span><br><span class="line">- addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port）</span><br><span class="line">- addrlen : 指定第二个参数的对应的内存大小</span><br><span class="line">- 返回值：</span><br><span class="line">- 成功 ：用于通信的文件描述符</span><br><span class="line">- -1 ： 失败</span><br></pre></td></tr></table></figure>

<p>5.connect()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">- 功能： 客户端连接服务器</span><br><span class="line">- 参数：</span><br><span class="line">- sockfd : 用于通信的文件描述符</span><br><span class="line">- addr : 客户端要连接的服务器的地址信息</span><br><span class="line">- addrlen : 第二个参数的内存大小</span><br><span class="line">- 返回值：成功 <span class="number">0</span>， 失败 <span class="number">-1</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 写数据</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>; <span class="comment">// 读数据</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>WebServer</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>computer network</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>WEB和HTTP</title>
    <url>/2021/08/23/http%E5%92%8Cweb/</url>
    <content><![CDATA[<blockquote>
<p>该目录下分享我在学习《计算机网络：自顶向下方法》的笔记</p>
</blockquote>
<h2 id="WEB和HTTP"><a href="#WEB和HTTP" class="headerlink" title="WEB和HTTP"></a>WEB和HTTP</h2><h3 id="1-HTTP和WEB概述"><a href="#1-HTTP和WEB概述" class="headerlink" title="1.HTTP和WEB概述"></a>1.HTTP和WEB概述</h3><p>HTTP（HyperText Transfer Protocol）是WEB的应用层协议，它是Web的核心；HTTP有两部分实现，一个客户端程序一个服务器程序；HTTP定义了客户和服务器进行报文交换的方法；</p>
<p>Web页面是由对象组成的，一个对象是一个文件，它们通过一个URL地址进行寻址。客户和服务器交互的核心思想是客户通过HTTP请求对服务器发出对Web页面的请求报文，服务器收到该报文后将返回包含该对象的HTTP响应报文。URL地址由两部分组成：存放对象的服务器主机名和对象的路径名</p>
<p>HTTP使用<strong>TCP</strong>作为它的传输层协议；HTTP客户首先发起一个与服务器的TCP连接，需要注意的是，服务器根据请求作出响应，但是不存储任何关于该客户的状态信息；也正因为这样，HTTP被称为<strong>无状态协议</strong>。同时，Web使用了客户端-服务器的应用体系结构；其中web服务器总是开着的</p>
<h3 id="2-持续连接HTTP和非持续连接HTTP"><a href="#2-持续连接HTTP和非持续连接HTTP" class="headerlink" title="2.持续连接HTTP和非持续连接HTTP"></a>2.持续连接HTTP和非持续连接HTTP</h3><p>在因特网应用程序中，客户端和服务器将在很长的时间范围里通信；应用程序将根据自身的特点，选择以规则的间隔周期性性发出请求也可以间断性一个个发出请求。当通信是使用TCP协议时，服务器端需要做出一个决定：这些请求是使用一个TCP连接完成还是通过独立的TCP连接完成。如果采取前一个方法，则称应用程序使用持续连接，如果使用后一种方式，则称为非持续连接。</p>
<p>HTTP既可使用持续连接也可以使用非持续连接。尽管<strong>HTTP在静默情况下使用持续连接</strong></p>
<h4 id="非持续连接HTTP"><a href="#非持续连接HTTP" class="headerlink" title="非持续连接HTTP"></a>非持续连接HTTP</h4><p>使用非持续连接时，每个TCP连接在服务器发送一个对象后就会关闭，也就是每个TCP只传送一个请求报文和响应报文；</p>
<p>为了描述持续连接和非持续连接的特点，我们引入<strong>RTT</strong>(Round-Trip Time)。</p>
<p>RTT指的是，一个短分组从客户端到服务器，然后再返回客户端所用的时间。</p>
<p>RTT包括分组的传播时延、排队时延、处理时延（因为是短分组，所以其传输时延可不计）；</p>
<p>客户端和服务器建立TCP连接的时候，会通过一个三次握手的过程来交换传输控制信息。三次握手的前两次占用了一个RTT，客户结合第三次握手通行会通过该连接发送一个HTTP请求报文，一旦该分组到达服务器，服务器便开始使用TCP传输HTML对象。因此，粗略地说，响应时间是两个RTT加上传输HTML的时间（不是传播）</p>
<h4 id="持续连接HTTP"><a href="#持续连接HTTP" class="headerlink" title="持续连接HTTP"></a>持续连接HTTP</h4><p>非持续连接必须为每个请求新建一个TCP连接，而每个TCP连接将占用系统资源，包括缓冲区和变量等，这样服务器的负担就很重了。第二，一个对象将通过两个RTT的时延才能交付。</p>
<p>如果使用持续连接，那么服务器在发送响应报文后将保持该TCP打开，后续客户端可以使用该连接来向服务器发出请求。不但一个完整的页面可以通过同一个连接传送，同一台服务器上的多个页面也可以通过同一个连接发送。这就提高了效率；</p>
<p>一般来说，如果一条连接在一定的时间间隔后没被使用的话，就会被关闭。HTTP默认使用的是带流水线的持续连接。</p>
<h3 id="3-HTTP报文格式"><a href="#3-HTTP报文格式" class="headerlink" title="3.HTTP报文格式"></a>3.HTTP报文格式</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>以下是wireshark抓出来的一段HTTP请求报文</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">GET</span> <span class="type">URl</span> <span class="type">HTTP</span><span class="operator">/</span><span class="number">1.1</span></span><br><span class="line"><span class="type">Host</span>: <span class="number">172.24</span>.<span class="number">116.154</span>:<span class="number">10000</span></span><br><span class="line"><span class="type">Connection</span>: keep<span class="operator">-</span>alive</span><br><span class="line"><span class="type">Upgrade</span><span class="operator">-</span><span class="type">Insecure</span><span class="operator">-</span><span class="type">Requests</span>: <span class="number">1</span></span><br><span class="line"><span class="type">User</span><span class="operator">-</span><span class="type">Agent</span>: <span class="type">Mozilla</span><span class="operator">/</span><span class="number">5.0</span> (<span class="type">Windows</span> <span class="type">NT</span> <span class="number">10.0</span>; <span class="type">Win64</span>; x64) <span class="type">AppleWebKit</span><span class="operator">/</span><span class="number">537.36</span> (<span class="type">KHTML</span>, like <span class="type">Gecko</span>) <span class="type">Chrome</span><span class="operator">/</span><span class="number">99.0</span>.<span class="number">4844.74</span> <span class="type">Safari</span><span class="operator">/</span><span class="number">537.36</span></span><br><span class="line"><span class="type">Accept</span>: text<span class="operator">/</span>html,application<span class="operator">/</span>xhtml<span class="operator">+</span>xml,application<span class="operator">/</span>xml;q<span class="operator">=</span><span class="number">0.9</span>,image<span class="operator">/</span>avif,image<span class="operator">/</span>webp,image<span class="operator">/</span>apng,<span class="operator">*/*</span>;q<span class="operator">=</span><span class="number">0.8</span>,application<span class="operator">/</span>signed<span class="operator">-</span>exchange;v<span class="operator">=</span>b3;q<span class="operator">=</span><span class="number">0.9</span></span><br><span class="line"><span class="type">Accept</span><span class="operator">-</span><span class="type">Encoding</span>: gzip, deflate</span><br><span class="line"><span class="type">Accept</span><span class="operator">-</span><span class="type">Language</span>: zh<span class="operator">-</span><span class="type">CN</span>,zh;q<span class="operator">=</span><span class="number">0</span>.9SESSID<span class="operator">=</span>deb31b8eb9ca68a514cf55777744e339</span><br></pre></td></tr></table></figure>

<p>HTTP的请求报文包括：请求行(request line)、请求头部(header)、空行 和 请求数据(request data) 四个部分组成。</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220326194015.png" alt="image-20220318111447560"></p>
<p><strong>请求行</strong>包括： 请求方法，URL(<strong>包括参数信息</strong>)，协议版本这些信息</p>
<p>**请求头部(Header)**是一个个的key-value值，比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Host: xxx.xxx.xxx.xxx</span><br><span class="line">Connection: Keep-Alive</span><br></pre></td></tr></table></figure>

<p><strong>空行(CR+LF)：请求报文用空行表示header和请求数据的分隔</strong></p>
<p><strong>请求数据</strong>：GET方法没有携带数据， POST方法会携带一个body</p>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>示例：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">HTTP</span><span class="operator">/</span><span class="number">1.1</span> <span class="number">200</span> <span class="type">OK</span></span><br><span class="line"><span class="type">Bdpagetype</span>: <span class="number">1</span></span><br><span class="line"><span class="type">Bdqid</span>: <span class="number">0xacbbb9d800005133</span></span><br><span class="line"><span class="type">Cache</span><span class="operator">-</span><span class="type">Control</span>: <span class="keyword">private</span></span><br><span class="line"><span class="type">Connection</span>: <span class="type">Keep</span><span class="operator">-</span><span class="type">Alive</span></span><br><span class="line"><span class="type">Content</span><span class="operator">-</span><span class="type">Encoding</span>: gzip</span><br><span class="line"><span class="type">Content</span><span class="operator">-</span><span class="type">Type</span>: text<span class="operator">/</span>html</span><br><span class="line"><span class="type">Cxy_all</span>: baidu<span class="operator">+</span>f8b5e5b521b3644ef7f3455ea441c5d0</span><br><span class="line"><span class="type">Date</span>: <span class="type">Fri</span>, <span class="number">12</span> <span class="type">Oct</span> <span class="number">2018</span> <span class="number">06</span>:<span class="number">36</span>:<span class="number">28</span> <span class="type">GMT</span></span><br><span class="line"><span class="type">Expires</span>: <span class="type">Fri</span>, <span class="number">12</span> <span class="type">Oct</span> <span class="number">2018</span> <span class="number">06</span>:<span class="number">36</span>:<span class="number">26</span> <span class="type">GMT</span></span><br><span class="line"><span class="type">Server</span>: <span class="type">BWS</span><span class="operator">/</span><span class="number">1.1</span></span><br><span class="line"><span class="type">Set</span><span class="operator">-</span><span class="type">Cookie</span>: delPer<span class="operator">=</span><span class="number">0</span>; path<span class="operator">=/</span>; domain<span class="operator">=</span>.baidu.com</span><br><span class="line"><span class="type">Set</span><span class="operator">-</span><span class="type">Cookie</span>: <span class="type">BDSVRTM</span><span class="operator">=</span><span class="number">0</span>; path<span class="operator">=/</span></span><br><span class="line"><span class="type">Set</span><span class="operator">-</span><span class="type">Cookie</span>: <span class="type">BD_HOME</span><span class="operator">=</span><span class="number">0</span>; path<span class="operator">=/</span></span><br><span class="line"><span class="type">Set</span><span class="operator">-</span><span class="type">Cookie</span>: <span class="type">H_PS_PSSID</span><span class="operator">=</span><span class="number">1433_21112_18560_26350_27245_22158</span>; path<span class="operator">=/</span>; domain<span class="operator">=</span>.baidu.com</span><br><span class="line"><span class="type">Vary</span>: <span class="type">Accept</span><span class="operator">-</span><span class="type">Encoding</span></span><br><span class="line"><span class="type">X</span><span class="operator">-</span><span class="type">Ua</span><span class="operator">-</span><span class="type">Compatible</span>: <span class="type">IE</span><span class="operator">=</span><span class="type">Edge</span>,chrome<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="type">Transfer</span><span class="operator">-</span><span class="type">Encoding</span>: chunked</span><br><span class="line"> </span><br><span class="line"><span class="operator">&lt;!</span><span class="type">DOCTYPE</span> html<span class="operator">&gt;</span></span><br><span class="line"><span class="operator">&lt;!--</span><span class="type">STATUS</span> <span class="type">OK</span><span class="operator">--&gt;</span></span><br></pre></td></tr></table></figure>

<p>HTTP的响应报文包括：状态行，响应头，空行，数据(响应体)</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220326194005.png" alt="image-20220318111831190"></p>
<p><strong>状态行</strong>包括：HTTP版本号，状态码和状态值组成。</p>
<p><strong>响应头</strong>类似请求头，是一系列key-value值</p>
<p>Cache-Control: private<br>Content-Encoding: gzip<br>Server: BWS&#x2F;1.1<br>Set-Cookie: delPer&#x3D;0; path&#x3D;&#x2F;; domain&#x3D;.baidu.com<br><strong>空白行</strong>：同上，响应报文也用空白行来分隔header和数据</p>
<p><strong>响应体</strong>：响应的data，本例中是一段HTML</p>
<h4 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h4><p>HTTP&#x2F;1.1 协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：</p>
<ol>
<li>GET：向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副<br>作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛等随意访<br>问。</li>
<li>HEAD：与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文<br>部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该<br>资源的信息”（元信息或称元数据）。</li>
<li>POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含<br>在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</li>
<li>PUT：向指定资源位置上传其最新内容。</li>
<li>DELETE：请求服务器删除 Request-URI 所标识的资源。</li>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li>
<li>OPTIONS：这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用’*’来代替资源名称，<br>向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。</li>
<li>CONNECT：HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服<br>务器的链接（经由非加密的 HTTP 代理服务器）。</li>
</ol>
<h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。</p>
<p>状态代码的第一个数字代表当前响应的类型：</p>
<ul>
<li>1xx消息——请求已被服务器接收，继续处理</li>
<li>2xx成功——请求已成功被服务器接收、理解、并接受</li>
<li>3xx重定向——需要后续操作才能完成这一请求</li>
<li>4xx请求错误——请求含有词法错误或者无法被执行</li>
<li>5xx服务器错误——服务器在处理某个正确请求时发生错误</li>
</ul>
<h3 id="4-用户与服务器的交互：Cookie"><a href="#4-用户与服务器的交互：Cookie" class="headerlink" title="4.用户与服务器的交互：Cookie"></a>4.用户与服务器的交互：Cookie</h3><p>前面提到，HTTP是无状态协议，但是Web站点为了识别用户身份或者限制用户访问的时间或者将用户访问的内容同用户身份相关联，Web站点可以使用Cookie技术；</p>
<p>Cookie技术包含4个组件：</p>
<ul>
<li>HTTP响应报文里增加一个关于Cookie的首部行；</li>
<li>HTTP请求报文里增加一个关于Cookie的首部行；</li>
<li>用户端系统保留一个Cookie文件，由浏览器保存维护；</li>
<li>Web站点建立Cookie和用户身份的关联；</li>
</ul>
<p>虽然，Cookie的使用方便了用户也方便了服务端，但是它的使用存在争议，因为使用Cookie被认为是对用户隐私的一种侵犯，因为Web站点可以通过Cookie得到很多用户的信息，并有可能将这部分信息卖给第三方等</p>
<h3 id="5-WEB缓存"><a href="#5-WEB缓存" class="headerlink" title="5.WEB缓存"></a>5.WEB缓存</h3><p>Web缓存器也被称为代理服务器，它代表初始web服务器来满足HTTP请求。它有自己的存储空间，并在存储空间里保持有最近请求过的对象的副本；可以通过配置浏览器，将所有指向初始服务器的请求首先指向代理服务器。</p>
<p>当代理服务器收到一个HTTP请求后，它将检查本地是否缓存过该对象，如果缓存过该对象，将检查是否过期，如果没有过期，则直接将该对象返回给浏览器；如果本地不存在或者存在已过期，则代理服务器将根据请求报文里的Host首部行以及请求行里的URL字段向初始服务器发出请求，然后将响应对象返回给浏览器并缓存在本地。</p>
<p>通常，代理服务器与客户端的通信速度要快于初始服务器与客户端的连接速度；Web代理服务器可以大起大减少对客户请求的响应时间；而且，缓存器能从整体上大大降低因特网上的web流量，从而有助于提高所有应用程序的性能；</p>
<p>通过使用内容分发网络（Content Distribution Network），Web缓存器正在因特网中发挥越来越重要的作用</p>
<p>Web缓存即是客户又是服务器</p>
<h3 id="6-条件get方法"><a href="#6-条件get方法" class="headerlink" title="6.条件get方法"></a>6.条件get方法</h3><p>高速缓存器的使用，带来很多好处，但是有一个问题就是代理服务器对缓存对象的管理：如何确保所请求的对象是最新的？</p>
<p>其实HTTP提供了一种机制，允许缓存器证实其使用的对象是最新的，这种机制就是<strong>条件GET方法</strong>。</p>
<p>使用<strong>条件GET方法</strong>只需在使用GET方法的时候，<strong>增加一个If-Modified-Since首部行</strong>，其对应的内容是一个时间，如果所请求的资源在指定日期后被修改了，那么服务器将返回新的对象，否则服务器将返回一个包含空实体体的报文。这样代理服务器就可以确认缓存是否过期了。</p>
]]></content>
      <categories>
        <category>computer network notes</category>
      </categories>
      <tags>
        <tag>computer network</tag>
        <tag>http</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>epoll原理解析</title>
    <url>/2022/02/20/epoll%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="epoll原理解析"><a href="#epoll原理解析" class="headerlink" title="epoll原理解析"></a>epoll原理解析</h1><p>epoll是linux下实现 I&#x2F;O 端口复用的一种系统调用，它可以提高程序的并发性。epoll模型常被用来开发高并发网络服务器，而其中原理却较为复杂。学习需要知其然更需知其所以然，故整理了一篇博客，希望能帮助大家理解epoll的工作原理</p>
<blockquote>
<p>注：本博客非原创，整理自 <a href="https://blog.csdn.net/armlinuxww/article/details/92803381">epoll原理解析</a></p>
</blockquote>
<h2 id="网卡接收数据"><a href="#网卡接收数据" class="headerlink" title="网卡接收数据"></a>网卡接收数据</h2><p>我们先从网卡接受数据的过程讲起</p>
<p>主机通过网络接受数据的过程如下</p>
<ul>
<li>网卡收到网线传来的数据。</li>
<li>硬件电路的传输。</li>
<li>最终 将数据写入到内存中的某个地址上。</li>
</ul>
<p>当网卡把数据写入到内存后，网卡向 CPU 发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。</p>
<h2 id="内核接收网络数据全过程"><a href="#内核接收网络数据全过程" class="headerlink" title="内核接收网络数据全过程"></a>内核接收网络数据全过程</h2><p>这一步，贯穿网卡、中断与进程调度的知识，叙述阻塞常规recv函数下，内核接收数据的全过程。</p>
<p>进程在 Recv 阻塞期间：</p>
<ul>
<li>计算机收到了对端传送的数据(步骤 ①)</li>
<li>数据经由网卡传送到内存(步骤 ②)</li>
<li>然后网卡通过中断信号通知 CPU 有数据到达，CPU 执行中断程序(步骤 ③)</li>
</ul>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220319100859.png" alt="img"></p>
<p>此处的中断程序主要有两项功能，先将网络数据写入到对应 Socket 的接收缓冲区里面(步骤 ④)，再唤醒进程 A(步骤 ⑤)，重新将进程 A 放入工作队列中。</p>
<p>那么问题来了</p>
<ul>
<li>操作系统如何知道网络数据对应于哪个 Socket?</li>
<li>如何同时监视多个 Socket 的数据?</li>
</ul>
<p>第一个问题：因为一个 Socket 对应着一个端口号，而网络数据包中包含了 IP 和端口的信息，内核可以通过端口号找到对应的 Socket。当然，为了提高处理速度，操作系统会维护端口号到 Socket 的索引结构，以快速读取。</p>
<p>第二个问题是多路复用的重中之重，也正是本文后半部分的重点。</p>
<h2 id="Select监视多个socket方法"><a href="#Select监视多个socket方法" class="headerlink" title="Select监视多个socket方法"></a>Select监视多个socket方法</h2><p>​    在讲epoll之前，我们先来介绍一下select，他也是实现I&#x2F;O多路复用的一种方法，出现在epoll之前，实现也比epoll简单。</p>
<p>Select 的实现思路很直接，假如程序同时监视如下图的 Sock1、Sock2 和 Sock3 三个 Socket，那么在调用 Select 之后，操作系统把进程 A 分别加入这三个 Socket 的等待队列中。操作系统把进程 A 分别加入这三个 Socket 的等待队列中当任何一个 Socket 收到数据后，中断程序将唤起进程。下图展示了 Sock2 接收到了数据的处理流程：</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220319101427.png" alt="img"></p>
<p>Sock2 接收到了数据，中断程序唤起进程 A</p>
<p>注：Recv 和 Select 的中断回调可以设置成不同的内容。</p>
<p>所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里面，如下图所示：</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220319101507.png" alt="img"></p>
<p>这种简单方式行之有效，在几乎所有操作系统都有对应的实现。但是简单的方法往往有缺点，主要是：</p>
<ul>
<li>每次调用 Select 都需要将进程加入到所有监视 Socket 的等待队列，每次唤醒都需要从每个队列中移除。这里涉及了两次遍历，而且每次都要将整个 FDS 列表传递给内核，有一定的开销。</li>
<li>进程被唤醒后，程序并不知道哪些 Socket 收到数据，还需要遍历一次。</li>
</ul>
<h2 id="Epoll设计思路"><a href="#Epoll设计思路" class="headerlink" title="Epoll设计思路"></a>Epoll设计思路</h2><p>Epoll 是在 Select 出现 N 多年后才被发明的，是 Select 和 Poll(Poll 和 Select 基本一样，有少量改进)的增强版本。Epoll 通过以下一些措施来改进效率</p>
<h3 id="Epoll用法"><a href="#Epoll用法" class="headerlink" title="Epoll用法"></a>Epoll用法</h3><p>为方便理解后续的内容，我们先大概了解一下 Epoll 的用法。如下的代码中，先用 epoll_create 创建一个 Epoll 对象 Epfd，再通过 epoll_ctl 将需要监视的 Socket 添加到 Epfd 中，最后调用epoll_wait 等待数据</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);    </span><br><span class="line">bind(s, ...) </span><br><span class="line">listen(s, ...) </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> epfd = epoll_create(...); </span><br><span class="line">epoll_ctl(epfd, ...); <span class="comment">//将所有需要监听的socket添加到epfd中 </span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123; </span><br><span class="line">    <span class="type">int</span> n = epoll_wait(...) </span><br><span class="line">    <span class="keyword">for</span>(接收到数据的socket)&#123; </span><br><span class="line">        <span class="comment">//处理 </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="Epoll-的原理与工作流程"><a href="#Epoll-的原理与工作流程" class="headerlink" title="Epoll 的原理与工作流程"></a>Epoll 的原理与工作流程</h3><h4 id="创建-Epoll-对象"><a href="#创建-Epoll-对象" class="headerlink" title="创建 Epoll 对象"></a>创建 Epoll 对象</h4><p>如下图所示，当某个进程调用 epoll_create 方法时，内核会创建一个 eventpoll 对象。</p>
<p>eventpoll 对象也是文件系统中的一员，和 Socket 一样，它也会有等待队列。</p>
<p>创建一个代表该 Epoll 的 eventpoll 对象是必须的，因为内核要维护“就绪列表”等数据，“就绪列表”可以作为 eventpoll 的成员。</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220319102113.png" alt="img"></p>
<h4 id="维护监视列表"><a href="#维护监视列表" class="headerlink" title="维护监视列表"></a><strong>维护监视列表</strong></h4><p>创建 Epoll 对象后，可以用 epoll_ctl 添加或删除所要监听的 Socket。以添加 Socket 为例。</p>
<p>如上图，如果通过 epoll_ctl 添加 Sock1、Sock2 和 Sock3 的监视，内核会将 eventpoll 添加到这三个 Socket 的等待队列中。</p>
<p>当 Socket 收到数据后，中断程序会操作 eventpoll 对象，而不是直接操作进程。</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220319102248.png" alt="img"></p>
<h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a><strong>接收数据</strong></h4><p>当 Socket 收到数据后，中断程序会给 eventpoll 的“就绪列表”添加 Socket 引用。</p>
<p>如下图展示的是 Sock2 和 Sock3 收到数据后，中断程序让 Rdlist 引用这两个 Socket。</p>
<p>eventpoll 对象相当于 Socket 和进程之间的中介，Socket 的数据接收并不直接影响进程，而是通过改变 eventpoll 的就绪列表来改变进程状态。</p>
<p>当程序执行到 epoll_wait 时，如果 Rdlist 已经引用了 Socket，那么 epoll_wait 直接返回，如果 Rdlist 为空，阻塞进程。</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220319102557.png" alt="img"></p>
<h4 id="阻塞和唤醒进程"><a href="#阻塞和唤醒进程" class="headerlink" title="阻塞和唤醒进程"></a><strong>阻塞和唤醒进程</strong></h4><p>假设计算机中正在运行进程 A 和进程 B，在某时刻进程 A 运行到了 epoll_wait 语句。</p>
<p>如下图所示，内核会将进程 A 放入 eventpoll 的等待队列中，阻塞进程。</p>
<p>当 Socket 接收到数据，中断程序一方面修改 Rdlist，另一方面唤醒 eventpoll 等待队列中的进程，进程 A 再次进入运行状态</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220319102646.png" alt="img"></p>
<h3 id="epoll实现细节"><a href="#epoll实现细节" class="headerlink" title="epoll实现细节"></a>epoll实现细节</h3><p>至此，相信读者对 Epoll 的本质已经有一定的了解。但我们还需要知道 eventpoll 的数据结构是什么样子?</p>
<p>此外，就绪队列应该使用什么数据结构? eventpoll 应使用什么数据结构来管理通过 epoll_ctl 添加或删除的 Socket?</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220319103002.png" alt="img"></p>
<p>Epoll 原理示意图，图片来源：《深入理解 <a href="https://so.csdn.net/so/search?q=Nginx&spm=1001.2101.3001.7020">Nginx</a>：模块开发与架构解析(第二版)》，陶辉</p>
<p>如上图所示，eventpoll 包含了 Lock、MTX、WQ(等待队列)与 Rdlist 等成员，其中 Rdlist 和 RBR 是我们所关心的。</p>
<h4 id="就绪列表的数据结构"><a href="#就绪列表的数据结构" class="headerlink" title="就绪列表的数据结构"></a><strong>就绪列表的数据结构</strong></h4><p>就绪列表引用着就绪的 Socket，所以它应能够快速的插入数据。程序可能随时调用 epoll_ctl 添加监视 Socket，也可能随时删除。</p>
<p>当删除时，若该 Socket 已经存放在就绪列表中，它也应该被移除。所以就绪列表应是一种能够快速插入和删除的数据结构。</p>
<p>双向链表就是这样一种数据结构，Epoll 使用双向链表来实现就绪队列(对应上图的 Rdlist)。</p>
<p><strong>索引结构</strong></p>
<p>既然 Epoll 将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保存监视的 Socket，至少要方便地添加和移除，还要便于搜索，以避免重复添加。</p>
<p>红黑树是一种自平衡二叉查找树，搜索、插入和删除时间复杂度都是 O(log(N))，效率较好，Epoll 使用了红黑树作为索引结构(对应上图的 RBR)。</p>
<p>注：因为操作系统要兼顾多种功能，以及有更多需要保存的数据，Rdlist 并非直接引用 Socket，而是通过 Epitem 间接引用，红黑树的节点也是 Epitem 对象。</p>
<p>同样，文件系统也并非直接引用着 Socket。为方便理解，本文中省略了一些间接结构。</p>
<h3 id="select和epoll实现方法对比"><a href="#select和epoll实现方法对比" class="headerlink" title="select和epoll实现方法对比"></a>select和epoll实现方法对比</h3><p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220319102814.png" alt="img"></p>
]]></content>
      <categories>
        <category>WebServer</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>computer network</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS:因特网的目录服务</title>
    <url>/2021/08/30/DNS/</url>
    <content><![CDATA[<h2 id="2-4-DNS-因特网的目录服务"><a href="#2-4-DNS-因特网的目录服务" class="headerlink" title="2.4 DNS: 因特网的目录服务"></a>2.4 DNS: 因特网的目录服务</h2><h3 id="2-4-1-DNS提供的服务"><a href="#2-4-1-DNS提供的服务" class="headerlink" title="2.4.1 DNS提供的服务"></a>2.4.1 DNS提供的服务</h3><p>解决主机名和IP地址的转化问题。因为在信息的发送者一端，通常使用主机名来标识主机，但是在计算机网络里是使用IP地址来标主机。</p>
<p><strong>DNS（Domain Name System）域名系统</strong>。</p>
<p>DNS是一个由分层的DNS服务器组成的分布式数据库和一个使得主机可以查询分布式数据库的应用层协议组成；</p>
<p>除了提供<strong>主机名到IP地址的转换</strong>外，DNS还提供以下重要服务</p>
<p><strong>主机别名</strong>：DNS不但提供主机名到IP地址的转换服务，还提供主机名与主机别名的转换；此时主机名被称为规范主机名；</p>
<p><strong>邮件服务器别名</strong>：DNS同样也提供邮件服务器主机名和别名的转换服务，实际上，公司的邮件服务器和Web服务器可以使用相同的主机别名；MX记录允许一个公司的邮件服务器和Web服务器使用相同的主机名。</p>
<p><strong>负载分配</strong>：DNS也被用在冗余的服务器之间分配负载。一个IP集合往往对应一个规范主机名（没太理解？？？）</p>
<h3 id="2-4-2-DNS工作机理概述"><a href="#2-4-2-DNS工作机理概述" class="headerlink" title="2.4.2 DNS工作机理概述"></a>2.4.2 DNS工作机理概述</h3><p>DNS使用<strong>UDP</strong>作为其传输层协议；DNS服务使用<strong>53</strong>端口；</p>
<p>当主机上的DNS客户端收到一个转换请求时，客户端将向网络发送一个DNS查询报文，然后客户端将收到一个包含相关信息的DNS回答报文，这个报文里有客户端想要的内容，之后DNS客户端将IP地址返回给请求的提出者即可。</p>
<p>从使用DNS服务的请求者来看，DNS就像一个简单的提供直接转换服务的黑盒子，实际上这个黑盒子非常复杂，由分布在全球的大量DNS服务器以及定义DNS服务器和查询主机之间如何通信的应用层协议组成；</p>
<p><strong>DNS采用分布式的设计方案</strong>，实际上，DNS是一个在因特网实现分布式数据库的精彩范例！而之所以这样做，是因为，<strong>单一的DNS服务器无法解决单点故障、无法保证通信容量以及无法临近所有的查询主机和维护困难</strong>等问题</p>
<p><strong>DNS采用分布式的设计方案</strong></p>
<p>为了处理扩展性问题，DNS服务器采用层次式组织，并且分布在全世界范围内；大致来说，存在三种DNS服务器：<strong>根</strong>DNS服务器、<strong>顶级域</strong>DNS服务器和<strong>权威</strong>DNS服务器；</p>
<p>其工作的普遍流程：一个DNS客户端，希望获得<a href="http://www.baidu.com的ip地址,粗略的说,dns客户端首先和根dns服务器取得联系,它将返回负责解析顶级域名com的服务器的ip地址(或者其集合),客户将同这些服务器之一取得联系,然后顶级域dns服务器建返回baidu.com的权威服务器的ip集合,客户端通过与这些服务器之一取得联系,获得www.baidu.com的ip地址./">www.baidu.com的IP地址，粗略的说，DNS客户端首先和根DNS服务器取得联系，它将返回负责解析顶级域名com的服务器的IP地址（或者其集合），客户将同这些服务器之一取得联系，然后顶级域DNS服务器建返回baidu.com的权威服务器的IP集合，客户端通过与这些服务器之一取得联系，获得www.baidu.com的IP地址。</a></p>
<h4 id="DNS服务器"><a href="#DNS服务器" class="headerlink" title="DNS服务器"></a>DNS服务器</h4><ul>
<li>根DNS服务器：因特网上有13个根DNS服务器，大部分分布在北美洲，尽管我们可以将这13个根DNS服务器视为单个的服务器，但是每台服务器实际上是一个冗余的计算机网络以提供安全性和可靠性；</li>
<li>顶级域DNS服务器：负责顶级域名，如com，org，net，edu，gov以及各个国家的顶级域名的转换。</li>
<li>权威DNS服务器：因特网上，具有公共可访问主机的每个组织机构必须公共可访问的DNS记录，这些记录将主机名映射为IP地址。一个组织的权威DNS服务器收藏了这些DNS记录，多数大学和大公司实现和维护它们自己的基本和辅助（备份）权威DNS服务器；当然，也可以通过付费的方式，将相关的信息插入到其它权威服务器中；</li>
<li><strong>本地DNS服务器</strong>。本地DNS服务器不在DNS层次结构之中,通常邻近其所在网络的其他主机。当主机发出DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将请求转发到DNS服务器层次结构中。</li>
</ul>
<h4 id="DNS查询方式"><a href="#DNS查询方式" class="headerlink" title="DNS查询方式"></a>DNS查询方式</h4><p>DNS查询有两种，一种是递归查询一种是迭代查询；</p>
<p>实践中，查询通常满足这样的模式：从请求主机到本地DNS服务器的查询是递归的，其余查询是迭代的。</p>
<p>所谓<strong>迭代</strong>就是，如果请求的接收者不知道所请求的内容，那么接收者将扮演请求者，发出有关请求，直到获得所需要的内容，然后将内容返回给最初的请求者。也就是说，在<strong>递归查询</strong>中，一定要给请求者想要的答案；<strong>迭代查询</strong>则是指，如果接收者没有请求者所需要的准确内容，接收者将告诉请求者，如何去获得，但是自己并不去发出请求。</p>
<p>图2・18所示的例子利用了递归查询(recursive query)和迭代查询(iterative query)。从cse. nyu. edu到dns. nyu. edu发出的查询是递归查询，因为该查询以自己的名义请求dns. nyu. edu来获得该映射。而后继的3个查询是迭代查询，因为所有的回答都是直接返<br>回给dns. nyu. eduo</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220325154736.png" alt="image-20220325113254234"></p>
<p>图2・19显示了一条DNS查询链，其中的所有查询都是递归的。实践中，查询通常遵循图2・18中的模式：从请求主机到本地DNS服务器的查询是递归的，其余的查询是迭代的。</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220325154746.png" alt="image-20220325113425441"></p>
<h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p>DNS缓存实际上是为了盖上时延性能并且减少在因特网上传输的DNS报文数量而引入的。DNS缓存原理十分简单，每当DNS服务器发出请求后收到回答时，就将回答的内容缓存在它自己的主机空间上。这样，如果有相同的请求到达时，就不需要再去发出请求，直接使用缓存即可；因为有了缓存，本地DNS就可以直接提供一些经常被访问的主机名所对应的IP地址，而不需要询问根DNS服务器了。需要注意的是，缓存不可避免的一个问题：有效时间。如果缓存过时而未得到更新，那么就会导致一些请求失败。</p>
<p>个人认为，缓存技术就是一种典型的使用<strong>空间换时间</strong>的策略</p>
<h3 id="2-4-3-DNS记录和报文"><a href="#2-4-3-DNS记录和报文" class="headerlink" title="2.4.3 DNS记录和报文"></a>2.4.3 DNS记录和报文</h3><h4 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h4><p>共同实现分布式数据库的所有DNS服务器存储了资源记录(Resource Record)。而RR提供了主机名到IP地址的映射信息；一条RR是具有一下字段的4元组：（name, value, type, TTL）;其中TTL是指该记录的生存时间，它决定了该条记录何时被删除。</p>
<p>首先看看type，type有4种取值，包括：A、NS、CNAME、MX等：</p>
<pre><code>type=A：则name为主机名，value为对应的IP地址；
type=NS：则name为域，value为如何获得该域下主机IP地址的权威DNS服务器的主机名；
type=CNAME：则value为name（本身为主机别名）所对应的主机的规范主机名；
type=MX：则value为那么所对应的邮件服务器的规范主机名；
</code></pre>
<h4 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h4><p>DNS报文有两种，即<strong>查询报文</strong>和<strong>回答报文</strong>，并且两种报文有着相同的结构</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220304140851.png" alt="image-20220304140851297"></p>
]]></content>
      <categories>
        <category>computer network notes</category>
      </categories>
      <tags>
        <tag>computer network</tag>
        <tag>web</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>因特网中的电子邮件</title>
    <url>/2021/09/04/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="2-3因特网中的电子邮件"><a href="#2-3因特网中的电子邮件" class="headerlink" title="2.3因特网中的电子邮件"></a>2.3因特网中的电子邮件</h2><p>电子邮件是一种异步通信媒介，不必与他人的计划进行协调。现代电子邮件报文常常包含附件、超链接、HTML格式文本和图片。</p>
<p>internet电子邮件系统通常包括：用户代理、邮件服务器、简单邮件传输协议SMTP。</p>
<p>邮件服务器构成了电子邮件系统的核心。每个收发方在邮件服务器上拥有一个邮箱；一个典型的电子邮件发送过成为：发送方通过用户代理将邮件传送到发送方的邮件服务器，然后再传输到接收方的邮件服务器，然后邮件被分发到接收方的邮箱里；接收方从邮件服务器里获取自己的邮件时需要通过邮件服务器的验证</p>
<p><strong>SMTP是因特网中电子邮件的主要应用层协议</strong>，它使用TCP可靠数据传输从发送方的邮件服务器向接收方的邮件服务器发送邮件；在每台邮件服务器上同时运行SMTP服务器和SMTP客户端。当邮件服务器接收其他邮件服务器的邮件时，它表现为SMTP服务器，当邮件服务器向其他邮件服务器发送邮件时，表现为SMTP客户端。</p>
<p>如果发送端不能将邮件发送个接受端的服务器，发送端的邮件服务器会在一个报文队列中保持该报文并在以后尝试再次发送。</p>
<h3 id="2-3-1SMTP"><a href="#2-3-1SMTP" class="headerlink" title="2.3.1SMTP"></a>2.3.1SMTP</h3><p><strong>传输的三个阶段</strong>：握手、传输、关闭连接。</p>
<p>SMTP25号端口。SMTP是持续连接的。对每一报文，客户使用一个新的MAIL FROM：crepes.fr开始。当所有报文发送完后才发送QUIT，断开连接。SMTP出现在因特网之前，尽管它有着很不错的特性，但是它具有的某种陈旧的特征表明它仍然是一种继承的技术，比如，它限制邮件报文的所有部分只能使用7比特的ASCII表示，这就导致二进制多媒体文件需要编码为ASCII，而且在发送方需要编码，接收方则需要解码。</p>
<p>值得注意的是，SMTP报文一般不使用中间邮件服务器发送报文，也就是邮件不会在中间某个邮件服务器保留；在SMTP握手阶段，SMTP客户端将介绍发送方和接收方的邮箱地址；一旦介绍完毕后，SMTP客户端将开始发送报文</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220326194302.png" alt="image-20220323090828915"></p>
<h3 id="2-3-2-与HTTP对比"><a href="#2-3-2-与HTTP对比" class="headerlink" title="2.3.2 与HTTP对比"></a>2.3.2 与HTTP对比</h3><p>HTTP和SMTP都是用TCP协议；持续的HTTP和SMTP都是用持续连接；但是两者也有区别。</p>
<ul>
<li>首先HTTP被设计为一个Pull协议而SMTP被设计为一个Push协议。即用户通过HTTP主动向服务器请求内容，而SMTP则是客户将内容推向服务器端；</li>
<li>第二个区别就是HTTP传输的数据不一定是用ASCII字符，但是SMTP则只能使用ASCII字符；</li>
<li>第三个重要区别就是，HTTP将每个对象封装在自己的响应报文里，而SMTP则将所有的报文对象放到一个报文之中；</li>
</ul>
<h3 id="2-3-3-邮件报文格式"><a href="#2-3-3-邮件报文格式" class="headerlink" title="2.3.3 邮件报文格式"></a>2.3.3 邮件报文格式</h3><p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220325154621.png" alt="image-20220323095531056"></p>
<p>报文由两部分组成：一个包含环境信息的首部和一个包含邮件内容的报文体；首部和报文体之间使用空行分开；首部行的格式为关键字：及其值；每个首部必须包含一个From和To首部行。首部也可以包含其它信息，比如Subject等。这与2.4.1中接触的SMTP命令不同，那节中的命令是握手协议的一部分；本节中研究的内容是邮件报文自身的一部分</p>
<h3 id="2-3-4-邮件访问协议"><a href="#2-3-4-邮件访问协议" class="headerlink" title="2.3.4 邮件访问协议"></a>2.3.4 邮件访问协议</h3><p>需要注意的是，SMTP是邮件服务器之间发送邮件报文的协议，并不是用户通过代理和邮件服务器之间通信的协议；用户代理使用邮件访问协议来从邮件服务器上获取邮件信息；目前常用的邮件访问协议有POP3（Post Office Protocol-Version 3）、因特网邮件访问协议（IMAP，Internet Mail Access protocol）和HTTP</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220325154622.png" alt="image-20220323095931773"></p>
<ul>
<li><strong>POP3</strong></li>
</ul>
<p>POP3是一个非常简单的协议，因为简单，所以功能有限；</p>
<p>POP3使用端口110来建立TCP连接（SMTP使用端口25）；</p>
<p>POP3按照三个阶段进行工作：特许、事务处理和更新；</p>
<ul>
<li>在特许阶段，用户代理发送密码和用户名，进行身份鉴别；</li>
<li>第二阶段，用户代理取回报文，同时还可以做删除、取消删除等标记或者统计邮件信息；</li>
<li>第三个阶段是在用户退出后，POP3结束会话，删除被标记的邮件；</li>
</ul>
<p>一个需要注意的是，POP3用户代理可以使用两种事务处理模式：一种是下载并删除，另一种是下载保留；POP3代理发出的命令和其工作模式相关；</p>
<p>下载并删除的方法存在的问题是，如果用户在一台设备上查看了邮件（下载了邮件）后，邮件将被删除，那么在其他设备上将无法查看邮件；这给用户带来一定的不便。使用下载保存方式，则用户下载邮件后，邮件还在服务器上。</p>
<p>在用户代理与邮箱服务器之间的POP3会话期间，该POP3服务器保留了一些状态信息，特别是标记了哪些用户报文被标记为删除了。但是POP3服务器并不在POP3绘画过程中携带状态信息，大大简化了POP3的服务。</p>
<ul>
<li><strong>IMAP</strong></li>
</ul>
<p>POP3协议无法为用户提供邮件分类管理的功能，虽然用户可以通过将邮件下载到本地，然后由用户代理程序做分类管理，但是处理的结果是无法同步到其他查看设备上的。为了解决这一问题，IMAP诞生了。IMAP是一个邮件访问协议，比POP3要复杂的多，当然也就有更多的特色了。</p>
<p>（远程）IMAP将每一份邮件和一个一个文件夹联系起来，当报文第一次到达服务器时，它与收件人的INBOX相关联。收件人可以将邮件移到新创建的文件夹，阅读邮件，删除邮件等。</p>
<p>IMAP允许用户在不同文件夹里移动邮件并且查询邮件。值得注意的是，IMAP服务器维护了IMAP会话的用户状态信息，但是POP3并不；IMAP协议还允许用户代理获取报文组件而不是报文整体。</p>
<ul>
<li><strong>基于Web的电子邮件</strong></li>
</ul>
<p>这种方式主要是指，用户使用HTTP协议和邮件服务器通信。用户代理就是普通的浏览器，但是，邮件服务器之间还是使用SMTP协议的</p>
]]></content>
      <categories>
        <category>computer network notes</category>
      </categories>
      <tags>
        <tag>computer network</tag>
        <tag>SMTP</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法总结</title>
    <url>/2021/04/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>常见排序算法包括「冒泡排序」、「插入排序」、「选择排序」、「快速排序」、「归并排序」、「堆排序」、「基数排序」、「桶排序」。如下图所示，为各排序算法的核心特性与时空复杂度总结。</p>
<h2 id="排序算法的特性"><a href="#排序算法的特性" class="headerlink" title="排序算法的特性"></a>排序算法的特性</h2><p>排序算法主要可根据 稳定性 、就地性 、自适应性 分类。理想的排序算法具有以下特性：</p>
<ol>
<li>具有稳定性，即相等元素的相对位置不变化；</li>
<li>具有就地性，即不使用额外的辅助空间；</li>
<li>具有自适应性，即时间复杂度受元素分布影响；</li>
</ol>
<p>各排序算法的核心特性与时空复杂度如下</p>
<img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220405230109.png" alt="image-20220405225740901" style="zoom:200%;">

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>冒泡排序算法的运作如下（以从小到大排序为例）：</p>
<ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; length -  i - <span class="number">1</span>; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> temp;</span><br><span class="line">				temp = arr[j + <span class="number">1</span>];</span><br><span class="line">				arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">				arr[j] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="算法特性"><a href="#算法特性" class="headerlink" title="算法特性"></a>算法特性</h3><p>时间复杂度为 $O(N^2)$，因为其是通过不断 交换元素 实现排序（交换 2 个元素需要 3 次赋值操作），因此速度较慢；</p>
<ul>
<li>原地： 指针变量仅使用常数大小额外空间，空间复杂度为 $O(1)$ ；</li>
<li>稳定： 元素值相同时不交换，因此不会改变相同元素的相对位置；</li>
<li>自适应： 通过增加一个标志位 flag ，若某轮内循环未执行任何交换操作时，说明已经完成排序，因此直接返回。此优化使冒泡排序的最优时间复杂度达到 $O(N)$（当输入数组已排序时）；</li>
</ul>
<h3 id="效率优化"><a href="#效率优化" class="headerlink" title="效率优化"></a>效率优化</h3><p>通过增加一个标志位 flag ，若在某轮「内循环」中未执行任何交换操作，则说明数组已经完成排序，直接返回结果即可。</p>
<p>优化后的冒泡排序的最差和平均时间复杂度仍为 $O(N^2)$；在输入数组 已排序 时，达到 最佳时间复杂度$\Omega(N)$ 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> N = nums.<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		<span class="type">bool</span> flag = <span class="literal">false</span>;   <span class="comment">// 初始化标志位</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">				<span class="built_in">swap</span>(nums[j], nums[j + <span class="number">1</span>]);</span><br><span class="line">				flag = <span class="literal">true</span>; <span class="comment">// 记录交换元素</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) <span class="keyword">break</span>;    <span class="comment">// 内循环未交换任何元素，则跳出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。其中一个子序列全部大于或小于另一个子序列。通过对子序列进行再次划分，最终达到整体有序</p>
<blockquote>
<p>Algorithm description:</p>
<p>Quicksort uses a Divide and conquer strategy to Divide a list into two sub-lists. One subsequence is all greater or less than the other.  </p>
<p>The whole order is achieved by dividing the subsequence again</p>
</blockquote>
<h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><ul>
<li>从数列中挑出一个元素，称为”基准”（pivot），通常选取待排序数组的第一个数字</li>
<li>重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为<strong>分区（partition）</strong>操作。</li>
<li>递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
<li>递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</li>
</ul>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 以 nums[l] 作为基准数</span></span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) i++;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[i], nums[l]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 哨兵划分操作</span></span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">    <span class="comment">// 递归左（右）子数组执行哨兵划分</span></span><br><span class="line">    <span class="built_in">quickSort</span>(nums, l, i - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(nums, i + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul>
<li><p>最佳 $\Omega(N \log N )Ω(NlogN)$ ： 最佳情况下， 每轮哨兵划分操作将数组划分为等长度的两个子数组；哨兵划分操作为线性时间复杂度 O(N)O(N) ；递归轮数共 O(\log N)O(logN) 。</p>
</li>
<li><p>平均 $\Theta(N \log N)Θ(NlogN)$ ： 对于随机输入数组，哨兵划分操作的递归轮数也为 $O(\log N)O(logN)$ 。</p>
</li>
<li><p>最差 $O(N^2)$： 对于某些特殊输入数组，每轮哨兵划分操作都将长度为 N 的数组划分为长度为 1和 N - 1 的两个子数组，此时递归轮数达到 N 。</p>
</li>
</ul>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>空间复杂度 $O(N)$ ： 快速排序的递归深度最好与平均皆为 $\log NlogN$ ；输入数组完全倒序下，达到最差递归深度 N 。</p>
<h3 id="算法特性-1"><a href="#算法特性-1" class="headerlink" title="算法特性"></a>算法特性</h3><ul>
<li><p>原地： 不用借助辅助数组的额外空间，递归仅使用 $O(\log N)$ 大小的栈帧空间。</p>
</li>
<li><p>非稳定： 哨兵划分操作可能改变相等元素的相对顺序。</p>
</li>
<li><p>自适应： 对于极少输入数据，每轮哨兵划分操作都将长度为 N的数组划分为长度 1 和 N−1 两个子数组，此时时间复杂度劣化至 $O(N^2)$。</p>
</li>
</ul>
<h3 id="算法优化"><a href="#算法优化" class="headerlink" title="算法优化"></a>算法优化</h3><p>快速排序的常见优化手段有「Tail Call」和「随机基准数」两种。</p>
<h4 id="Tail-Call"><a href="#Tail-Call" class="headerlink" title="Tail Call"></a>Tail Call</h4><p>由于普通快速排序每轮选取「子数组最左元素」作为「基准数」，因此在输入数组 完全倒序 时， partition() 的递归深度会达到 N ，即 最差空间复杂度 为 O(N) 。</p>
<p>每轮递归时，仅对 较短的子数组 执行哨兵划分 partition() ，就可将最差的递归深度控制在 $O(\log N)$ （每轮递归的子数组长度都≤ 当前数组长度 &#x2F;2 ），即实现最差空间复杂度 $O(\log N)$ 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 子数组长度为 1 时终止递归</span></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="comment">// 哨兵划分操作</span></span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">        <span class="comment">// 仅递归至较短子数组，控制递归深度</span></span><br><span class="line">        <span class="keyword">if</span> (i - l &lt; r - i) &#123;</span><br><span class="line">            <span class="built_in">quickSort</span>(nums, l, i - <span class="number">1</span>);</span><br><span class="line">            l = i + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">quickSort</span>(nums, i + <span class="number">1</span>, r);</span><br><span class="line">            r = i - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="随机基准数"><a href="#随机基准数" class="headerlink" title="随机基准数"></a>随机基准数</h4><p>同样地，由于快速排序每轮选取「子数组最左元素」作为「基准数」，因此在输入数组 完全有序 或 完全倒序 时， partition() 每轮只划分一个元素，达到最差时间复杂度 $O(N^2)$。</p>
<p>因此，可使用 随机函数 ，每轮在子数组中随机选择一个元素作为基准数，这样就可以极大概率避免以上劣化情况。</p>
<p>值得注意的是，由于仍然可能出现最差情况，因此快速排序的最差时间复杂度仍为 $O(N^2)$。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在闭区间 [l, r] 随机选取任意索引，并与 nums[l] 交换</span></span><br><span class="line">    <span class="type">int</span> ra = l + <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">swap</span>(nums[l], nums[ra]);</span><br><span class="line">    <span class="comment">// 以 nums[l] 作为基准数</span></span><br><span class="line">    <span class="type">int</span> i = l, j = r;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[l]) j--;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[l]) i++;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[i], nums[l]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>归并排序（merge-sort）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<h3 id="算法描述-递归法"><a href="#算法描述-递归法" class="headerlink" title="算法描述(递归法)"></a>算法描述(递归法)</h3><ul>
<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li>
<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li>
<li>重复步骤3直到某一指针超出序列尾。</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾</li>
</ul>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 递归划分</span></span><br><span class="line">    <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, l, m);</span><br><span class="line">    <span class="built_in">mergeSort</span>(nums, m + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">// 合并阶段</span></span><br><span class="line">    <span class="type">int</span> tmp[r - l + <span class="number">1</span>];             <span class="comment">// 暂存需合并区间元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = l; k &lt;= r; k++)</span><br><span class="line">        tmp[k - l] = nums[k];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = m - l + <span class="number">1</span>;       <span class="comment">// 两指针分别指向左/右子数组的首个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = l; k &lt;= r; k++) &#123;  <span class="comment">// 遍历合并左/右子数组</span></span><br><span class="line">        <span class="keyword">if</span> (i == m - l + <span class="number">1</span>)</span><br><span class="line">            nums[k] = tmp[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == r - l + <span class="number">1</span> || tmp[i] &lt;= tmp[j])</span><br><span class="line">            nums[k] = tmp[i++];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            nums[k] = tmp[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="算法复杂度-1"><a href="#算法复杂度-1" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><p>时间复杂度： 最佳Ω(NlogN) ，平均 Θ(NlogN) ，最差 O(NlogN) 。</p>
<p>空间复杂度 O(N) ： 合并过程中需要借助辅助数组 tmp ，使用 O(N)O(N) 大小的额外空间；划分的递归深度为 logN ，使用 O(logN) 大小的栈帧空间。</p>
<p>若输入数据是 链表 ，则归并排序的空间复杂度可被优化至 O(1) ，这是因为：</p>
<p>通过应用「双指针法」，可在O(1) 空间下完成两个排序链表的合并，省去辅助数组tmp 使用的额外空间；<br>通过使用「迭代」代替「递归划分」，可省去递归使用的栈帧空间；</p>
<blockquote>
<p>迭代和递归的关系和区别（敲黑板）<br>从概念上讲，递归就是指程序调用自身的编程思想，即一个函数调用本身；</p>
<p>迭代是利用已知的变量值，根据递推公式不断演进得到变量新值得编程思想。</p>
<p>简单地说，递归是重复调用函数自身实现循环。</p>
<p>迭代是函数内某段代码实现循环，而迭代与普通循环的区别是：循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</p>
</blockquote>
<h3 id="算法特性-2"><a href="#算法特性-2" class="headerlink" title="算法特性"></a>算法特性</h3><ul>
<li><p>非原地： 辅助数组tmp 需要使用额外空间。</p>
</li>
<li><p>稳定： 归并排序不改变相等元素的相对顺序。</p>
</li>
<li><p>非自适应： 对于任意输入数据，归并排序的时间复杂度皆相同。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Data Structure and Algorithm</category>
      </categories>
      <tags>
        <tag>Data Structure and Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Daily Coding</title>
    <url>/2021/04/06/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Daily-Coding"><a href="#Daily-Coding" class="headerlink" title="Daily Coding"></a>Daily Coding</h1><blockquote>
<p>记录刷《剑指offer》的笔记和心得，持续更新中……</p>
</blockquote>
<h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><h3 id="Q1：用两个栈实现队列"><a href="#Q1：用两个栈实现队列" class="headerlink" title="Q1：用两个栈实现队列"></a>Q1：用两个栈实现队列</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h4><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<h4 id="我的思路"><a href="#我的思路" class="headerlink" title="我的思路"></a><strong>我的思路</strong></h4><p>两个栈s1,s2;栈1用来入队，当需要删除队首元素时，将s1中的元素push进s2,在栈s2中完成出队操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CQueue &#123;</span><br><span class="line">public:</span><br><span class="line">     stack&lt;int&gt; s1;</span><br><span class="line">     stack&lt;int&gt; s2;</span><br><span class="line">    CQueue() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void appendTail(int value) &#123;</span><br><span class="line">       </span><br><span class="line">     if(!this-&gt;s2.empty())</span><br><span class="line">     &#123;</span><br><span class="line">         while(!this-&gt;s2.empty())</span><br><span class="line">         &#123;</span><br><span class="line">             this-&gt;s1.push(this-&gt;s2.top());</span><br><span class="line">             this-&gt;s2.pop();</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         this-&gt;s1.push(value);</span><br><span class="line">     &#125;  </span><br><span class="line"></span><br><span class="line">     else </span><br><span class="line">     &#123;</span><br><span class="line">         this-&gt;s1.push(value);</span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int deleteHead() &#123;</span><br><span class="line">         int tail;</span><br><span class="line">        if(!this-&gt;s1.empty()&amp;&amp;this-&gt;s2.empty())&#123;</span><br><span class="line">            while(!this-&gt;s1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                this-&gt;s2.push(this-&gt;s1.top());</span><br><span class="line">                this-&gt;s1.pop();</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">            tail = this-&gt;s2.top();</span><br><span class="line">               this-&gt;s2.pop();</span><br><span class="line">               return tail;</span><br><span class="line">        else </span><br><span class="line">            return -1;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="参考思路"><a href="#参考思路" class="headerlink" title="参考思路"></a>参考思路</h4><p>函数设计：<br><strong>加入队尾 appendTail()</strong> ： 将数字 val 加入栈 A 即可。<br><strong>删除队首deleteHead()</strong> ： 有以下三种情况。<br>当栈 B 不为空： B中仍有已完成倒序的元素，因此直接返回 B 的栈顶元素。<br>否则，当 A 为空： 即两个栈都为空，无元素，因此返回 -1 。<br>否则： 将栈 A 元素全部转移至栈 B 中，实现元素倒序，并返回栈 B 的栈顶元素。</p>
<p><strong>基本思路与我的思路一致，但是在我的思路在入队操作时效率太低。在新加入元素时无需再将s2中的元素倒入s1，直接push进s1</strong></p>
<p>在出队操作时，如果s2中有元素，则直接返回栈顶元素</p>
<p>否则将s1中的元素倒入s2中后返回栈顶元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class CQueue &#123;</span><br><span class="line">public:</span><br><span class="line">    stack&lt;int&gt; A, B;</span><br><span class="line">    CQueue() &#123;&#125;</span><br><span class="line">    void appendTail(int value) &#123;</span><br><span class="line">        A.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    int deleteHead() &#123;</span><br><span class="line">        if(!B.empty()) &#123;</span><br><span class="line">            int tmp = B.top();</span><br><span class="line">            B.pop();</span><br><span class="line">            return tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        if(A.empty()) return -1;</span><br><span class="line">        while(!A.empty()) &#123;</span><br><span class="line">            int tmp = A.top();</span><br><span class="line">            A.pop();</span><br><span class="line">            B.push(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        int tmp = B.top();</span><br><span class="line">        B.pop();</span><br><span class="line">        return tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Q2-包含-min-函数的栈"><a href="#Q2-包含-min-函数的栈" class="headerlink" title="Q2:  包含 min 函数的栈"></a>Q2:  包含 min 函数的栈</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<h4 id="我的思路-amp-amp-参考思路"><a href="#我的思路-amp-amp-参考思路" class="headerlink" title="我的思路&amp;&amp;参考思路"></a>我的思路&amp;&amp;参考思路</h4><p>创建一个辅助栈，用来储存最小值，按非严格降序排列，防止最小值提前弹出</p>
<p>易错点：最小值可能会弹出，所以不能单独用一个int Min 记录最小值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">public:</span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">    stack&lt;int&gt; s , Min;</span><br><span class="line">    MinStack() &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void push(int x) &#123;</span><br><span class="line"></span><br><span class="line">        s.push(x);</span><br><span class="line">        if(Min.empty() || x &lt;= Min.top())</span><br><span class="line">            Min.push(x);</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void pop() &#123;</span><br><span class="line"></span><br><span class="line">       if (s.top() == Min.top())</span><br><span class="line">            Min.pop();</span><br><span class="line">       s.pop();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int top() &#123;</span><br><span class="line">        return  s.top();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int min() &#123;</span><br><span class="line">        return Min.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Your MinStack object will be instantiated and called as such:</span><br><span class="line"> * MinStack* obj = new MinStack();</span><br><span class="line"> * obj-&gt;push(x);</span><br><span class="line"> * obj-&gt;pop();</span><br><span class="line"> * int param_3 = obj-&gt;top();</span><br><span class="line"> * int param_4 = obj-&gt;min();</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><h3 id="Q3：从尾到头打印链表"><a href="#Q3：从尾到头打印链表" class="headerlink" title="Q3：从尾到头打印链表"></a>Q3：从尾到头打印链表</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<h4 id="我的思路-1"><a href="#我的思路-1" class="headerlink" title="我的思路"></a><strong>我的思路</strong></h4><p>先顺序插入vector v再倒序遍历放入另一个vector vv</p>
<h4 id="参考思路-1"><a href="#参考思路-1" class="headerlink" title="参考思路"></a><strong>参考思路</strong></h4><p><strong>方法一</strong></p>
<p>利用递归，先递推至链表末端；回溯时，依次将节点值加入列表，即可实现链表值的倒序输出。</p>
<p><strong>方法二</strong></p>
<p>链表只能 从前至后 访问每个节点，而题目要求 倒序输出 各节点值，这种 先入后出 的需求可以借助 栈 来实现。</p>
<p>算法流程：<br>入栈： 遍历链表，将各节点值 push 入栈。<br>出栈： 将各节点值 pop 出栈，存储于数组并返回。</p>
<h3 id="Q4-：反转链表"><a href="#Q4-：反转链表" class="headerlink" title="Q4 ：反转链表"></a>Q4 ：反转链表</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<h4 id="我的思路-2"><a href="#我的思路-2" class="headerlink" title="我的思路"></a><strong>我的思路</strong></h4><p>在顺序遍历链表的同时，利用两个指针 preP，nextP ，nextP指向上一次访问的位置，preP当前访问的位置，通过设置preP-&gt;next &#x3D; nextP，创建一个新的倒序链表</p>
<p><strong>反思</strong></p>
<p>我的大致思路的对的，但是错误的使用的指针，破坏了原来的链表，导致遍历失败。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* reverseList(ListNode* head) &#123;</span><br><span class="line"></span><br><span class="line">        ListNode* nextP = NULL;</span><br><span class="line">        ListNode* tmp = NULL;</span><br><span class="line">        while(head != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = head-&gt;next;  //暂存next结点</span><br><span class="line">            head-&gt;next = nextP;</span><br><span class="line">            nextP = head;</span><br><span class="line">            head = tmp ;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        return nextP ;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="参考思路-2"><a href="#参考思路-2" class="headerlink" title="参考思路"></a>参考思路</h4><p>本质思路与我一致，考虑遍历链表，并在访问各节点时修改 <code>next</code> 引用指向。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head, *pre = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* tmp = cur-&gt;next; <span class="comment">// 暂存后继节点 cur.next</span></span><br><span class="line">            cur-&gt;next = pre;           <span class="comment">// 修改 next 引用指向</span></span><br><span class="line">            pre = cur;                 <span class="comment">// pre 暂存 cur</span></span><br><span class="line">            cur = tmp;                 <span class="comment">// cur 访问下一节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="Q5：复杂链表的复制"><a href="#Q5：复杂链表的复制" class="headerlink" title="Q5：复杂链表的复制"></a>Q5：复杂链表的复制</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<h4 id="我的思路-3"><a href="#我的思路-3" class="headerlink" title="我的思路"></a>我的思路</h4><p>不知如何在遍历原链表时，怎么设置random指针</p>
<h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><h3 id="Q7：左旋转字符串"><a href="#Q7：左旋转字符串" class="headerlink" title="Q7：左旋转字符串"></a>Q7：左旋转字符串</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<h4 id="我的题解"><a href="#我的题解" class="headerlink" title="我的题解"></a>我的题解</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string reverseLeftWords(string s, int n) &#123;</span><br><span class="line"></span><br><span class="line">        /*解法一：使用STL 切片，但效率较低*/</span><br><span class="line">        // string substr = s.substr(0,n);</span><br><span class="line">        // s.erase(0,n);</span><br><span class="line">        // s.append(substr);</span><br><span class="line">        </span><br><span class="line">         /*解法二：使用迭代指针和STL，编译出现错误？？？*/</span><br><span class="line">        // string::iterator it=s.begin();</span><br><span class="line">        // unsigned int len = s.length();</span><br><span class="line">        // //string::iterator endpos=s.end();</span><br><span class="line">        // for(int i = 0 ; i &lt; n ; i ++)</span><br><span class="line">        // &#123;</span><br><span class="line">        //     s.insert(len,s[0]);</span><br><span class="line">        //     it=s.erase(it);</span><br><span class="line"></span><br><span class="line">        // &#125;</span><br><span class="line">        </span><br><span class="line">         /*解法三：使用reverse，效率最高*/</span><br><span class="line">        reverse(s.begin(), s.begin() + n);</span><br><span class="line">        reverse(s.begin() + n, s.end());</span><br><span class="line">        reverse(s.begin(), s.end());</span><br><span class="line">        return s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><h3 id="Q8：-数组中重复的数字"><a href="#Q8：-数组中重复的数字" class="headerlink" title="Q8： 数组中重复的数字"></a>Q8： 数组中重复的数字</h3><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<h4 id="我的思路-4"><a href="#我的思路-4" class="headerlink" title="我的思路"></a>我的思路</h4><p>哈希表</p>
<h4 id="参考思路-3"><a href="#参考思路-3" class="headerlink" title="参考思路"></a>参考思路</h4><p>哈希表或者<strong>原地交换</strong>。<strong>原地交换</strong>的空间效率更优</p>
<p>算法流程：<br>遍历数组 numsnums ，设索引初始值为 i &#x3D; 0i&#x3D;0 :</p>
<p>若 nums[i] &#x3D; inums[i]&#x3D;i ： 说明此数字已在对应索引位置，无需交换，因此跳过；<br>若 nums[nums[i]] &#x3D; nums[i]nums[nums[i]]&#x3D;nums[i] ： 代表索引 nums[i]nums[i] 处和索引 ii 处的元素值都为 nums[i]nums[i] ，即找到一组重复值，返回此值 nums[i]nums[i] ；<br>否则： 交换索引为 ii 和 nums[i]nums[i] 的元素值，将此数字交换至对应索引位置。<br>若遍历完毕尚未返回，则返回 -1−1 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int findRepeatNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">          </span><br><span class="line">          map&lt;int,int&gt; m;</span><br><span class="line">          int len = nums.size();</span><br><span class="line">          int i =0;</span><br><span class="line">          while(i&lt;len)</span><br><span class="line">          &#123;</span><br><span class="line">              //方法一：哈希表</span><br><span class="line">                // m[nums[i]]+=1;</span><br><span class="line">                // if(m[nums[i]] &gt; 1)</span><br><span class="line">                //     return nums[i];</span><br><span class="line">            /*方法二：原地交换*/</span><br><span class="line">            if(nums[i] == i) &#123;i++;continue;&#125;</span><br><span class="line">            if(nums[nums[i]] == nums[i])</span><br><span class="line">                return nums[i];</span><br><span class="line">            swap(nums[i],nums[nums[i]]);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">             return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Q9：在排序数组中查找数字-I"><a href="#Q9：在排序数组中查找数字-I" class="headerlink" title="Q9：在排序数组中查找数字 I"></a>Q9：在排序数组中查找数字 I</h3><p>统计一个数字在排序数组中出现的次数。</p>
<h4 id="我的思路-5"><a href="#我的思路-5" class="headerlink" title="我的思路"></a>我的思路</h4><p>二分查找，找到target值后再从左右临近寻找重复值</p>
<p>注意：二分法易写错！</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int search(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        </span><br><span class="line">        int len =nums.size();</span><br><span class="line">        int low = 0 , high = len - 1 ,mid;</span><br><span class="line">        int count = 1;</span><br><span class="line">        while(low &lt;= high)&#123;</span><br><span class="line">            mid = ( low + high ) / 2;</span><br><span class="line">            if(nums[mid] == target)&#123;</span><br><span class="line">                  </span><br><span class="line">                  int i = mid-1 , j=mid+1 ;</span><br><span class="line">                  while( i &gt;=0)&#123;</span><br><span class="line">                      if(nums[i] !=target) break;</span><br><span class="line">                      if(nums[i] == target) count++;</span><br><span class="line">                      i--;</span><br><span class="line">                  &#125;</span><br><span class="line">                  while( j&lt;len)&#123;</span><br><span class="line">                      if(nums[j] !=target) break;</span><br><span class="line">                      if(nums[j] == target) count++;</span><br><span class="line">                      j++;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  return count;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            else if(nums[mid] &gt; target)  high = mid-1;</span><br><span class="line">            else low = mid+1;</span><br><span class="line">        &#125;</span><br><span class="line">               return 0;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="参考思路-4"><a href="#参考思路-4" class="headerlink" title="参考思路"></a>参考思路</h4><p>同样的二分法，差别在于参考思路用两次二分法寻找左边界和右边界，然后相减</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(nums, target) - <span class="built_in">helper</span>(nums, target - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> tar)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">            <span class="type">int</span> m = (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[m] &lt;= tar) i = m + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> j = m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Q10：-0～n-1-中缺失的数字"><a href="#Q10：-0～n-1-中缺失的数字" class="headerlink" title="Q10： 0～n-1 中缺失的数字"></a>Q10： 0～n-1 中缺失的数字</h3><p>一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<h4 id="我的思路-6"><a href="#我的思路-6" class="headerlink" title="我的思路"></a>我的思路</h4><p>二分法</p>
<p>易错点：注意只有一个元素的边界情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int missingNumber(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        int len = nums.size();</span><br><span class="line">        int low = 0 , high =len-1 ,mid;</span><br><span class="line">        while(low&lt;=high)&#123;</span><br><span class="line">            mid = (low+high)/2;</span><br><span class="line">            if(nums[mid] ==mid)  low=mid+1;</span><br><span class="line">            else if(nums[mid] &gt; mid) high=mid-1;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="参考思路-5"><a href="#参考思路-5" class="headerlink" title="参考思路"></a>参考思路</h4><ul>
<li>暴力法</li>
<li>二分法（效率最好）</li>
<li>数学方法</li>
</ul>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220406214453.png" alt="image-20220210201503037"></p>
<h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><h3 id="Q11：二维数组中的查找"><a href="#Q11：二维数组中的查找" class="headerlink" title="Q11：二维数组中的查找"></a>Q11：二维数组中的查找</h3><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h4 id="我的思路-7"><a href="#我的思路-7" class="headerlink" title="我的思路"></a>我的思路</h4><p>依次访问每一列的数据。对于每一列数据，进行二分查找。每访问完一行数据，缩小二分查找的右边界。如果matirx[i] [j] &gt;target则大于等于的列数都不再访问。</p>
<h4 id="参考思路-6"><a href="#参考思路-6" class="headerlink" title="参考思路"></a>参考思路</h4><p> <img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220406214454.png" alt="image-20220213124702441"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool findNumberIn2DArray(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123;</span><br><span class="line">        </span><br><span class="line">        if (matrix.empty())  return false;</span><br><span class="line">        int n = matrix.size();</span><br><span class="line">        int m = matrix[0].size();</span><br><span class="line">        int i=n-1,j=0;</span><br><span class="line">        while(i&gt;=0 &amp;&amp; j &lt; m)&#123;</span><br><span class="line">            if(matrix[i][j] == target)   return true;</span><br><span class="line">            else if(matrix[i][j] &gt;target) i--;</span><br><span class="line">            else j++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h2><h3 id="Q12-旋转数组的最小数字"><a href="#Q12-旋转数组的最小数字" class="headerlink" title="Q12 : 旋转数组的最小数字"></a>Q12 : 旋转数组的最小数字</h3><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。</p>
<p>给你一个可能存在 重复 元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。  </p>
<h4 id="我的思路-8"><a href="#我的思路-8" class="headerlink" title="我的思路"></a>我的思路</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minArray(vector&lt;int&gt;&amp; numbers) &#123;</span><br><span class="line">            int len = numbers.size();</span><br><span class="line">            //如果数组长度为1或者数组未旋转</span><br><span class="line">            if(len == 1 || (numbers[0]&lt;numbers[len-1]))  return numbers[0];</span><br><span class="line">            //二分查找，判断mid位于左排序队列还是右排序队列</span><br><span class="line">            int low = 0 , high = len - 1;</span><br><span class="line">            while(low&lt;=high)&#123;</span><br><span class="line">                int mid = (low+high) / 2;</span><br><span class="line">                if(mid!=0 &amp;&amp;mid !=len-1)&#123;</span><br><span class="line">                    //如果mid-1，mid，mid+1 递减，则找到最小值，直接返回</span><br><span class="line">                    if(numbers[mid]&lt;numbers[mid-1]</span><br><span class="line">                     )  </span><br><span class="line">                     return numbers[mid];</span><br><span class="line">                     if(numbers[mid]&gt;numbers[mid+1])</span><br><span class="line">                     return numbers[mid+1];</span><br><span class="line">                    else&#123; //mid-1 mid mid+1 非递减</span><br><span class="line">                       //mid位于左排序队列</span><br><span class="line">                        if(numbers[mid+1] &gt; numbers[0]) low=mid+1;</span><br><span class="line">                        //mid位于右排序队列</span><br><span class="line">                        else if(numbers[mid+1] &lt; numbers[0]) high=mid-1;</span><br><span class="line">                        else&#123; //当无法判断位于左排序队列还是右排序队列时</span><br><span class="line">                          //判断mid-1，如果mid-1&lt;number,则位于左排序队列</span><br><span class="line">                          if(numbers[mid-1] &lt; numbers[0])  high =mid-1;</span><br><span class="line">                          else &#123;</span><br><span class="line">                              //缩小搜索范围</span><br><span class="line">                              if(numbers[high]&gt;=numbers[high-1])</span><br><span class="line">                              high--;</span><br><span class="line">                              else  return numbers[high];</span><br><span class="line">                              if(numbers[low]&lt;=numbers[low+1])</span><br><span class="line">                              low++;</span><br><span class="line">                              else return numbers[low+1];</span><br><span class="line">                              &#125; </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                else return min(numbers[low],numbers[high]);</span><br><span class="line">                </span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">            return numbers[0];//min(numbers[high],numbers[low]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="参考思路-7"><a href="#参考思路-7" class="headerlink" title="参考思路"></a>参考思路</h4><p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220406214455.png" alt="image-20220213164617610"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int minArray(vector&lt;int&gt;&amp; numbers) &#123;</span><br><span class="line">        int i = 0, j = numbers.size() - 1;</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            int m = (i + j) / 2;</span><br><span class="line">            if (numbers[m] &gt; numbers[j]) i = m + 1;</span><br><span class="line">            else if (numbers[m] &lt; numbers[j]) j = m;</span><br><span class="line">            else j--;</span><br><span class="line">        &#125;</span><br><span class="line">        return numbers[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Day7"><a href="#Day7" class="headerlink" title="Day7"></a>Day7</h2><h2 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h2><h3 id="Q16：树的子结构"><a href="#Q16：树的子结构" class="headerlink" title="Q16：树的子结构"></a>Q16：树的子结构</h3><p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220406214456.png" alt="image-20220215154425267"></p>
<h4 id="我的思路-9"><a href="#我的思路-9" class="headerlink" title="我的思路"></a>我的思路</h4><p>深度优先遍历，寻找与B相同的TreeNode</p>
<p><strong>错误！！！</strong>：不能用简单的&#x3D;&#x3D;号判断两者是否相等。而且题目中要求是判断是否为子结构，而不是子树</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isSubStructure(TreeNode* A, TreeNode* B) &#123;</span><br><span class="line">        return visit(A,B);   </span><br><span class="line">    &#125;</span><br><span class="line">    bool visit(TreeNode *cur ,TreeNode *B)&#123;</span><br><span class="line"></span><br><span class="line">        if(cur == B) return true;</span><br><span class="line">        if(!cur-&gt;left&amp;&amp;!cur-&gt;right)  return false;</span><br><span class="line">        else if(cur-&gt;left&amp;&amp;!cur-&gt;right) return visit(cur-&gt;left,B);</span><br><span class="line">        else if(!cur-&gt;left&amp;&amp;cur-&gt;right) return visit(cur-&gt;right,B);</span><br><span class="line">        else return  visit(cur-&gt;left,B) || visit(cur-&gt;right,B);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="参考思路-8"><a href="#参考思路-8" class="headerlink" title="参考思路"></a>参考思路</h4><p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220406214457.png" alt="image-20220215154846992"></p>
<h3 id="Q17：二叉树镜像"><a href="#Q17：二叉树镜像" class="headerlink" title="Q17：二叉树镜像"></a>Q17：二叉树镜像</h3><p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220406214458.png" alt="image-20220215175323237"></p>
<h4 id="我的思路-10"><a href="#我的思路-10" class="headerlink" title="我的思路"></a>我的思路</h4><p>深度遍历二叉树，交换其左右子树</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    TreeNode* mirrorTree(TreeNode* root) &#123;</span><br><span class="line">        if(root) reverseTree(root);</span><br><span class="line">        return root;</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void reverseTree(TreeNode*root )&#123;</span><br><span class="line">        </span><br><span class="line">          TreeNode* rightchild = root-&gt;right;</span><br><span class="line">          root-&gt;right =root-&gt;left;</span><br><span class="line">          root-&gt;left = rightchild;</span><br><span class="line">          if(root-&gt;left)  reverseTree(root-&gt;left);</span><br><span class="line">          if(root-&gt;right)  reverseTree(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h3 id="Q18：对称的二叉树"><a href="#Q18：对称的二叉树" class="headerlink" title="Q18：对称的二叉树"></a>Q18：对称的二叉树</h3><p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220406214459.png" alt="image-20220215175501854"></p>
<h4 id="我的思路-11"><a href="#我的思路-11" class="headerlink" title="我的思路"></a>我的思路</h4><p>层序遍历二叉树，判断每一层的数据是否对称</p>
<h4 id="参考思路-9"><a href="#参考思路-9" class="headerlink" title="参考思路"></a>参考思路</h4><p>深度优先遍历。递归判断左右两颗子树是否对称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool isSymmetric(TreeNode* root)&#123;</span><br><span class="line">    if(!root)  return true;</span><br><span class="line">    return issymmetric(root-&gt;left,root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line">bool issymmetric(TreeNode* A,TreeNode* B)&#123;</span><br><span class="line">    if(!A &amp;&amp; !B)  return true;</span><br><span class="line">    if(!A || !B || A-&gt;val!=B-&gt;val)  return false;</span><br><span class="line">    return  issymmetric(A-&gt;left,B-&gt;right) &amp;&amp; issymmetric(A-&gt;right,B-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Day9"><a href="#Day9" class="headerlink" title="Day9"></a>Day9</h2><h3 id="Q19：两个链表的第一个公共节点"><a href="#Q19：两个链表的第一个公共节点" class="headerlink" title="Q19：两个链表的第一个公共节点"></a>Q19：两个链表的第一个公共节点</h3><p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220406214500.png" alt="image-20220217225342393"></p>
<h4 id="我的思路-12"><a href="#我的思路-12" class="headerlink" title="我的思路"></a>我的思路</h4><p>利用哈希表存储链表中的每一个结点，再去链表B中寻找</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">              map&lt;ListNode*,bool&gt; m;</span><br><span class="line">              ListNode *A =headA;</span><br><span class="line">              ListNode *B =headB;</span><br><span class="line">              while(A )&#123;</span><br><span class="line">               m[A] = true;</span><br><span class="line">               A = A-&gt;next;</span><br><span class="line">              &#125;</span><br><span class="line">              while(B)&#123;</span><br><span class="line">                  if(m.find(B) != m.end())  return B;</span><br><span class="line">                  B = B-&gt;next;</span><br><span class="line">              &#125;</span><br><span class="line">              return nullptr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="参考思路-10"><a href="#参考思路-10" class="headerlink" title="参考思路"></a>参考思路</h4><p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220406214501.png" alt="image-20220217231507610"></p>
<blockquote>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220406214658.png" alt="image-20220406214655379"></p>
<p>每次看查看参考思路和代码，都觉得太妙了，我悟了，赞不绝口。一看评论区，好吧，还是结宙老师的境界高</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;</span><br><span class="line">        ListNode *A = headA, *B = headB;</span><br><span class="line">        while (A != B) &#123;</span><br><span class="line">            A = A != nullptr ? A-&gt;next : headB;</span><br><span class="line">            B = B != nullptr ? B-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        return A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Day10-11"><a href="#Day10-11" class="headerlink" title="Day10,11"></a>Day10,11</h2><h3 id="Q20：数据流中的中位数"><a href="#Q20：数据流中的中位数" class="headerlink" title="Q20：数据流中的中位数"></a>Q20：数据流中的中位数</h3><blockquote>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p>
<p>例如，</p>
<p>[2,3,4] 的中位数是 3</p>
<p>[2,3] 的中位数是 (2 + 3) &#x2F; 2 &#x3D; 2.5</p>
<p>设计一个支持以下两种操作的数据结构：</p>
<p>void addNum(int num) - 从数据流中添加一个整数到数据结构中。<br>double findMedian() - 返回目前所有元素的中位数。</p>
</blockquote>
<h4 id="我的思路-13"><a href="#我的思路-13" class="headerlink" title="我的思路"></a>我的思路</h4><p>使用双链表存储数组。维护链表的中位数结点</p>
<p>缺点：当初考虑链表主要是因为其插入速度快，但是其查找速度慢。</p>
<p>思考：查找和插入速度都佳的结构肯定是<strong>树</strong></p>
<h4 id="参考思路-11"><a href="#参考思路-11" class="headerlink" title="参考思路"></a>参考思路</h4><p>将数据分为两组，使用两个堆，一个大根堆A，一个小根堆B分别存储</p>
<p>（C++中priority_queue优先队列使用的堆结构，greater是小根堆，less是大根堆）</p>
<ol>
<li><p>A大根堆用来存储数据较小的一组</p>
</li>
<li><p>B用来存储数据较大的一组</p>
</li>
<li><p>所以求中位数只需返回大小堆的根</p>
</li>
</ol>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220406214502.png" alt="image-20220405222929119"></p>
<p><strong>时间复杂度</strong></p>
<p>堆的插入复杂度$O(logN)$  , 返回根的代价$O(1)$ </p>
]]></content>
      <categories>
        <category>Data Structure and Algorithm</category>
      </categories>
      <tags>
        <tag>Data Structure and Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>FUSO论文阅读笔记</title>
    <url>/2022/04/07/FUSO/</url>
    <content><![CDATA[<blockquote>
<p>该文《Fast and Cautious: Leveraging Multi-path Diversity for Transport Loss Recovery in Data Centers》介绍了一种利用DCN中多路径多样性特性进行输运损失恢复的新型分组损失恢复方法FUSO（Fast Multi-path Loss Recovery ）</p>
<p>FUSO主要有两个特性：</p>
<ol>
<li>fast：它不需要在有损耗的子流上等待超时</li>
<li>cautious：它不违反拥塞控制算法</li>
</ol>
<p>试验台实验和仿真结果表明在1Gbps的试验台中，FUSO可将对延迟敏感的流量的 99^th^FCT（ flow completion time）降低约82.3%，而在10Gbps的大规模模拟网络中则可降低约87.9%。</p>
</blockquote>
<h2 id="预置知识"><a href="#预置知识" class="headerlink" title="预置知识"></a>预置知识</h2><ul>
<li><p>FTP（ flow completion time）</p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/277593169">MPTCP</a></p>
</li>
<li><p>RTO</p>
</li>
</ul>
<h2 id="快速多路径丢失恢复（FUSO）"><a href="#快速多路径丢失恢复（FUSO）" class="headerlink" title="快速多路径丢失恢复（FUSO）"></a>快速多路径丢失恢复（FUSO）</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>FUSO建立在多路径传输的基础上，多路径传输将一个TCP流划分为多个子流。FUSO侧重于多路径丢失恢复，而不是多路径拥塞控制。</p>
<p>FUSO的<strong>核心思想</strong>是，在严格遵守拥塞控制的情况下，如果存在空闲拥塞窗口(cwnd)， FUSO首先尝试发送新的数据。如果上层应用程序目前没有新数据，<strong>FUSO利用这个传输机会，通过利用“good”子流，主动&#x2F;立即发送“bad”子流上预期可能丢失(un-ACKed)报文的恢复报文。</strong>注意，FUSO不影响现有的MPTCP机会重传机制，该机制由全接收窗口触发。这两种机制可以相互补充。</p>
<p>接下来我们分别讨论发送端和接收端的所做的工作</p>
<h3 id="发送端"><a href="#发送端" class="headerlink" title="发送端"></a>发送端</h3><p>FUSO发送端主动恢复多路径丢失过程可以概括为Alogo.1.</p>
<p><img src="https://pic-1310557869.cos.ap-beijing.myqcloud.com/img/20220407090641.png" alt="image-20220407090638114"></p>
<h4 id="TRY-SEND-RECOVERIES"><a href="#TRY-SEND-RECOVERIES" class="headerlink" title="TRY SEND RECOVERIES()"></a>TRY SEND RECOVERIES()</h4><p>具体来说，发送端我们在传输栈中插入一个函数<code>TRY SEND RECOVERIES()</code>，监视BytesInFlight<del>Total</del>，CWND<del>Total</del>和应用程序数</p>
<p>这个函数需要插入到两个位置:</p>
<p>i) 在应用程序传递的所有数据被推入传输发送缓冲区并发送出去之后，目前没有新的数据从上层应用程序传递出去;</p>
<p>ii) 接收到ACK后，传输状态(如BytesInFlight<del>Total</del>, CWND<del>Total</del>)已经改变。</p>
<p>在这个函数中，如果满足以下两个条件，发送方调用SEND A RECOVERY()函数发送一个恢复包:</p>
<p>i) 拥塞控制允许有空闲的窗口容量</p>
<p>ii) 所有新数据都已发送出去。</p>
<h4 id="SEND-A-RECOVERY"><a href="#SEND-A-RECOVERY" class="headerlink" title="SEND A RECOVERY()"></a>SEND A RECOVERY()</h4><p>在函数<code>SEND A RECOVERY()</code>中，FUSO发送者首先调用函数FIND WORST SUB-FLOW()和FIND BEST SUB-FLOW()可以找到当前最差和最好的子流。</p>
<p>在存在un-ACKed 数据的子流选择最差子流，在拥塞窗口(cwnd)中有拥塞控制允许的空闲空间的子流中选择最佳子流。至于具体选择子流的策略我们会在下文继续讨论</p>
<p>如果目前没有最坏或最好的子流，此轮FUSO停止生成恢复报文。接下来，如果找到了最差和最好的子流，则生成最差子流的恢复包。因为在DACKs或RTO检测到数据包丢失之前，FUSO会进行主动的丢包恢复，我们必须猜测哪个包最有可能丢失。</p>
<p>FUSO推断该报文是最差子流上发出时间最长的最早的未被ack的报文。因此，发送端主动为最坏路径上的一个未被ack报文生成一个恢复报文</p>
<p>为了避免给网络增加过多不必要的流量，在FUSO中采用主动丢失恢复方案，一个未被ack的报文最多发送一次。</p>
<p>恢复报文生成后，FUSO发送端通过最佳子流发送恢复报文。注意，恢复数据包被视为最佳子流的新数据包。恢复包处于最佳子流的拥塞控制下，如果在最佳子流中丢失，则使用标准的TCP丢失恢复将在最佳子流中作为正常数据包重传。但是，为了避免重复恢复，当FUSO发送端稍后进行快速多路径丢失恢复时，这些报文不会被计入等待恢复的unack报文中。</p>
<h3 id="路径选择"><a href="#路径选择" class="headerlink" title="路径选择"></a>路径选择</h3><p>如何选择最佳子流和最差子流？</p>
<h4 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h4><p>我们定义 $C_l &#x3D; α ·lossrate + β · lossratelast$描述子流中发生丢包的可能性。</p>
<p>$C_l$​是该子流中总丢包率(lossrate)和最近丢包率(lossrate<del>last</del>)的加权和。α, β为各部分的权重。</p>
<p>由于TCP&#x2F;MPTCP在检测到数据包被DACK或RTO丢失后会重传，FUSO使用重传的总包数与传输的总包数的比值作为近似的丢包率。需要注意的是，FUSO生成的恢复包将被视为新的报文，而不是子流的重传报文。lossrate<del>last</del>计算为1&#x2F;上次重传发送的包数。</p>
<h4 id="最差子流"><a href="#最差子流" class="headerlink" title="最差子流"></a>最差子流</h4><p>最差的子流是在那些至少有一个未被ack包(可能丢失)和C<del>l</del>最大的子流中挑选出来的。对于从未遇到过重传的子流，其C<del>l</del>&#x3D; 0。如果所有子流程的C<del>l</del>均为零，则FUSO选择RTT最大的子流程，从而优化整体FCT。</p>
<h4 id="最优子流"><a href="#最优子流" class="headerlink" title="最优子流"></a>最优子流</h4><p>最佳子流在有空闲cwnd、C<del>l</del>值最小的子流中选择。</p>
<ul>
<li>对于从未遇到重传输的子流，它们的C<del>l</del>等于零，且小于其他子流。</li>
<li>如果超过一个子流的C<del>l</del>为零，FUSO选择RTT最小的子流为最佳子流。</li>
<li>在初始状态下，当FUSO开始主动恢复包时，一些子流程可能从未传输过任何数据。当FUSO选择最优子流时，这些子流的C<del>l</del>值为无穷大且具有最低优先级。</li>
<li>在所有子流C<del>l</del> &#x3D;∞的情况下，FUSO随机选取其中一个子流为最佳子流。</li>
<li>最好的和最差的子流可能是同一个。在这种情况下，FUSO只是简单地将恢复报文在原始报文之后的同一子流中发送。</li>
</ul>
<h3 id="接收端"><a href="#接收端" class="headerlink" title="接收端"></a>接收端</h3><p>FUSO接受端相对简单，在多路传输协议，如MPTCP，接收端有一个数据级的接受缓存区，每一个子流都有都有一个虚拟的接收缓存区映射到这个数据级的接受缓存区。</p>
<p>在接收到FUSO恢复报文后，FUSO接收端直接将恢复报文插入到数据级接收缓冲区的相应位置，完成流传输。</p>
<p>对于传输FUSO恢复报文的最佳子流，从该子流的拥塞控制和原始TCP的丢失恢复来看，这些报文自然被认为是正常的数据包。虽然受到了它们的保护，但坏子流并不知道这些恢复包，并可能不必要地重新传输旧数据包。</p>
<h3 id="Further-Study"><a href="#Further-Study" class="headerlink" title="Further Study"></a>Further Study</h3><p>目前，FUSO选择了这样一种简单的方法，在单个子流和整体多路径传输流上保持精确的拥塞控制行为，并且不增加攻击行为。它不需要在发送端和接收端之间进行进一步的协调，除了TCP中原有的ACK方案，<strong>但可能会引起一些冗余的重传</strong>。消除冗余重传的一种简单的解决方法是，接收端在收到来自其他良好子流的恢复报文后，主动为坏子流的原始报文生成ack。</p>
<p>然而，这可能会导致拥塞控制的不利影响。具体来说，坏子流的发送端可能会错误地将路径判断为良好状态，从而增加其发送速率，加剧损失。</p>
<p>为了保持拥塞控制行为和消除冗余重传，可能需要对MCTCP&#x2F;TCP协议进行非常复杂的修改。发送方和接收方必须协调决定是否&#x2F;如何改变每个子流的拥塞控制行为(例如，增加&#x2F;减少拥塞窗口的数量)，以应对各种情况，如</p>
<ul>
<li>收到了主动重传但丢失了原始包;</li>
<li>收到了原始包但丢失了主动重传;</li>
<li>两个包都丢失;</li>
</ul>
<p>这种解决方案的可行性和如何设计还需要进一步研究，是我们未来的工作。目前，FUSO选择了一些多余的重传以换取上述简单和低成本的方法。</p>
<p>论文地址：<a href="https://1989chenguo.github.io/Publications/FUSO-ATC16.pdf">https://1989chenguo.github.io/Publications/FUSO-ATC16.pdf</a></p>
]]></content>
      <categories>
        <category>computer network notes</category>
      </categories>
      <tags>
        <tag>computer network</tag>
        <tag>MPTCP</tag>
      </tags>
  </entry>
</search>
